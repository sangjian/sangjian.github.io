<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[计算机中浮点数的二进制表示]]></title>
      <url>http://www.ideabuffer.cn/2017/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>最近看了一些代码，忽然发现double类型的数据可表示的范围比long类型的数据表示的范围要大的多，同样是占用64位大小，差距竟如此之大。后来发现，工作了两三年，竟然现在还不太熟悉计算机中浮点数的表示方式，确实有些惭愧。</p>
<p>下面的内容参考自《深入理解计算机系统（原书第三版）》。</p>
<h2 id="IEEE-浮点表示"><a href="#IEEE-浮点表示" class="headerlink" title="IEEE 浮点表示"></a>IEEE 浮点表示</h2><p>IEEE浮点标准用 $V=(-1)^s\times M\times 2^E$ 来表示一个数：</p>
<ul>
<li>符号（sign）：$s$ 决定是负数（$s=1$）还是正数（$s=0$）；</li>
<li>尾数（significand）：$M$ 是一个二进制小数，它的范围是$1\thicksim 2-\varepsilon$，或者是$0\thicksim 1-\varepsilon$；</li>
<li>阶码（exponent）：$E$ 代表2的次幂（可能是负数）。</li>
</ul>
<a id="more"></a>
<p>在计算机中，把浮点数的位表示划分为3段：</p>
<ol>
<li>一个单独的符号位 $s$；</li>
<li>$k$ 位的阶码字段 $exp=e_{k-1}\cdots e_1e_0$ 编码阶码 $E$；</li>
<li>$n$ 位小数字段 $frac=f_{n-1}\cdots f_1f_0$ 编码尾数 $M$，编码出来的值依赖于阶码字段的值是否等于0。</li>
</ol>
<p>举例来说：</p>
<p>10进制中的 $9.0$ 在二进制中写成 $1001.0$，也就是 $1.001\times 2^3$，按照上面的格式，可以算出 $s=0$， $M=1.001$， $E=3$。</p>
<p>10进制中的 $-9.0$ 在二进制中写成 $-1001.0$ ，也就是 $-1.001\times 2^3$，那么 $s=1$， $M=1.001$， $E=3$。</p>
<p>IEEE 754规定，对于32位的浮点数，最高的1位是符号位 $s$，接着的8位是指数 $E$，剩下的23位为有效数字 $M$。</p>
<img src="/2017/05/17/计算机中浮点数的二进制表示/bin-32.png" alt="bin-32.png" title="">
<p>对于64位的浮点数，最高的1位是符号位 $s$，接着的11位是指数 $E$，剩下的52位为有效数字 $M$。</p>
<img src="/2017/05/17/计算机中浮点数的二进制表示/bin-64.png" alt="bin-64.png" title="">
<p>对于上述位的表示，根据阶码 $exp$ 的表示，可以分为三种情况：</p>
<h3 id="规格化的值"><a href="#规格化的值" class="headerlink" title="规格化的值"></a>规格化的值</h3><p>这是一般的情况，当 $exp$ 的二进制表示中既不全为0，也不全为1（单精度格式8位，数值为255；双精度格式11位，数值为2047）时，都是这种情况。这种情况下，阶码字段被解释为以<em>偏置（biased）</em>形式表示的有符号整数。也就是说，阶码的值是 $E=e-Bias$，其中 $e$ 是无符号数，其位表示为 $e_{k-1}\cdots e_1e_0$，而Bias是一个等于 $2^{k-1}-1$（单精度是127，双精度是1023）的偏置值。所以由此产生的指数的取值范围，对于单精度来说是 $-126 \thicksim +127$，对于双精度来说是 $-1022 \thicksim +1023$。</p>
<p>小数字段 $frac$ 被解释为描述小数值 $f$， 其中 $0\leqslant f &lt; 1$，其二进制表示为 $0.f_{n-1}\cdots f_1f_0$，也就是二进制小数点在最高有效位的左边。尾数定义为 $M=1+f$。我们可以把 $M$ 看成是一个 $1.f_{n-1}f_{n-2}\cdots f_0$ 的数字。因为总是能够通过调整阶码 $E$ 使得尾数 $M$ 的值在范围 $1\leqslant M &lt; 2$ 中，所以这一位可以省去，只保留后面的小数位，这样又能够获得一个精度位。</p>
<h3 id="非规格化的值"><a href="#非规格化的值" class="headerlink" title="非规格化的值"></a>非规格化的值</h3><p>当阶码位全为0时，表示的数就是<em>非规格化</em>的形式。这种情况下，阶码的值是 $E=1-Bias$，而尾数的值是 $M=f$，也就是小数字段的值不包括开头的1。</p>
<p>非规格化数有两个用途。</p>
<ol>
<li>它们提供了一种表示数值0的方法，因为使用规格化数时，必须总是使 $M\geqslant 1$，这样就不能表示0。实际上，$+0.0$ 的浮点表示的位模式为全0：符号位是0，阶码字段全为0（表示是一个非规格化的值），而小数域也全为0，这就得到 $M=f=0$。但当符号位为1，其他域全为0时，会得到 $-0.0$。根据IEEE的浮点格式，值 $+0.0$ 和 $-0.0$在某些方面被认为是不同的，而在其他方面是相同的。</li>
<li>另外一个功能是表示哪些非常接近于 $0.0$ 的数。它们提供了一种属性，称为<em>逐渐溢出（gradual underflow）</em>，其中，可能的数值分布均匀地接近于 $0.0$。</li>
</ol>
<h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><p>这种情况是当阶码全为1时出现的。当小数域全为0时，得到的值表示无穷，当  $s=0$ 时是 $+\infty$，或者当$s=1$ 时是 $-\infty$。当把两个非常大的数相乘，或者除以0时，无穷可以表示溢出的结果。当小数域为非零时，结果值被称为 “NAN”。</p>
<p>下面想一下，为什么阶码的值要表示为 $E=e-Bias$？</p>
<p>下面内容参考自：<a href="https://www.zhihu.com/question/24115452" target="_blank" rel="external">https://www.zhihu.com/question/24115452</a></p>
<p>想一想，我们对两个用科学记数法表示的数进行加减法的时候，我们怎么做最简单？通过比较exponent的大小，然后通过移动小数点，让它们一致，之后，把数值部分相加，即可。</p>
<p>同样的，在计算机硬件的实现上，也是这样处理浮点数的加减法的~也就是通常所说的：求阶差、对阶，尾数相加，结果规格化。那么，这就产生了一个问题：如何比较两个阶的大小，以右移小阶所对应的fraction呢？</p>
<p>在原码的情况下，这样的比较是不方便的！因为按照规定，对于负数，符号位是1；正数，符号位是0。</p>
<p>那么一个正数01xxx和另一个正数00xxx比较，显然，01xxx大。</p>
<p>但是，一个正数0xxx和一个负数1xxx比较，还是按照上面的比较的话，我们认为是1xxx那个大。</p>
<p>所以，为了一个比较设计不同的电路确实不划算，所以让负数都变成正数，这样一来，比较就变得容易了。</p>
<h2 id="Double类的一些重要常量"><a href="#Double类的一些重要常量" class="headerlink" title="Double类的一些重要常量"></a>Double类的一些重要常量</h2><p>下面看一下java中的Double类中定义的一些重要的常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Double</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 一个持有double的负无穷大的常数。</div><div class="line">     * 它等于Double.longBitsToDouble(0x7ff0000000000000L)的返回值。</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> POSITIVE_INFINITY = <span class="number">1.0</span> / <span class="number">0.0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 一个持有double的负无穷大的常数。</div><div class="line">     * 它等于Double.longBitsToDouble（0xfff0000000000000L）返回的值。</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NEGATIVE_INFINITY = -<span class="number">1.0</span> / <span class="number">0.0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 一个持有double的负无穷大的常数。</div><div class="line">     * 它等于Double.longBitsToDouble(0x7ff8000000000000L)的返回值</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NaN = <span class="number">0.0</span>d / <span class="number">0.0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最大值，也就是除了符号位，其余全为1。</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MAX_VALUE = <span class="number">0x1</span>.fffffffffffffP+<span class="number">1023</span>; <span class="comment">// 1.7976931348623157e+308</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最小的正数值，相当于Double.longBitsToDouble(0x0010000000000000L)的返回值</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MIN_NORMAL = <span class="number">0x1</span>.0p-<span class="number">1022</span>; <span class="comment">// 2.2250738585072014E-308</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最小值</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MIN_VALUE = <span class="number">0x0</span>.0000000000001P-<span class="number">1022</span>; <span class="comment">// 4.9e-324</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最大指数</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_EXPONENT = <span class="number">1023</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最小指数</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_EXPONENT = -<span class="number">1022</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的分析，理解这里定义的这些常量也就很容易了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java8使用@sun.misc.Contended避免伪共享]]></title>
      <url>http://www.ideabuffer.cn/2017/05/12/Java8%E4%BD%BF%E7%94%A8-sun-misc-Contended%E9%81%BF%E5%85%8D%E4%BC%AA%E5%85%B1%E4%BA%AB/</url>
      <content type="html"><![CDATA[<h2 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h2><p>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>
<p>缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。</p>
<p>为了让可伸缩性与线程数呈线性关系，就必须确保不会有两个线程往同一个变量或缓存行中写。两个线程写同一个变量可以在代码中发现。为了确定互相独立的变量是否共享了同一个缓存行，就需要了解缓存行和对象的内存布局，有关缓存行和对象内存布局可以参考我的另外两篇文章<a href="http://www.jianshu.com/p/900554f11881" target="_blank" rel="external">理解CPU Cache</a>和<a href="http://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="external">Java对象内存布局</a>。</p>
<a id="more"></a>
<p>下面的图说明了伪共享的问题：</p>
<img src="/2017/05/12/Java8使用-sun-misc-Contended避免伪共享/false-sharing.png" alt="false-sharing.png" title="">
<p>假设在核心1上运行的线程想更新变量X，同时核心2上的线程想要更新变量Y。不幸的是，这两个变量在同一个缓存行中。每个线程都要去竞争缓存行的所有权来更新变量。如果核心1获得了所有权，缓存子系统将会使核心2中对应的缓存行失效。当核心2获得了所有权然后执行更新操作，核心1就要使自己对应的缓存行失效。这会来来回回的经过L3缓存，大大影响了性能。如果互相竞争的核心位于不同的插槽，就要额外横跨插槽连接，问题可能更加严重。</p>
<h2 id="避免伪共享"><a href="#避免伪共享" class="headerlink" title="避免伪共享"></a>避免伪共享</h2><p>假设有一个类中，只有一个long类型的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时定义一个VolatileLong类型的数组，然后让多个线程同时并发访问这个数组，这时可以想到，在多个线程同时处理数据时，数组中的多个VolatileLong对象可能存在同一个缓存行中，通过上文可知，这种情况就是伪共享。</p>
<p>怎么样避免呢？在Java 7之前，可以在属性的前后进行padding，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> p0, p1, p2, p3, p4, p5, p6;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0</span>;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> q0, q1, q2, q3, q4, q5, q6;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<a href="http://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="external">Java对象内存布局</a>文章中结尾对paddign的分析可知，由于都是long类型的变量，这里就是按照声明的顺序分配内存，那么这可以保证在同一个缓存行中只有一个VolatileLong对象。</p>
<p><strong> 这里有一个问题：据说Java7优化了无用字段，会使这种形式的补位无效，但经过测试，无论是在JDK 1.7 还是 JDK 1.8中，这种形式都是有效的。网上有关伪共享的文章基本都是来自Martin的两篇博客，这种优化方式也是在他的博客中提到的。但国内的文章貌似根本就没有验证过而直接引用了此观点，这也确实迷惑了一大批同学！</strong></p>
<p>在Java 8中，提供了@sun.misc.Contended注解来避免伪共享，原理是在使用此注解的对象或字段的前后各增加128字节大小的padding，使用2倍于大多数硬件缓存行的大小来避免相邻扇区预取导致的伪共享冲突。具体可以参考<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html" target="_blank" rel="external">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html</a>。</p>
<p>下面用代码来看一下加padding和不加的效果：</p>
<blockquote>
<p>运行环境：JDK 1.8，macOS 10.12.4，2.2 GHz Intel Core i7，四核-八线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_THREADS = <span class="number">4</span>; <span class="comment">// change</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> arrayIndex;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> VolatileLong[] longs = <span class="keyword">new</span> VolatileLong[NUM_THREADS];</div><div class="line"><span class="comment">//    private static VolatileLong2[] longs = new VolatileLong2[NUM_THREADS];</span></div><div class="line"><span class="comment">//    private static VolatileLong3[] longs = new VolatileLong3[NUM_THREADS];</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;</div><div class="line">            longs[i] = <span class="keyword">new</span> VolatileLong();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        runTest();</div><div class="line">        System.out.println(<span class="string">"duration = "</span> + (System.nanoTime() - start));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</div><div class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</div><div class="line">            t.join();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</div><div class="line">            longs[arrayIndex].value = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// long padding避免false sharing</span></div><div class="line">    <span class="comment">// 按理说jdk7以后long padding应该被优化掉了，但是从测试结果看padding仍然起作用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong2</span> </span>&#123;</div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> p0, p1, p2, p3, p4, p5, p6;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> q0, q1, q2, q3, q4, q5, q6;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * jdk8新特性，Contended注解避免false sharing</div><div class="line">     * Restricted on user classpath</div><div class="line">     * Unlock: -XX:-RestrictContended</div><div class="line">     */</div><div class="line">    <span class="meta">@sun</span>.misc.Contended</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong3</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>VolatileLong对象只有一个long类型的字段，VolatileLong2加了padding，下面分别执行看下时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">duration = 57293259577</div><div class="line">duration = 4679059000</div></pre></td></tr></table></figure>
<p>没加padding时用了大概57秒，加padding后用时大概4.6秒，可见加padding后有效果了。</p>
<p>在Java8中提供了@sun.misc.Contended来避免伪共享，例如这里的VolatileLong3，在运行时需要设置JVM启动参数<code>-XX:-RestrictContended</code>，运行一下结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">duration = 4756952426</div></pre></td></tr></table></figure>
<p>结果与加padding的时间差不多。</p>
<p>下面看一下VolatileLong对象在运行时的内存大小（参考<a href="http://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="external">Java对象内存布局</a>）：</p>
<img src="/2017/05/12/Java8使用-sun-misc-Contended避免伪共享/VolatileLong.png" alt="VolatileLong.png" title="">
<p>再来看下VolatileLong2对象在运行时的内存大小：</p>
<img src="/2017/05/12/Java8使用-sun-misc-Contended避免伪共享/VolatileLong2.png" alt="VolatileLong2.png" title="">
<p>因为多了14个long类型的变量，所以24+8*14=136字节。</p>
<p>下面再来看下使用@sun.misc.Contended注解后的对象内存大小：</p>
<img src="/2017/05/12/Java8使用-sun-misc-Contended避免伪共享/VolatileLong3.png" alt="VolatileLong3.png" title="">
<p>在堆内存中并没有看到对变量进行padding，大小与VolatileLong对象是一样的。</p>
<p>这就奇怪了，看起来与VolatileLong没什么不一样，但看一下内存的地址，用十六进制算一下，两个VolatileLong对象地址相差24字节，而两个VolatileLong3对象地址相差280字节。这就是前面提到的@sun.misc.Contended注解会在对象或字段的前后各增加128字节大小的padding，那么padding的大小就是256字节，再加上对象的大小24字节，结果就是280字节，所以确实是增加padding了。</p>
<h2 id="八线程运行比四线程运行还快？"><a href="#八线程运行比四线程运行还快？" class="headerlink" title="八线程运行比四线程运行还快？"></a>八线程运行比四线程运行还快？</h2><p>根据上面的代码，把NUM_THREADS改为8，测试看下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VolatileLong:  44305002641</div><div class="line">VolatileLong2: 7100172492</div><div class="line">VolatileLong3: 7335024041</div></pre></td></tr></table></figure>
<p>可以看到，加了padding和@sun.misc.Contended注解的运行时间多了不到1倍，而VolatileLong运行的时间比线程数是4的时候还要短，这是为什么呢？</p>
<p>再说一下，我的CPU是四核八线程，每个核有一个L1 Cache，那么我的环境一共有4个L1 Cache，所以，2个CPU线程会共享同一个L1 Cache；由于VolatileLong对象占用24字节内存，而代码中VolatileLong对象是保存在数组中的，所以内存是连续的，2个VolatileLong对象的大小是48字节，这样一来，对于缓存行大小是64字节来说，每个缓存行只能存放2个VolatileLong对象。</p>
<p>通过上面的分析可知，伪共享发生在L3 Cache，如果每个核操作的数据不在同一个缓存行中，那么就会避免伪共享的发生，所以，8个线程的情况下其实是CPU线程共享了L1 Cache，所以执行的时间可能比4线程的情况还要短。下面看下执行时4线程和8线程的CPU使用情况：</p>
<img src="/2017/05/12/Java8使用-sun-misc-Contended避免伪共享/CPU.png" alt="CPU.png" title="">
<p>可以看到，在4线程时，线程被平均分配到了4个核中，这样一来，L1 Cache肯定是不能共享的，这时会发生伪共享；而8线程时，每个核都使用了2个线程，这时L1 Cache是可以共享的，这在一定程度上能减少伪共享的发生，从而时间会变短（也不一定，但总体来说8线程的情况与4线程的运行时间几乎不会向加padding和注解的方式差那么多）。</p>
<p>在Windows上情况就不太一样了，在双核四线程的CPU上，测试结果并不和mac中一样，在不加padding和注解时，2线程和4线程执行的时间都是将近差了1倍，看下使用2个线程在Windows中执行的时候CPU的使用情况：</p>
<img src="/2017/05/12/Java8使用-sun-misc-Contended避免伪共享/windows.png" alt="windows.png" title="">
<p>虽然只使用了2个线程，但从图像上来看，似乎都在工作，即使把线程数量设置为1也是这种情况。这应该是Windows和UNIX对CPU线程调度的方式不一样，具体我现在也不太清楚他们之间的差别，希望有知道的同学告知，感谢。</p>
<h2 id="sun-misc-Contended注解"><a href="#sun-misc-Contended注解" class="headerlink" title="@sun.misc.Contended注解"></a>@sun.misc.Contended注解</h2><p>上文中将@sun.misc.Contended注解用在了对象上，@sun.misc.Contended注解还可以指定某个字段，并且可以为字段进行分组，下面通过代码来看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Options: </div><div class="line"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</div><div class="line"> * -XX:-RestrictContended</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContendedTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">byte</span> a;</div><div class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"a"</span>)</div><div class="line">    <span class="keyword">long</span> b;</div><div class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"a"</span>)</div><div class="line">    <span class="keyword">long</span> c;</div><div class="line">    <span class="keyword">int</span> d;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Field f = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</div><div class="line">            f.setAccessible(<span class="keyword">true</span>);</div><div class="line">            UNSAFE = (Unsafe) f.get(<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"offset-a: "</span> + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField(<span class="string">"a"</span>)));</div><div class="line">        System.out.println(<span class="string">"offset-b: "</span> + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField(<span class="string">"b"</span>)));</div><div class="line">        System.out.println(<span class="string">"offset-c: "</span> + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField(<span class="string">"c"</span>)));</div><div class="line">        System.out.println(<span class="string">"offset-d: "</span> + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField(<span class="string">"d"</span>)));</div><div class="line"></div><div class="line">        ContendedTest contendedTest = <span class="keyword">new</span> ContendedTest();</div><div class="line"></div><div class="line">        <span class="comment">// 打印对象的shallow size</span></div><div class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</div><div class="line">        <span class="comment">// 打印对象的 retained size</span></div><div class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里还是使用到了classmexer.jar，可以参考<a href="http://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="external">Java对象内存布局</a>中的说明。</p>
<p>这里在变量b和c中使用了@sun.misc.Contended注解，并将这两个变量分为1组，执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">offset-a: 16</div><div class="line">offset-b: 152</div><div class="line">offset-c: 160</div><div class="line">offset-d: 12</div><div class="line">Shallow Size: 296 bytes</div><div class="line">Retained Size: 296 bytes</div></pre></td></tr></table></figure>
<p>可见int类型的变量的偏移地址是12，也就是在对象头后面，因为它正好是4个字节，然后是变量a。@sun.misc.Contended注解的变量会加到对象的最后面，这里就是b和c了，那么b的偏移地址是152，之前说过@sun.misc.Contended注解会在变量前后各加128字节，而byte类型的变量a分配完内存后这时起始地址应该是从17开始，因为byte类型占1字节，那么应该补齐到24，所以b的起始地址是24+128=152，而c的前面并不用加128字节，因为b和c被分为了同一组。</p>
<p>我们算一下c分配完内存后，这时的地址应该到了168，然后再加128字节，最后大小就是296。内存结构如下：</p>
<p>| d:12~16 | — | a:16~17 | — | 17~24 | — | 24~152 | — | b:152~160 | — | c:160~168 | — | 168~296 |</p>
<p>现在把b和c分配到不同的组中，代码做如下修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Options:</div><div class="line"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</div><div class="line"> * -XX:-RestrictContended</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContendedTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">byte</span> a;</div><div class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"a"</span>)</div><div class="line">    <span class="keyword">long</span> b;</div><div class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"b"</span>)</div><div class="line">    <span class="keyword">long</span> c;</div><div class="line">    <span class="keyword">int</span> d;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Field f = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</div><div class="line">            f.setAccessible(<span class="keyword">true</span>);</div><div class="line">            UNSAFE = (Unsafe) f.get(<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"offset-a: "</span> + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField(<span class="string">"a"</span>)));</div><div class="line">        System.out.println(<span class="string">"offset-b: "</span> + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField(<span class="string">"b"</span>)));</div><div class="line">        System.out.println(<span class="string">"offset-c: "</span> + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField(<span class="string">"c"</span>)));</div><div class="line">        System.out.println(<span class="string">"offset-d: "</span> + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField(<span class="string">"d"</span>)));</div><div class="line"></div><div class="line">        ContendedTest contendedTest = <span class="keyword">new</span> ContendedTest();</div><div class="line"></div><div class="line">        <span class="comment">// 打印对象的shallow size</span></div><div class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</div><div class="line">        <span class="comment">// 打印对象的 retained size</span></div><div class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">offset-a: <span class="number">16</span></div><div class="line">offset-b: <span class="number">152</span></div><div class="line">offset-c: <span class="number">288</span></div><div class="line">offset-d: <span class="number">12</span></div><div class="line">Shallow Size: <span class="number">424</span> bytes</div><div class="line">Retained Size: <span class="number">424</span> bytes</div></pre></td></tr></table></figure>
<p>可以看到，这时b和c中增加了128字节的padding，结构也就变成了：</p>
<p>| d:12~16 | — | a:16~17 | — | 17~24 | — | 24~152 | — | b:152~160 | — | 160~288 | — | c:288~296 | — | 296~424 |</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解CPU Cache]]></title>
      <url>http://www.ideabuffer.cn/2017/05/07/%E7%90%86%E8%A7%A3CPU-Cache/</url>
      <content type="html"><![CDATA[<h2 id="CPU-Cache介绍"><a href="#CPU-Cache介绍" class="headerlink" title="CPU Cache介绍"></a>CPU Cache介绍</h2><p>随着CPU频率的不断提升，内存的访问速度却并没有什么突破。所以，为了弥补内存访问速度慢的硬伤，便出现了CPU缓存。它的工作原理如下：</p>
<ul>
<li>当CPU要读取一个数据时，首先从缓存中查找，如果找到就立即读取并送给CPU处理；</li>
<li>如果没有找到，就用相对慢的速度从内存中读取并送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对整块数据的读取都从缓存中进行，不必再调用内存。</li>
</ul>
<p>为了充分发挥CPU的计算性能和吞吐量，现代CPU引入了一级缓存、二级缓存和三级缓存，结构如下图所示：</p>
<img src="/2017/05/07/理解CPU-Cache/CPU-Cache.jpg" alt="CPU-Cache.jpg" title="">
<a id="more"></a>
<p>图中所示的是三级缓存的架构，可以看到，级别越小的缓存，越接近CPU，但访问速度也会越慢。</p>
<ul>
<li>L1 Cache分为D-Cache和I-Cache，D-Cache用来存储数据，I-Cache用来存放指令，一般L1 Cache的大小是32k；</li>
<li>L2 Cache 更大一些,例如256K, 速度要慢一些, 一般情况下每个核上都有一个独立的L2 Cache；</li>
<li>L3 Cache是三级缓存中最大的一级，例如12MB，同时也是最慢的一级，在同一个CPU插槽之间的核共享一个L3 Cache。</li>
</ul>
<p>当CPU计算时，首先去L1去寻找需要的数据，如果没有则去L2寻找，接着从L3中寻找，如果都没有，则从内存中读取数据。所以，如果某些数据需要经常被访问，那么这些数据存放在L1中的效率会最高。</p>
<p>下面的列表表示了CPU到各缓存和内存之间的大概速度：</p>
<table>
<thead>
<tr>
<th>从CPU到</th>
<th>大约需要的CPU周期</th>
<th>大约需要的时间(单位ns)</th>
</tr>
</thead>
<tbody>
<tr>
<td>寄存器</td>
<td>1 cycle</td>
<td></td>
</tr>
<tr>
<td>L1 Cache</td>
<td>~3-4 cycles</td>
<td>~0.5-1 ns</td>
</tr>
<tr>
<td>L2 Cache</td>
<td>~10-20 cycles</td>
<td>~3-7 ns</td>
</tr>
<tr>
<td>L3 Cache</td>
<td>~40-45 cycles</td>
<td>~15 ns</td>
</tr>
<tr>
<td>跨槽传输</td>
<td>~20 ns</td>
<td></td>
</tr>
<tr>
<td>内存</td>
<td>~120-240 cycles</td>
<td>~60-120ns</td>
</tr>
</tbody>
</table>
<p>在Linux中可以通过如下命令查看CPU Cache：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/size</div><div class="line">32K</div><div class="line">cat /sys/devices/system/cpu/cpu0/cache/index1/size</div><div class="line">32K</div><div class="line">cat /sys/devices/system/cpu/cpu0/cache/index2/size</div><div class="line">256K</div><div class="line">cat /sys/devices/system/cpu/cpu0/cache/index3/size</div><div class="line">20480K</div><div class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/<span class="built_in">type</span></div><div class="line">Data</div><div class="line">cat /sys/devices/system/cpu/cpu0/cache/index1/<span class="built_in">type</span></div><div class="line">Instruction</div></pre></td></tr></table></figure>
<p>这里的index0和index1对应着L1 D-Cache和L1 I-Cache。</p>
<h2 id="缓存行Cache-Line"><a href="#缓存行Cache-Line" class="headerlink" title="缓存行Cache Line"></a>缓存行Cache Line</h2><p>缓存是由缓存行组成的。一般一行缓存行有64字节。CPU在操作缓存时是以缓存行为单位的，可以通过如下命令查看缓存行的大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size</div><div class="line">64</div></pre></td></tr></table></figure>
<p>由于CPU存取缓存都是按行为最小单位操作的。对于long类型来说，一个long类型的数据有64位，也就是8个字节，所以对于数组来说，由于数组中元素的地址是连续的，所以在加载数组中第一个元素的时候会把后面的元素也加载到缓存行中。</p>
<p>如果一个long类型的数组长度是8，那么也就是64个字节了，CPU这时操作该数组，会把数组中所有的元素都放入缓存行吗？答案是否定的，原因就是在Java中，对象在内存中的结构包含对象头，可以参考我的另一篇文章<a href="http://www.ideabuffer.cn/2017/05/06/Java对象内存布局/">Java对象内存布局</a>来了解。</p>
<h2 id="测试Cache-Miss"><a href="#测试Cache-Miss" class="headerlink" title="测试Cache Miss"></a>测试Cache Miss</h2><p>下面的代码引用自<a href="http://coderplay.iteye.com/blog/1485760" target="_blank" rel="external">http://coderplay.iteye.com/blog/1485760</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">L1CacheMiss</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNS = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DIMENSION_1 = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DIMENSION_2 = <span class="number">62</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] longs;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        longs = <span class="keyword">new</span> <span class="keyword">long</span>[DIMENSION_1][];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIMENSION_1; i++) &#123;</div><div class="line">            longs[i] = <span class="keyword">new</span> <span class="keyword">long</span>[DIMENSION_2];</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"starting...."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</div><div class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; RUNS; r++) &#123;</div><div class="line">            <span class="comment">// 1. slow</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIMENSION_2; j++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIMENSION_1; i++) &#123;</div><div class="line">                    sum += longs[i][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 2. fast</span></div><div class="line"><span class="comment">//            for (int i = 0; i &lt; DIMENSION_1; i++) &#123;</span></div><div class="line"><span class="comment">//                for (int j = 0; j &lt; DIMENSION_2; j++) &#123;</span></div><div class="line"><span class="comment">//                    sum += longs[i][j];</span></div><div class="line"><span class="comment">//                &#125;</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"duration = "</span> + (System.nanoTime() - start));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里测试的环境是macOS 10.12.4，JDK 1.8，Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)。</p>
<p>这里定义了一个二维数组，第一维长度是1024*1024，第二维长度是62，这里遍历二维数组。由于二维数组中每一个数组对象的长度是62，那么根据上篇文章<a href="http://www.ideabuffer.cn/2017/05/06/Java对象内存布局/">Java对象内存布局</a>的介绍，可以知道，long类型的数组对象头的大小是16字节（这里默认开启了指针压缩），每个long类型的数据大小是8字节，那么一个long类型的数组大小为16+8*62=512字节。先看一下第一种慢的方式运行的时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">starting....</div><div class="line">duration = 11883939677</div></pre></td></tr></table></figure>
<p>运行时间是11秒多，再来看下快的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">starting....</div><div class="line">duration = 888085368</div></pre></td></tr></table></figure>
<p>运行时间是888毫秒，还不到1秒，为什么相差这么多？</p>
<p>首先来分析一下第一种情况，因为二维数组中的每一个数组对象占用的内存大小是512字节，而缓存行的大小是64字节，那么使用第一种遍历方式，假设当前遍历的数据是longs[i][j]，那么下一个遍历的数据是longs[i+1][j]，也就是说遍历的不是同一个数组对象，那么这两次遍历的数据肯定不在同一个缓存行内，也就是产生了Cache Miss；</p>
<p>在第二种情况中，假设当前遍历的数据是longs[i][j]，那么下一个遍历的数据是longs[i][j+1]，遍历的是同一个数组对象，所以当前的数据和下一个要遍历的数据可能都是在同一个缓存行中，这样发生Cache Miss的情况就大大减少了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，Cache Miss有三种情况：</p>
<ol>
<li>第一次访问数据时cache中不存在这条数据；</li>
<li>cache冲突；</li>
<li>cache已满。</li>
</ol>
<p>这里的第二种情况也比较常见，同时会产生一个问题，就是伪共享，有时间会单独写一篇文章来介绍一下Java中对伪共享的处理方式。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java对象内存布局]]></title>
      <url>http://www.ideabuffer.cn/2017/05/06/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p>我们知道在Java中基本数据类型的大小，例如int类型占4个字节、long类型占8个字节，那么Integer对象和Long对象会占用多少内存呢？本文介绍一下Java对象在堆中的内存结构以及对象大小的计算。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>一个Java对象在内存中包括对象头、实例数据和补齐填充3个部分：</p>
<img src="/2017/05/06/Java对象内存布局/ObjectMemoryLayout.png" alt="ObjectMemoryLayout.png" title="">
<a id="more"></a>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ul>
<li><strong>Mark Word</strong>：包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。在32位系统占4字节，在64位系统中占8字节；</li>
<li><strong>Class Pointer</strong>：用来指向对象对应的Class对象（其对应的元数据对象）的内存地址。在32位系统占4字节，在64位系统中占8字节；</li>
<li><strong>Length</strong>：如果是数组对象，还有一个保存数组长度的空间，占4个字节；</li>
</ul>
<h3 id="对象实际数据"><a href="#对象实际数据" class="headerlink" title="对象实际数据"></a>对象实际数据</h3><p>对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节（64位系统中是8个字节）。</p>
<table>
<thead>
<tr>
<th>Primitive Type</th>
<th>Memory Required(bytes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>1</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>对于reference类型来说，在32位系统上占用4bytes, 在64位系统上占用8bytes。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数。例如，一个包含两个属性的对象：int和byte，这个对象需要占用8+4+1=13个字节，这时就需要加上大小为3字节的padding进行8字节对齐，最终占用大小为16个字节。</p>
<p>注意：以上对64位操作系统的描述是未开启指针压缩的情况，关于指针压缩会在下文中介绍。</p>
<h3 id="对象头占用空间大小"><a href="#对象头占用空间大小" class="headerlink" title="对象头占用空间大小"></a>对象头占用空间大小</h3><p>这里说明一下32位系统和64位系统中对象所占用内存空间的大小：</p>
<ul>
<li>在32位系统下，存放Class Pointer的空间大小是4字节，MarkWord是4字节，对象头为8字节;</li>
<li>在64位系统下，存放Class Pointer的空间大小是8字节，MarkWord是8字节，对象头为16字节;</li>
<li>64位开启指针压缩的情况下，存放Class Pointer的空间大小是4字节，<code>MarkWord</code>是8字节，对象头为12字节;</li>
<li>如果是数组对象，对象头的大小为：数组对象头8字节+数组长度4字节+对齐4字节=16字节。其中对象引用占4字节（未开启指针压缩的64位为8字节），数组<code>MarkWord</code>为4字节（64位未开启指针压缩的为8字节）;</li>
<li>静态属性不算在对象大小内。</li>
</ul>
<h2 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h2><p>从上文的分析中可以看到，64位JVM消耗的内存会比32位的要多大约1.5倍，这是因为对象指针在64位JVM下有更宽的寻址。对于那些将要从32位平台移植到64位的应用来说，平白无辜多了1/2的内存占用，这是开发者不愿意看到的。</p>
<p>从JDK 1.6 update14开始，64位的JVM正式支持了 -XX:+UseCompressedOops 这个可以压缩指针，起到节约内存占用的新参数。</p>
<h3 id="什么是OOP？"><a href="#什么是OOP？" class="headerlink" title="什么是OOP？"></a>什么是OOP？</h3><p>OOP的全称为：Ordinary Object Pointer，就是普通对象指针。启用CompressOops后，会压缩的对象：</p>
<ul>
<li>每个Class的属性指针（静态成员变量）；</li>
<li>每个对象的属性指针；</li>
<li>普通对象数组的每个元素指针。</li>
</ul>
<p>当然，压缩也不是所有的指针都会压缩，对一些特殊类型的指针，JVM是不会优化的，例如指向PermGen的Class对象指针、本地变量、堆栈元素、入参、返回值和NULL指针不会被压缩。</p>
<h3 id="启用指针压缩"><a href="#启用指针压缩" class="headerlink" title="启用指针压缩"></a>启用指针压缩</h3><p>在Java程序启动时增加JVM参数：<code>-XX:+UseCompressedOops</code>来启用。</p>
<p><em>注意：32位HotSpot VM是不支持UseCompressedOops参数的，只有64位HotSpot VM才支持。</em></p>
<p>本文中使用的是JDK 1.8，默认该参数就是开启的。</p>
<h2 id="查看对象的大小"><a href="#查看对象的大小" class="headerlink" title="查看对象的大小"></a>查看对象的大小</h2><p>接下来我们使用<a href="http://www.javamex.com/" target="_blank" rel="external">http://www.javamex.com/</a>中提供的<a href="http://www.javamex.com/classmexer/classmexer-0_03.zip" target="_blank" rel="external">classmexer.jar</a>来计算对象的大小。</p>
<p>运行环境：JDK 1.8，Java HotSpot(TM) 64-Bit Server VM</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>对于基本数据类型来说，是比较简单的，因为我们已经知道每个基本数据类型的大小。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM options:</div><div class="line"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</div><div class="line"> * -XX:+UseCompressedOops</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectSize</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">long</span> b;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        TestObjectSize testObjectSize = <span class="keyword">new</span> TestObjectSize();</div><div class="line">        <span class="comment">// 打印对象的shallow size</span></div><div class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</div><div class="line">        <span class="comment">// 打印对象的 retained size</span></div><div class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</div><div class="line">        System.in.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>注意：在运行前需要设置javaagent参数，在JVM启动参数中添加<code>-javaagent:/path_to_agent/classmexer.jar</code>来运行。</em></p>
<p>有关Shallow Size和Retained Size请参考<a href="http://blog.csdn.net/e5945/article/details/7708253" target="_blank" rel="external">http://blog.csdn.net/e5945/article/details/7708253</a>。</p>
<h4 id="开启指针压缩的情况"><a href="#开启指针压缩的情况" class="headerlink" title="开启指针压缩的情况"></a>开启指针压缩的情况</h4><p>运行查看结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shallow Size: 24 bytes</div><div class="line">Retained Size: 24 bytes</div></pre></td></tr></table></figure>
<p>根据上文的分析可以知道，64位开启指针压缩的情况下：</p>
<ul>
<li>对象头大小=Class Pointer的空间大小为4字节+<code>MarkWord</code>为8字节=12字节；</li>
<li>实际数据大小=int类型4字节+long类型8字节=12字节（静态变量不在计算范围之内）</li>
</ul>
<p>在MAT中分析的结果如下：</p>
<img src="/2017/05/06/Java对象内存布局/dump1.png" alt="dump1.png" title="">
<p>所以大小是24字节。其实这里并没有padding，因为正好是24字节。如果我们把<code>long b;</code>换成<code>int b;</code>之后，再来看一下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shallow Size: 24 bytes</div><div class="line">Retained Size: 24 bytes</div></pre></td></tr></table></figure>
<p>大小并没有变化，说明这里做了padding，并且padding的大小是4字节。</p>
<p>这里的Shallow Size和Retained Size是一样的，因为都是基本数据类型。</p>
<h4 id="关闭指针压缩的情况"><a href="#关闭指针压缩的情况" class="headerlink" title="关闭指针压缩的情况"></a>关闭指针压缩的情况</h4><p>如果要关闭指针压缩，在JVM参数中添加<code>-XX:-UseCompressedOops</code>来关闭，再运行上述代码查看结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shallow Size: 24 bytes</div><div class="line">Retained Size: 24 bytes</div></pre></td></tr></table></figure>
<p>分析一下在64位未开启指针压缩的情况下：</p>
<ul>
<li>对象头大小=Class Pointer的空间大小为8字节+<code>MarkWord</code>为8字节=16字节；</li>
<li>实际数据大小=int类型4字节+long类型8字节=12字节（静态变量不在计算范围之内）；</li>
</ul>
<p>这里计算后大小为16+12=28字节，这时候就需要padding来补齐了，所以padding为4字节，最后的大小就是32字节。</p>
<p>我们再把<code>long b;</code>换成<code>int b;</code>之后呢？通过上面的计算结果可以知道，实际数据大小就应该是int类型4字节+int类型4字节=8字节，对象头大小为16字节，那么不需要做padding，对象的大小为24字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shallow Size: 24 bytes</div><div class="line">Retained Size: 24 bytes</div></pre></td></tr></table></figure>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>64位系统中，数组对象的对象头占用24 bytes，启用压缩后占用16字节。比普通对象占用内存多是因为需要额外的空间存储数组的长度。基础数据类型数组占用的空间包括数组对象头以及基础数据类型数据占用的内存空间。由于对象数组中存放的是对象的引用，所以数组对象的Shallow Size=数组对象头+length <em> 引用指针大小，Retained Size=Shallow Size+length</em>每个元素的Retained Size。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM options:</div><div class="line"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</div><div class="line"> * -XX:+UseCompressedOops</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectSize</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">6</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        TestObjectSize testObjectSize = <span class="keyword">new</span> TestObjectSize();</div><div class="line">        <span class="comment">// 打印对象的shallow size</span></div><div class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</div><div class="line">        <span class="comment">// 打印对象的 retained size</span></div><div class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</div><div class="line">        System.in.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="开启指针压缩的情况-1"><a href="#开启指针压缩的情况-1" class="headerlink" title="开启指针压缩的情况"></a>开启指针压缩的情况</h4><p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shallow Size: 16 bytes</div><div class="line">Retained Size: 80 bytes</div></pre></td></tr></table></figure>
<p>Shallow Size比较简单，这里对象头大小为12字节， 实际数据大小为4字节，所以Shallow Size为16。</p>
<p>对于Retained Size来说，要计算数组占用的大小，对于数组来说，它的对象头部多了一个用来存储数组长度的空间，该空间大小为4字节，所以<strong>数组对象的大小=引用对象头大小12字节+存储数组长度的空间大小4字节+数组的长度*数组中对象的Retained Size+padding大小</strong></p>
<p>下面分析一下上述代码中的<code>long[] arr = new long[6];</code>，它是一个长度为6的long类型的数组，由于long类型的大小为8字节，所以数组中的实际数据是6<em>8=48字节，那么数组对象的大小=12+4+6</em>8+0=64，最终的Retained Size=Shallow Size + 数组对象大小=16+64=80。</p>
<p>通过MAT查看如下：</p>
<img src="/2017/05/06/Java对象内存布局/dump2.png" alt="dump2.png" title="">
<h4 id="关闭指针压缩的情况-1"><a href="#关闭指针压缩的情况-1" class="headerlink" title="关闭指针压缩的情况"></a>关闭指针压缩的情况</h4><p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shallow Size: 24 bytes</div><div class="line">Retained Size: 96 bytes</div></pre></td></tr></table></figure>
<p>这个结果大家应该能自己分析出来了，因为这时引用对象头为16字节，那么数组的大小=16+4+6*8+4=72，（这里最后一个4是padding），所以Retained Size=Shallow Size + 数组对象大小=24+72=96。</p>
<p>通过MAT查看如下：</p>
<img src="/2017/05/06/Java对象内存布局/dump3.png" alt="dump3.png" title="">
<h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>包装类（Boolean/Byte/Short/Character/Integer/Long/Double/Float）占用内存的大小等于对象头大小加上底层基础数据类型的大小。</p>
<p>包装类型的Retained Size占用情况如下：</p>
<table>
<thead>
<tr>
<th>Numberic Wrappers</th>
<th>+useCompressedOops</th>
<th>-useCompressedOops</th>
</tr>
</thead>
<tbody>
<tr>
<td>Byte, Boolean</td>
<td>16 bytes</td>
<td>24 bytes</td>
</tr>
<tr>
<td>Short, Character</td>
<td>16 bytes</td>
<td>24 bytes</td>
</tr>
<tr>
<td>Integer, Float</td>
<td>16 bytes</td>
<td>24 bytes</td>
</tr>
<tr>
<td>Long, Double</td>
<td>24 bytes</td>
<td>24 bytes</td>
</tr>
</tbody>
</table>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM options:</div><div class="line"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</div><div class="line"> * -XX:+UseCompressedOops</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectSize</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    Boolean a = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</div><div class="line">    Byte b = <span class="keyword">new</span> Byte(<span class="string">"1"</span>);</div><div class="line">    Short c = <span class="keyword">new</span> Short(<span class="string">"1"</span>);</div><div class="line">    Character d = <span class="keyword">new</span> Character(<span class="string">'a'</span>);</div><div class="line">    Integer e = <span class="keyword">new</span> Integer(<span class="number">1</span>);</div><div class="line">    Float f = <span class="keyword">new</span> Float(<span class="number">2.5</span>);</div><div class="line">    Long g = <span class="keyword">new</span> Long(<span class="number">123L</span>);</div><div class="line">    Double h = <span class="keyword">new</span> Double(<span class="number">2.5</span>D);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        TestObjectSize testObjectSize = <span class="keyword">new</span> TestObjectSize();</div><div class="line">        <span class="comment">// 打印对象的shallow size</span></div><div class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</div><div class="line">        <span class="comment">// 打印对象的 retained size</span></div><div class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</div><div class="line">        System.in.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="开启指针压缩的情况-2"><a href="#开启指针压缩的情况-2" class="headerlink" title="开启指针压缩的情况"></a>开启指针压缩的情况</h4><p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shallow Size: 48 bytes</div><div class="line">Retained Size: 192 bytes</div></pre></td></tr></table></figure>
<p>MAT中的结果如下：</p>
<img src="/2017/05/06/Java对象内存布局/dump4.png" alt="dump4.png" title="">
<h4 id="关闭指针压缩的情况-2"><a href="#关闭指针压缩的情况-2" class="headerlink" title="关闭指针压缩的情况"></a>关闭指针压缩的情况</h4><p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shallow Size: 80 bytes</div><div class="line">Retained Size: 272 bytes</div></pre></td></tr></table></figure>
<p>MAT中的结果如下：</p>
<img src="/2017/05/06/Java对象内存布局/dump5.png" alt="dump5.png" title="">
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>在JDK1.7及以上版本中，<code>java.lang.String</code>中包含2个属性，一个用于存放字符串数据的char[], 一个int类型的hashcode, 部分源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> &#123;</div><div class="line">    <span class="comment">/** The value is used for character storage. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</div><div class="line"></div><div class="line">    <span class="comment">/** Cache the hash code for the string */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，在关闭指针压缩时，一个String对象的大小为：</p>
<ul>
<li><p><strong>Shallow Size=对象头大小16字节+int类型大小4字节+数组引用大小8字节+padding4字节=32字节</strong>；</p>
</li>
<li><p><strong>Retained Size=Shallow Size+char数组的Retained Size</strong>。</p>
</li>
</ul>
<p>在开启指针压缩时，一个String对象的大小为：</p>
<ul>
<li><p><strong>Shallow Size=对象头大小12字节+int类型大小4字节+数组引用大小4字节+padding4字节=24字节</strong>；</p>
</li>
<li><p><strong>Retained Size=Shallow Size+char数组的Retained Size</strong>。</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM options:</div><div class="line"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</div><div class="line"> * -XX:+UseCompressedOops</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectSize</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    String s = <span class="string">"test"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        TestObjectSize testObjectSize = <span class="keyword">new</span> TestObjectSize();</div><div class="line">        <span class="comment">// 打印对象的shallow size</span></div><div class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</div><div class="line">        <span class="comment">// 打印对象的 retained size</span></div><div class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</div><div class="line">        System.in.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="开启指针压缩的情况-3"><a href="#开启指针压缩的情况-3" class="headerlink" title="开启指针压缩的情况"></a>开启指针压缩的情况</h4><p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shallow Size: 16 bytes</div><div class="line">Retained Size: 64 bytes</div></pre></td></tr></table></figure>
<p>MAT中的结果如下：</p>
<img src="/2017/05/06/Java对象内存布局/dump6.png" alt="dump6.png" title="">
<h4 id="关闭指针压缩的情况-3"><a href="#关闭指针压缩的情况-3" class="headerlink" title="关闭指针压缩的情况"></a>关闭指针压缩的情况</h4><p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shallow Size: 24 bytes</div><div class="line">Retained Size: 88 bytes</div></pre></td></tr></table></figure>
<p>MAT中的结果如下：</p>
<img src="/2017/05/06/Java对象内存布局/dump7.png" alt="dump7.png" title="">
<h3 id="其他引用类型的大小"><a href="#其他引用类型的大小" class="headerlink" title="其他引用类型的大小"></a>其他引用类型的大小</h3><p>根据上面的分析，可以计算出一个对象在内存中的占用空间大小情况，其他的引用类型可以参考分析计算过程来计算内存的占用情况。</p>
<h2 id="关于padding"><a href="#关于padding" class="headerlink" title="关于padding"></a>关于padding</h2><p>思考这样一个问题，是不是padding都加到对象的后面呢，如果对象头占12个字节，对象中只有1个long类型的变量，那么该long类型的变量的偏移起始地址是在12吗？用下面一段代码测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ALL"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> a;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</div><div class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</div><div class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</div><div class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"a"</span>)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用Unsafe类来查看变量的偏移地址，运行后结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">16</div></pre></td></tr></table></figure>
<p>如果是换成int类型的变量呢？结果是12。</p>
<p>现在一般的CPU一次直接操作的数据可以到64位，也就是8个字节，那么字长就是64，而long类型本身就是占64位，如果这时偏移地址是12，那么需要分两次读取该数据，而如果偏移地址从16开始只需要通过一次读取即可。int类型的数据占用4个字节，所以可以从12开始。</p>
<p>把上面的代码修改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ALL"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> a;</div><div class="line"></div><div class="line">    <span class="keyword">byte</span> b;</div><div class="line"></div><div class="line">    <span class="keyword">byte</span> c;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</div><div class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</div><div class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</div><div class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"a"</span>)));</div><div class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"b"</span>)));</div><div class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"c"</span>)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">16</div><div class="line">12</div><div class="line">13</div></pre></td></tr></table></figure>
<p>在本例中，如果变量的大小小于等于4个字节，那么在分配内存的时候会先优先分配，因为这样可以减少padding，比如这里的b和c变量；如果这时达到了16个字节，那么其他的变量按照类型所占内存的大小降序分配。</p>
<p>再次修改代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM options: -javaagent:D:\source-files\classmexer.jar</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ALL"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> a;</div><div class="line">    <span class="keyword">byte</span> b;</div><div class="line"></div><div class="line">    <span class="keyword">short</span> c;</div><div class="line">    <span class="keyword">char</span> d;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> e;</div><div class="line">    <span class="keyword">float</span> f;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> g;</div><div class="line">    <span class="keyword">double</span> h;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</div><div class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</div><div class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"field a --&gt; "</span>+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"a"</span>)));</div><div class="line">        System.out.println(<span class="string">"field b --&gt; "</span>+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"b"</span>)));</div><div class="line">        System.out.println(<span class="string">"field c --&gt; "</span>+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"c"</span>)));</div><div class="line">        System.out.println(<span class="string">"field d --&gt; "</span>+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"d"</span>)));</div><div class="line">        System.out.println(<span class="string">"field e --&gt; "</span>+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"e"</span>)));</div><div class="line">        System.out.println(<span class="string">"field f --&gt; "</span>+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"f"</span>)));</div><div class="line">        System.out.println(<span class="string">"field g --&gt; "</span>+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"g"</span>)));</div><div class="line">        System.out.println(<span class="string">"field h --&gt; "</span>+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField(<span class="string">"h"</span>)));</div><div class="line"></div><div class="line">        PaddingTest paddingTest = <span class="keyword">new</span> PaddingTest();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Shallow Size: "</span>+ MemoryUtil.memoryUsageOf(paddingTest));</div><div class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(paddingTest));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">field a --&gt; 40</div><div class="line">field b --&gt; 41</div><div class="line">field c --&gt; 36</div><div class="line">field d --&gt; 38</div><div class="line">field e --&gt; 12</div><div class="line">field f --&gt; 32</div><div class="line">field g --&gt; 16</div><div class="line">field h --&gt; 24</div><div class="line">Shallow Size: 48</div><div class="line">Retained Size: 48</div></pre></td></tr></table></figure>
<p>可以看到，先分配的是int类型的变量e，因为它正好是4个字节，其余的都是先从g和h变量开始分配的，因为这两个变量是long类型和double类型的，占64位，最后分配的是a和b，它们只占一个字节。</p>
<p>如果分配到最后，这时字节数不是8的倍数，则需要padding。这里实际的大小是42字节，所以padding6字节，最终占用48字节。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java 中的锁 -- 偏向锁、轻量级锁、自旋锁、重量级锁]]></title>
      <url>http://www.ideabuffer.cn/2017/04/21/java-%E4%B8%AD%E7%9A%84%E9%94%81-%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</url>
      <content type="html"><![CDATA[<p>原文出处：<a href="http://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="external">http://blog.csdn.net/zqz_zqz/article/details/70233767</a></p>
<h2 id="理解锁的基础知识"><a href="#理解锁的基础知识" class="headerlink" title="理解锁的基础知识"></a>理解锁的基础知识</h2><p>如果想要透彻的理解java锁的来龙去脉，需要先了解以下基础知识。</p>
<h3 id="基础知识之一：锁的类型"><a href="#基础知识之一：锁的类型" class="headerlink" title="基础知识之一：锁的类型"></a>基础知识之一：锁的类型</h3><p>锁从宏观上分类，分为悲观锁与乐观锁。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p>
<p>java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p>
<a id="more"></a>
<h3 id="基础知识之二：java线程阻塞的代价"><a href="#基础知识之二：java线程阻塞的代价" class="headerlink" title="基础知识之二：java线程阻塞的代价"></a>基础知识之二：java线程阻塞的代价</h3><p>java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p>
<ol>
<li>如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间；</li>
<li>如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。</li>
</ol>
<p>synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。</p>
<p><strong>明确java线程切换的代价，是理解java中各种锁的优缺点的基础之一。</strong></p>
<h3 id="基础知识之三：markword"><a href="#基础知识之三：markword" class="headerlink" title="基础知识之三：markword"></a>基础知识之三：markword</h3><p>在介绍java锁之前，先说下什么是markword，markword是java对象数据结构中的一部分，要详细了解java对象的结构可以<a href="http://blog.csdn.net/zqz_zqz/article/details/70246212" target="_blank" rel="external">点击这里</a>,这里只做markword的详细介绍，因为对象的markword和java各种类型的锁密切相关；</p>
<p>markword数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，它的<strong>最后2bit是锁状态标志位</strong>，用来标记当前对象的状态，对象的所处的状态，决定了markword存储的内容，如下表所示:</p>
<table>
<thead>
<tr>
<th>状态</th>
<th style="text-align:center">标志位</th>
<th style="text-align:left">存储内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>未锁定</td>
<td style="text-align:center">01</td>
<td style="text-align:left">对象哈希码、对象分代年龄</td>
</tr>
<tr>
<td>轻量级锁定</td>
<td style="text-align:center">00</td>
<td style="text-align:left">指向锁记录的指针</td>
</tr>
<tr>
<td>膨胀(重量级锁定)</td>
<td style="text-align:center">10</td>
<td style="text-align:left">执行重量级锁定的指针</td>
</tr>
<tr>
<td>GC标记</td>
<td style="text-align:center">11</td>
<td style="text-align:left">空(不需要记录信息)</td>
</tr>
<tr>
<td>可偏向</td>
<td style="text-align:center">01</td>
<td style="text-align:left">偏向线程ID、偏向时间戳、对象分代年龄</td>
</tr>
</tbody>
</table>
<p>32位虚拟机在不同状态下markword结构如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20170419215511634?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenF6X3pxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>了解了markword结构，有助于后面了解java锁的加锁解锁过程；</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>前面提到了java的4种锁，他们分别是重量级锁、自旋锁、轻量级锁和偏向锁，<br>不同的锁有不同特点，每种锁只有在其特定的场景下，才会有出色的表现，java中没有哪种锁能够在所有情况下都能有出色的效率，引入这么多锁的原因就是为了应对不同的情况；</p>
<p>前面讲到了重量级锁是悲观锁的一种，自旋锁、轻量级锁与偏向锁属于乐观锁，所以现在你就能够大致理解了他们的适用范围，但是具体如何使用这几种锁呢，就要看后面的具体分析他们的特性；</p>
<h2 id="java中的锁"><a href="#java中的锁" class="headerlink" title="java中的锁"></a>java中的锁</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就<strong>避免用户线程和内核的切换的消耗</strong>。</p>
<p>但是线程自旋是需要消耗cup的，说白了就是让cup在做无用功，线程不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<h4 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h4><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗！</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，占着XX不XX，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup的线程又不能获取到cpu，造成cpu的浪费。</p>
<h4 id="自旋锁时间阈值"><a href="#自旋锁时间阈值" class="headerlink" title="自旋锁时间阈值"></a>自旋锁时间阈值</h4><p>自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p>
<p>JVM对于自旋周期的选择，jdk1.5这个限度是一定的写死的，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM还针对当前CPU的负荷情况做了较多的优化</p>
<ol>
<li><p>如果平均负载小于CPUs则一直自旋</p>
</li>
<li><p>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞</p>
</li>
<li><p>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞</p>
</li>
<li><p>如果CPU处于节电模式则停止自旋</p>
</li>
<li><p>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）</p>
</li>
<li><p>自旋时会适当放弃线程优先级之间的差异</p>
</li>
</ol>
<h4 id="自旋锁的开启"><a href="#自旋锁的开启" class="headerlink" title="自旋锁的开启"></a>自旋锁的开启</h4><ul>
<li>JDK1.6中-XX:+UseSpinning开启；</li>
<li>JDK1.7后，去掉此参数，由jvm控制。</li>
</ul>
<h3 id="重量级锁Synchronized"><a href="#重量级锁Synchronized" class="headerlink" title="重量级锁Synchronized"></a>重量级锁Synchronized</h3><h4 id="Synchronized的作用"><a href="#Synchronized的作用" class="headerlink" title="Synchronized的作用"></a>Synchronized的作用</h4><p>在JDK1.5之前都是使用synchronized关键字保证同步的，Synchronized的作用相信大家都已经非常熟悉了；</p>
<p>它可以把任意一个非NULL的对象当作锁。</p>
<ol>
<li>作用于方法时，锁住的是对象的实例(this)；</li>
<li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则是metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</li>
<li>synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。</li>
</ol>
<h4 id="Synchronized的实现"><a href="#Synchronized的实现" class="headerlink" title="Synchronized的实现"></a>Synchronized的实现</h4><p>实现如下图所示；</p>
<p><img src="http://img.blog.csdn.net/20170418221917277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenF6X3pxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p>
<ol>
<li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
</li>
<li><p>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</p>
</li>
<li><p>Wait Set：哪些调用wait方法被阻塞的线程被放置在这里；</p>
</li>
<li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck；</p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为Owner；</p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ol>
<p>JVM每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList会被大量的并发线程进行CAS访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList中作为候选竞争线程。Owner线程会在unlock时，将ContentionList中的部分线程迁移到EntryList中，并指定EntryList中的某个线程为OnDeck线程（一般是最先进去的那个线程）。Owner线程并不直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM中，也把这种选择行为称之为“竞争切换”。</p>
<p>OnDeck线程获取到锁资源后会变为Owner线程，而没有得到锁资源的仍然停留在EntryList中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify或者notifyAll唤醒，会重新进去EntryList中。</p>
<p>处于ContentionList、EntryList、WaitSet中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux内核下采用pthread_mutex_lock内核函数实现的）。</p>
<p><strong>Synchronized是非公平锁。</strong> Synchronized在线程进入ContentionList时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占OnDeck线程的锁资源。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。<br>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。<br>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</p>
<blockquote>
<p><em>它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。</em></p>
</blockquote>
<h4 id="偏向锁的实现"><a href="#偏向锁的实现" class="headerlink" title="偏向锁的实现"></a>偏向锁的实现</h4><h5 id="偏向锁获取过程："><a href="#偏向锁获取过程：" class="headerlink" title="偏向锁获取过程："></a>偏向锁获取过程：</h5><ol>
<li><p>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</p>
</li>
<li><p>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</p>
</li>
<li><p>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</p>
</li>
<li><p>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</p>
</li>
<li><p>执行同步代码。</p>
</li>
</ol>
<blockquote>
<p>注意：第四步中到达安全点safepoint会导致stop the word，时间很短。</p>
</blockquote>
<h5 id="偏向锁的释放："><a href="#偏向锁的释放：" class="headerlink" title="偏向锁的释放："></a>偏向锁的释放：</h5><p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<h4 id="偏向锁的适用场景"><a href="#偏向锁的适用场景" class="headerlink" title="偏向锁的适用场景"></a>偏向锁的适用场景</h4><p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作；<br>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致stw，导致性能下降，这种情况下应当禁用；</p>
<p>通过设置JVM参数 -XX:+PrintGCApplicationStoppedTime 会打出系统停止的时间，添加-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 这两个参数会打印出详细信息，可以查看到使用偏向锁导致的停顿，时间非常短暂，但是争用严重的情况下，停顿次数也会非常多；</p>
<p><img src="http://img.blog.csdn.net/20170420165422130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenF6X3pxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>此日志分两段，第一段是时间戳，VM Operation的类型，以及线程概况<br>total: 安全点里的总线程数<br>initially_running: 安全点时开始时正在运行状态的线程数<br>wait_to_block: 在VM Operation开始前需要等待其暂停的线程数</p>
<p>第二行是到达安全点时的各个阶段以及执行操作所花的时间，其中最重要的是vmop</p>
<ul>
<li>spin: 等待线程响应safepoint号召的时间；</li>
<li>block: 暂停所有线程所用的时间；</li>
<li>sync: 等于 spin+block，这是从开始到进入安全点所耗的时间，可用于判断进入安全点耗时；</li>
<li>cleanup: 清理所用时间；</li>
<li>vmop: 真正执行VM Operation的时间。</li>
</ul>
<p>可见，那些很多但又很短的安全点，全都是RevokeBias， 高并发的应用会禁用掉偏向锁。</p>
<h4 id="jvm开启-关闭偏向锁"><a href="#jvm开启-关闭偏向锁" class="headerlink" title="jvm开启/关闭偏向锁"></a>jvm开启/关闭偏向锁</h4><ul>
<li>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0   </li>
<li>关闭偏向锁：-XX:-UseBiasedLocking  </li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；<br>轻量级锁的加锁过程：</p>
<ol>
<li><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如图：<br>　　<img src="http://img.blog.csdn.net/20170420102716139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenF6X3pxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">所示。</p>
</li>
<li><p>拷贝对象头中的Mark Word复制到锁记录中；</p>
</li>
<li><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。</p>
</li>
<li><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图所示。<br>　　<img src="http://img.blog.csdn.net/20170420102754608?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenF6X3pxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</p>
</li>
</ol>
<h4 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h4><p><strong>释放锁线程视角</strong>：由轻量锁切换到重量锁，是发生在轻量锁释放锁的期间，之前在获取锁的时候它拷贝了锁对象头的markword，在释放锁的时候如果它发现在它持有锁的期间有其他线程来尝试获取锁了，并且该线程对markword做了修改，两者比对发现不一致，则切换到重量锁。</p>
<p>因为重量级锁被修改了，所有display mark word和原来的markword不一样了。</p>
<p>怎么补救，就是进入mutex前，compare一下obj的markword状态。确认该markword是否被其他线程持有。</p>
<p>此时如果线程已经释放了markword，那么通过CAS后就可以直接进入线程，无需进入mutex，就这个作用。</p>
<p><strong>尝试获取锁线程视角</strong>：如果线程尝试获取锁的时候，轻量锁正被其他线程占有，那么它就会修改markword，修改重量级锁，表示该进入重量锁了。</p>
<p>还有一个注意点：等待轻量锁的线程不会阻塞，它会一直自旋等待锁，并如上所说修改markword。</p>
<p>这就是自旋锁，尝试获取锁的线程，在没有获得锁的时候，不被挂起，而转而去执行一个空循环，即自旋。在若干个自旋后，如果还没有获得锁，则才被挂起，获得锁，则执行代码。</p>
<p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://img.blog.csdn.net/20170420224430096?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenF6X3pxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>上面几种锁都是JVM自己内部实现，当我们执行synchronized同步块的时候jvm会根据启用的锁和当前线程的争用情况，决定如何执行同步操作；</p>
<p>在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，如果以上两种都失败，则启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，使线程阻塞挂起；</p>
<p>如果线程争用激烈，那么应该禁用偏向锁。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java线程池：ScheduledThreadPoolExecutor]]></title>
      <url>http://www.ideabuffer.cn/2017/04/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AScheduledThreadPoolExecutor/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>自JDK1.5开始，JDK提供了ScheduledThreadPoolExecutor类来支持周期性任务的调度。在这之前的实现需要依靠Timer和TimerTask或者其它第三方工具来完成。但Timer有不少的缺陷：</p>
<ul>
<li>Timer是单线程模式；</li>
<li>如果在执行任务期间某个TimerTask耗时较久，那么就会影响其它任务的调度；</li>
<li>Timer的任务调度是基于绝对时间的，对系统时间敏感；</li>
<li>Timer不会捕获执行TimerTask时所抛出的异常，由于Timer是单线程，所以一旦出现异常，则线程就会终止，其他任务也得不到执行。</li>
</ul>
<p>ScheduledThreadPoolExecutor继承ThreadPoolExecutor来重用线程池的功能，它的实现方式如下：</p>
<ul>
<li>将任务封装成ScheduledFutureTask对象，ScheduledFutureTask基于相对时间，不受系统时间的改变所影响；</li>
<li>ScheduledFutureTask实现了<code>java.lang.Comparable</code>接口和<code>java.util.concurrent.Delayed</code>接口，所以有两个重要的方法：compareTo和getDelay。compareTo方法用于比较任务之间的优先级关系，如果距离下次执行的时间间隔较短，则优先级高；getDelay方法用于返回距离下次任务执行时间的时间间隔；</li>
<li>ScheduledThreadPoolExecutor定义了一个DelayedWorkQueue，它是一个有序队列，会通过每个任务按照距离下次执行时间间隔的大小来排序；</li>
<li>ScheduledFutureTask继承自FutureTask，可以通过返回Future对象来获取执行的结果。</li>
</ul>
<p>通过如上的介绍，可以对比一下Timer和ScheduledThreadPoolExecutor：</p>
<table>
<thead>
<tr>
<th>Timer</th>
<th>ScheduledThreadPoolExecutor</th>
</tr>
</thead>
<tbody>
<tr>
<td>单线程</td>
<td>多线程</td>
</tr>
<tr>
<td>单个任务执行时间影响其他任务调度</td>
<td>多线程，不会影响</td>
</tr>
<tr>
<td>基于绝对时间</td>
<td>基于相对时间</td>
</tr>
<tr>
<td>一旦执行任务出现异常不会捕获，其他任务得不到执行</td>
<td>多线程，单个任务的执行不会影响其他线程</td>
</tr>
</tbody>
</table>
<p>所以，在JDK1.5之后，应该没什么理由继续使用Timer进行任务调度了。</p>
<a id="more"></a>
<h2 id="ScheduledThreadPoolExecutor的使用"><a href="#ScheduledThreadPoolExecutor的使用" class="headerlink" title="ScheduledThreadPoolExecutor的使用"></a>ScheduledThreadPoolExecutor的使用</h2><p>下面用一个具体的例子来说明ScheduledThreadPoolExecutor的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 创建大小为5的线程池</span></div><div class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">            Task worker = <span class="keyword">new</span> Task(<span class="string">"task-"</span> + i);</div><div class="line">            <span class="comment">// 只执行一次</span></div><div class="line"><span class="comment">//          scheduledThreadPool.schedule(worker, 5, TimeUnit.SECONDS);</span></div><div class="line">            <span class="comment">// 周期性执行，每5秒执行一次</span></div><div class="line">            scheduledThreadPool.scheduleAtFixedRate(worker, <span class="number">0</span>,<span class="number">5</span>, TimeUnit.SECONDS);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">10000</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Shutting down executor..."</span>);</div><div class="line">        <span class="comment">// 关闭线程池</span></div><div class="line">        scheduledThreadPool.shutdown();</div><div class="line">        <span class="keyword">boolean</span> isDone;</div><div class="line">        <span class="comment">// 等待线程池终止</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            isDone = scheduledThreadPool.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</div><div class="line">            System.out.println(<span class="string">"awaitTermination..."</span>);</div><div class="line">        &#125; <span class="keyword">while</span>(!isDone);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Finished all threads"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"name = "</span> + name + <span class="string">", startTime = "</span> + <span class="keyword">new</span> Date());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"name = "</span> + name + <span class="string">", endTime = "</span> + <span class="keyword">new</span> Date());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面就来具体分析一下ScheduledThreadPoolExecutor的实现过程。</p>
<h2 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h2><h3 id="ScheduledThreadPoolExecutor的类结构"><a href="#ScheduledThreadPoolExecutor的类结构" class="headerlink" title="ScheduledThreadPoolExecutor的类结构"></a>ScheduledThreadPoolExecutor的类结构</h3><p>看下ScheduledThreadPoolExecutor内部的类图：</p>
<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/QQ20170409-013110.png" alt="QQ20170409-013110.png" title="">
<p>不要被这么多类吓到，这里只不过是为了更清楚的了解ScheduledThreadPoolExecutor有关调度和队列的接口。</p>
<p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，实现了ScheduledExecutorService接口，该接口定义了schedule等任务调度的方法。</p>
<p>同时ScheduledThreadPoolExecutor有两个重要的内部类：DelayedWorkQueue和ScheduledFutureTask。可以看到，DelayeddWorkQueue是一个阻塞队列，而ScheduledFutureTask继承自FutureTask，并且实现了Delayed接口。有关FutureTask的介绍请参考另一篇文章：<a href="http://www.ideabuffer.cn/2017/04/06/FutureTask源码解析/FutureTask源码解析/">FutureTask源码解析</a>。</p>
<h3 id="ScheduledThreadPoolExecutor的构造方法"><a href="#ScheduledThreadPoolExecutor的构造方法" class="headerlink" title="ScheduledThreadPoolExecutor的构造方法"></a>ScheduledThreadPoolExecutor的构造方法</h3><p>ScheduledThreadPoolExecutor有3中构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                                    ThreadFactory threadFactory) &#123;</div><div class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</div><div class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                                   RejectedExecutionHandler handler) &#123;</div><div class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</div><div class="line">          <span class="keyword">new</span> DelayedWorkQueue(), handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                                   ThreadFactory threadFactory,</div><div class="line">                                   RejectedExecutionHandler handler) &#123;</div><div class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</div><div class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，所以这里都是调用的ThreadPoolExecutor类的构造方法。有关ThreadPoolExecutor可以参考<a href="http://www.ideabuffer.cn/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a>。</p>
<p>这里注意传入的阻塞队列是DelayedWorkQueue类型的对象。后面会详细介绍。</p>
<h3 id="schedule方法"><a href="#schedule方法" class="headerlink" title="schedule方法"></a>schedule方法</h3><p>在上文的例子中，使用了schedule方法来进行任务调度，schedule方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</div><div class="line">                                   <span class="keyword">long</span> delay,</div><div class="line">                                   TimeUnit unit) &#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</div><div class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,</div><div class="line">                                      triggerTime(delay, unit)));</div><div class="line">    delayedExecute(t);</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></div><div class="line">                                       <span class="keyword">long</span> delay,</div><div class="line">                                       TimeUnit unit) &#123;</div><div class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</div><div class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable,</div><div class="line">                                   triggerTime(delay, unit)));</div><div class="line">    delayedExecute(t);</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，这里的两个重载的schedule方法只是传入的第一个参数不同，可以是Runnable对象或者Callable对象。会把传入的任务封装成一个RunnableScheduledFuture对象，其实也就是ScheduledFutureTask对象，decorateTask默认什么功能都没有做，子类可以重写该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 修改或替换用于执行 runnable 的任务。此方法可重写用于管理内部任务的具体类。默认实现只返回给定任务。</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(</span></span></div><div class="line">    Runnable runnable, RunnableScheduledFuture&lt;V&gt; task) &#123;</div><div class="line">    <span class="keyword">return</span> task;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 修改或替换用于执行 callable 的任务。此方法可重写用于管理内部任务的具体类。默认实现只返回给定任务。</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(</span></span></div><div class="line">    Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task) &#123;</div><div class="line">    <span class="keyword">return</span> task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，通过调用delayedExecute方法来延时执行任务。<br>最后，返回一个ScheduledFuture对象。</p>
<h3 id="scheduleAtFixedRate方法"><a href="#scheduleAtFixedRate方法" class="headerlink" title="scheduleAtFixedRate方法"></a>scheduleAtFixedRate方法</h3><p>该方法设置了执行周期，下一次执行时间相当于是上一次的执行时间加上period，它是采用已固定的频率来执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</div><div class="line">                                              <span class="keyword">long</span> initialDelay,</div><div class="line">                                              <span class="keyword">long</span> period,</div><div class="line">                                              TimeUnit unit) &#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    ScheduledFutureTask&lt;Void&gt; sft =</div><div class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</div><div class="line">                                      <span class="keyword">null</span>,</div><div class="line">                                      triggerTime(initialDelay, unit),</div><div class="line">                                      unit.toNanos(period));</div><div class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</div><div class="line">    sft.outerTask = t;</div><div class="line">    delayedExecute(t);</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="scheduleWithFixedDelay方法"><a href="#scheduleWithFixedDelay方法" class="headerlink" title="scheduleWithFixedDelay方法"></a>scheduleWithFixedDelay方法</h3><p>该方法设置了执行周期，与scheduleAtFixedRate方法不同的是，下一次执行时间是上一次任务执行完的系统时间加上period，因而具体执行时间不是固定的，但周期是固定的，是采用相对固定的延迟来执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</div><div class="line">                                                 <span class="keyword">long</span> initialDelay,</div><div class="line">                                                 <span class="keyword">long</span> delay,</div><div class="line">                                                 TimeUnit unit) &#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    ScheduledFutureTask&lt;Void&gt; sft =</div><div class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</div><div class="line">                                      <span class="keyword">null</span>,</div><div class="line">                                      triggerTime(initialDelay, unit),</div><div class="line">                                      unit.toNanos(-delay));</div><div class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</div><div class="line">    sft.outerTask = t;</div><div class="line">    delayedExecute(t);</div><div class="line">    <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的<code>unit.toNanos(-delay));</code>，这里把周期设置为负数来表示是相对固定的延迟执行。</p>
<p>scheduleAtFixedRate和scheduleWithFixedDelay的区别在setNextRunTime方法中就可以看出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> p = period;</div><div class="line">    <span class="comment">// 固定频率，上次执行时间加上周期时间</span></div><div class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</div><div class="line">        time += p;</div><div class="line">    <span class="comment">// 相对固定延迟执行，使用当前系统时间加上周期时间</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        time = triggerTime(-p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>setNextRunTime方法会在run方法中执行完任务后调用。</p>
<h3 id="triggerTime方法"><a href="#triggerTime方法" class="headerlink" title="triggerTime方法"></a>triggerTime方法</h3><p>triggerTime方法用于获取下一次执行的具体时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="number">0</span>) ? <span class="number">0</span> : delay));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> now() +</div><div class="line">        ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>delay &lt; (Long.MAX_VALUE &gt;&gt; 1</code>是为了判断是否要防止Long类型溢出，如果delay的值小于Long类型最大值的一半，则直接返回delay，否则需要进行防止溢出处理。</p>
<h3 id="overflowFree方法"><a href="#overflowFree方法" class="headerlink" title="overflowFree方法"></a>overflowFree方法</h3><p>该方法的作用是限制队列中所有节点的延迟时间在Long.MAX_VALUE之内，防止在compareTo方法中溢出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">overflowFree</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取队列中的第一个节点</span></div><div class="line">    Delayed head = (Delayed) <span class="keyword">super</span>.getQueue().peek();</div><div class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 获取延迟时间</span></div><div class="line">        <span class="keyword">long</span> headDelay = head.getDelay(NANOSECONDS);</div><div class="line">        <span class="comment">// 如果延迟时间小于0，并且 delay - headDelay 超过了Long.MAX_VALUE</span></div><div class="line">        <span class="comment">// 将delay设置为 Long.MAX_VALUE + headDelay 保证delay小于Long.MAX_VALUE</span></div><div class="line">        <span class="keyword">if</span> (headDelay &lt; <span class="number">0</span> &amp;&amp; (delay - headDelay &lt; <span class="number">0</span>))</div><div class="line">            delay = Long.MAX_VALUE + headDelay;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> delay;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当一个任务已经可以执行出队操作，但还没有执行，可能由于线程池中的工作线程不是空闲的。具体分析一下这种情况：</p>
<ul>
<li>为了方便说明，假设Long.MAX_VALUE=1023，也就是11位，并且当前的时间是100，调用triggerTime时并没有对delay进行判断，而是直接返回了<code>now() + delay</code>，也就是相当于<code>100 + 1023</code>，这肯定是溢出了，那么返回的时间是-925；</li>
<li>如果头节点已经可以出队但是还没有执行出队，那么头节点的执行时间应该是小于当前时间的，假设是95；</li>
<li>这时调用offer方法向队列中添加任务，在offer方法中会调用siftUp方法来排序，在siftUp方法执行时又会调用ScheduledFutureTask中的compareTo方法来比较执行时间；</li>
<li>这时如果执行到了compareTo方法中的<code>long diff = time - x.time;</code>时，那么计算后的结果就是<code>-925 - 95 = -1020</code>，那么将返回-1，而正常情况应该是返回1，因为新加入的任务的执行时间要比头结点的执行时间要晚，这就不是我们想要的结果了，这会导致队列中的顺序不正确。</li>
<li>同理也可以算一下在执行compareTo方法中的<code>long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</code>时也会有这种情况；</li>
<li>所以在triggerTime方法中对delay的大小做了判断，就是为了防止这种情况发生。</li>
</ul>
<p>如果执行了overflowFree方法呢，这时<code>headDelay = 95 - 100 = -5</code>，然后执行<code>delay = 1023 + (-5) = 1018</code>，那么triggerTime会返回<code>100 + 1018 = -930</code>，再执行compareTo方法中的<code>long diff = time - x.time;</code>时，<code>diff = -930 - 95 = -930 - 100 + 5 = 1018 + 5 = 1023</code>，没有溢出，符合正常的预期。</p>
<p>所以，overflowFree方法中把已经超时的部分时间给减去，就是为了避免在compareTo方法中出现溢出情况。</p>
<p>（说实话，这段代码看的很痛苦，一般情况下也不会发生这种情况，谁会传一个Long.MAX_VALUE呢。要知道Long.MAX_VALUE的纳秒数换算成年的话是292年，谁会这么无聊。。。）</p>
<h3 id="ScheduledFutureTask的getDelay方法"><a href="#ScheduledFutureTask的getDelay方法" class="headerlink" title="ScheduledFutureTask的getDelay方法"></a>ScheduledFutureTask的getDelay方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</div><div class="line">    <span class="comment">// 执行时间减去当前系统时间</span></div><div class="line">    <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ScheduledFutureTask的构造方法"><a href="#ScheduledFutureTask的构造方法" class="headerlink" title="ScheduledFutureTask的构造方法"></a>ScheduledFutureTask的构造方法</h3><p>ScheduledFutureTask继承自FutureTask并实现了RunnableScheduledFuture接口，具体可以参考上文的类图，构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) &#123;</div><div class="line">    <span class="keyword">super</span>(r, result);</div><div class="line">    <span class="keyword">this</span>.time = ns;</div><div class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</div><div class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates a periodic action with given nano time and period.</div><div class="line"> */</div><div class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</div><div class="line">    <span class="keyword">super</span>(r, result);</div><div class="line">    <span class="keyword">this</span>.time = ns;</div><div class="line">    <span class="keyword">this</span>.period = period;</div><div class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates a one-shot action with given nanoTime-based trigger time.</div><div class="line"> */</div><div class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</div><div class="line">    <span class="keyword">super</span>(callable);</div><div class="line">    <span class="keyword">this</span>.time = ns;</div><div class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</div><div class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面有几个重要的属性，下面来解释一下：</p>
<ul>
<li><strong>time</strong>：下次任务执行时的时间；</li>
<li><strong>period</strong>：执行周期；</li>
<li><strong>sequenceNumber</strong>：保存任务被添加到ScheduledThreadPoolExecutor中的序号。</li>
</ul>
<p>在schedule方法中，创建完ScheduledFutureTask对象之后，会执行delayedExecute方法来执行任务。</p>
<h3 id="delayedExecute方法"><a href="#delayedExecute方法" class="headerlink" title="delayedExecute方法"></a>delayedExecute方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果线程池已经关闭，使用拒绝策略拒绝任务</span></div><div class="line">    <span class="keyword">if</span> (isShutdown())</div><div class="line">        reject(task);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 添加到阻塞队列中</span></div><div class="line">        <span class="keyword">super</span>.getQueue().add(task);</div><div class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</div><div class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</div><div class="line">            remove(task))</div><div class="line">            task.cancel(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="comment">// 确保线程池中至少有一个线程启动，即使corePoolSize为0</span></div><div class="line">            <span class="comment">// 该方法在ThreadPoolExecutor中实现</span></div><div class="line">            ensurePrestart();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说一下这里的第二个if判断：</p>
<ol>
<li>如果不是SHUTDOWN状态，执行else，否则执行步骤2；</li>
<li>如果在当前线程池运行状态下可以执行任务，执行else，否则执行步骤3；</li>
<li>从阻塞队列中删除任务，如果失败，执行else，否则执行步骤4；</li>
<li>取消任务，但不中断执行中的任务。</li>
</ol>
<p>对于步骤2，可以通过setContinueExistingPeriodicTasksAfterShutdownPolicy方法设置在线程池关闭时，周期任务继续执行，默认为false，也就是线程池关闭时，不再执行周期任务。</p>
<p>ensurePrestart方法在ThreadPoolExecutor中定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());</div><div class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</div><div class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</div><div class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用了addWorker方法，可以在<a href="http://www.ideabuffer.cn/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/#addWorker方法">深入理解Java线程池：ThreadPoolExecutor</a>中查看addWorker方法的介绍，线程池中的工作线程是通过该方法来启动并执行任务的。</p>
<h3 id="ScheduledFutureTask的run方法"><a href="#ScheduledFutureTask的run方法" class="headerlink" title="ScheduledFutureTask的run方法"></a>ScheduledFutureTask的run方法</h3><p>回顾一下线程池的执行过程：当线程池中的工作线程启动时，不断地从阻塞队列中取出任务并执行，当然，取出的任务实现了Runnable接口，所以是通过调用任务的run方法来执行任务的。</p>
<p>这里的任务类型是ScheduledFutureTask，所以下面看一下ScheduledFutureTask的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 是否是周期性任务</span></div><div class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</div><div class="line">    <span class="comment">// 当前线程池运行状态下如果不可以执行任务，取消该任务</span></div><div class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</div><div class="line">        cancel(<span class="keyword">false</span>);</div><div class="line">    <span class="comment">// 如果不是周期性任务，调用FutureTask中的run方法执行</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</div><div class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</div><div class="line">    <span class="comment">// 如果是周期性任务，调用FutureTask中的runAndReset方法执行</span></div><div class="line">    <span class="comment">// runAndReset方法不会设置执行结果，所以可以重复执行任务</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</div><div class="line">        <span class="comment">// 计算下次执行该任务的时间</span></div><div class="line">        setNextRunTime();</div><div class="line">        <span class="comment">// 重复执行任务</span></div><div class="line">        reExecutePeriodic(outerTask);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有关FutureTask的run方法和runAndReset方法，可以参考<a href="http://www.ideabuffer.cn/2017/04/06/FutureTask源码解析/FutureTask源码解析/">FutureTask源码解析</a>。</p>
<p>分析一下执行过程：</p>
<ol>
<li>如果当前线程池运行状态不可以执行任务，取消该任务，然后直接返回，否则执行步骤2；</li>
<li>如果不是周期性任务，调用FutureTask中的run方法执行，会设置执行结果，然后直接返回，否则执行步骤3；</li>
<li>如果是周期性任务，调用FutureTask中的runAndReset方法执行，不会设置执行结果，然后直接返回，否则执行步骤4和步骤5；</li>
<li>计算下次执行该任务的具体时间；</li>
<li>重复执行任务。</li>
</ol>
<h3 id="ScheduledFutureTask的reExecutePeriodic方法"><a href="#ScheduledFutureTask的reExecutePeriodic方法" class="headerlink" title="ScheduledFutureTask的reExecutePeriodic方法"></a>ScheduledFutureTask的reExecutePeriodic方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;</div><div class="line">        <span class="keyword">super</span>.getQueue().add(task);</div><div class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task))</div><div class="line">            task.cancel(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            ensurePrestart();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法和delayedExecute方法类似，不同的是：</p>
<ol>
<li>由于调用reExecutePeriodic方法时已经执行过一次周期性任务了，所以不会reject当前任务；</li>
<li>传入的任务一定是周期性任务。</li>
</ol>
<h3 id="onShutdown方法"><a href="#onShutdown方法" class="headerlink" title="onShutdown方法"></a>onShutdown方法</h3><p>onShutdown方法是ThreadPoolExecutor中的钩子方法，在ThreadPoolExecutor中什么都没有做，参考<a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a>，该方法是在执行shutdown方法时被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">    BlockingQueue&lt;Runnable&gt; q = <span class="keyword">super</span>.getQueue();</div><div class="line">    <span class="comment">// 获取在线程池已 shutdown 的情况下是否继续执行现有延迟任务</span></div><div class="line">    <span class="keyword">boolean</span> keepDelayed =</div><div class="line">        getExecuteExistingDelayedTasksAfterShutdownPolicy();</div><div class="line">    <span class="comment">// 获取在线程池已 shutdown 的情况下是否继续执行现有定期任务</span></div><div class="line">    <span class="keyword">boolean</span> keepPeriodic =</div><div class="line">        getContinueExistingPeriodicTasksAfterShutdownPolicy();</div><div class="line">    <span class="comment">// 如果在线程池已 shutdown 的情况下不继续执行延迟任务和定期任务</span></div><div class="line">    <span class="comment">// 则依次取消任务，否则则根据取消状态来判断</span></div><div class="line">    <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;</div><div class="line">        <span class="keyword">for</span> (Object e : q.toArray())</div><div class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</div><div class="line">                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="keyword">false</span>);</div><div class="line">        q.clear();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Traverse snapshot to avoid iterator exceptions</span></div><div class="line">        <span class="keyword">for</span> (Object e : q.toArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</div><div class="line">                RunnableScheduledFuture&lt;?&gt; t =</div><div class="line">                    (RunnableScheduledFuture&lt;?&gt;)e;</div><div class="line">                <span class="comment">// 如果有在 shutdown 后不继续的延迟任务或周期任务，则从队列中删除并取消任务</span></div><div class="line">                <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||</div><div class="line">                    t.isCancelled()) &#123; <span class="comment">// also remove if already cancelled</span></div><div class="line">                    <span class="keyword">if</span> (q.remove(t))</div><div class="line">                        t.cancel(<span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    tryTerminate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h2><p>ScheduledThreadPoolExecutor之所以要自己实现阻塞的工作队列，是因为ScheduledThreadPoolExecutor要求的工作队列有些特殊。</p>
<p>DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面（<strong>注意：这里的顺序并不是绝对的，堆中的排序只保证了子节点的下次执行时间要比父节点的下次执行时间要大，而叶子节点之间并不一定是顺序的，下文中会说明</strong>）。</p>
<p>堆结构如下图所示：</p>
<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/QQ20170411-223120.png" alt="QQ20170411-223120.png" title="">
<p>可见，DelayedWorkQueue是一个基于最小堆结构的队列。堆结构可以使用数组表示，可以转换成如下的数组：</p>
<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/QQ20170411-224025@2x.png" alt="QQ20170411-224025@2x.png" title="">
<p>在这种结构中，可以发现有如下特性：</p>
<p>假设，索引值从0开始，子节点的索引值为k，父节点的索引值为p，则：</p>
<ol>
<li>一个节点的左子节点的索引为：k = p * 2 + 1；</li>
<li>一个节点的右子节点的索引为：k = (p + 1) * 2；</li>
<li>一个节点的父节点的索引为：p = (k - 1) / 2。</li>
</ol>
<p><strong>为什么要使用DelayedWorkQueue呢？</strong></p>
<p>定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。</p>
<p>DelayedWorkQueue是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 <em>O(logN)</em>。</p>
<h3 id="DelayedWorkQueue的属性"><a href="#DelayedWorkQueue的属性" class="headerlink" title="DelayedWorkQueue的属性"></a>DelayedWorkQueue的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 队列初始容量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</div><div class="line"><span class="comment">// 根据初始容量创建RunnableScheduledFuture类型的数组</span></div><div class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =</div><div class="line">    <span class="keyword">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// leader线程</span></div><div class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</div><div class="line"><span class="comment">// 当较新的任务在队列的头部可用时，或者新线程可能需要成为leader，则通过该条件发出信号</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</div></pre></td></tr></table></figure>
<p>注意这里的leader，它是Leader-Follower模式的变体，用于减少不必要的定时等待。什么意思呢？对于多线程的网络模型来说：</p>
<blockquote>
<p>所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p>
</blockquote>
<p><em>参考自：<a href="http://blog.csdn.net/goldlevi/article/details/7705180" target="_blank" rel="external">http://blog.csdn.net/goldlevi/article/details/7705180</a></em></p>
<p>具体leader的作用在分析take方法时再详细介绍。</p>
<h3 id="offer方法"><a href="#offer方法" class="headerlink" title="offer方法"></a>offer方法</h3><p>既然是阻塞队列，入队的操作如add和put方法都调用了offer方法，下面查看一下offer方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = size;</div><div class="line">        <span class="comment">// queue是一个RunnableScheduledFuture类型的数组，如果容量不够需要扩容</span></div><div class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</div><div class="line">            grow();</div><div class="line">        size = i + <span class="number">1</span>;</div><div class="line">        <span class="comment">// i == 0 说明堆中还没有数据</span></div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">            queue[<span class="number">0</span>] = e;</div><div class="line">            setIndex(e, <span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// i != 0 时，需要对堆进行重新排序</span></div><div class="line">            siftUp(i, e);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果传入的任务已经是队列的第一个节点了，这时available需要发出信号</span></div><div class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</div><div class="line">            <span class="comment">// leader设置为null为了使在take方法中的线程在通过available.signal();后会执行available.awaitNanos(delay);</span></div><div class="line">            leader = <span class="keyword">null</span>;</div><div class="line">            available.signal();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有关Condition的介绍请参考<a href="http://www.ideabuffer.cn/2017/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer%EF%BC%88%E4%B8%89%EF%BC%89/">深入理解AbstractQueuedSynchronizer（三）</a></p>
<p>这里的重点是siftUp方法。</p>
<h3 id="siftUp方法"><a href="#siftUp方法" class="headerlink" title="siftUp方法"></a>siftUp方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 找到父节点的索引</span></div><div class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="comment">// 获取父节点</span></div><div class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent];</div><div class="line">        <span class="comment">// 如果key节点的执行时间大于父节点的执行时间，不需要再排序了</span></div><div class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 如果key.compareTo(e) &lt; 0，说明key节点的执行时间小于父节点的执行时间，需要把父节点移到后面</span></div><div class="line">        queue[k] = e;</div><div class="line">        <span class="comment">// 设置索引为k</span></div><div class="line">        setIndex(e, k);</div><div class="line">        k = parent;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// key设置为排序后的位置中</span></div><div class="line">    queue[k] = key;</div><div class="line">    setIndex(key, k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很好理解，就是循环的根据key节点与它的父节点来判断，如果key节点的执行时间小于父节点，则将两个节点交换，使执行时间靠前的节点排列在队列的前面。</p>
<p>假设新入队的节点的延迟时间（调用getDelay()方法获得）是5，执行过程如下：</p>
<ol>
<li><strong>先将新的节点添加到数组的尾部，这时新节点的索引k为7：</strong><img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/siftup-1.png" alt="siftup-1.png" title=""></li>
<li><strong>计算新父节点的索引：parent = (k - 1) &gt;&gt;&gt; 1，parent = 3，那么queue[3]的时间间隔值为8，因为 5 &lt; 8 ，将执行queue[7] = queue[3]：</strong>：<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/siftup-2.png" alt="siftup-2.png" title=""></li>
<li><strong>这时将k设置为3，继续循环，再次计算parent为1，queue[1]的时间间隔为3，因为 5 &gt; 3 ，这时退出循环，最终k为3：</strong><img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/siftup-3.png" alt="siftup-3.png" title="">
</li>
</ol>
<p>可见，每次新增节点时，只是根据父节点来判断，而不会影响兄弟节点。</p>
<p>另外，setIndex方法只是设置了ScheduledFutureTask中的heapIndex属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(RunnableScheduledFuture&lt;?&gt; f, <span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ScheduledFutureTask)</div><div class="line">        ((ScheduledFutureTask)f).heapIndex = idx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</div><div class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</div><div class="line">                available.await();</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 计算当前时间到执行时间的时间间隔</span></div><div class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</div><div class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> finishPoll(first);</div><div class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></div><div class="line">                <span class="comment">// leader不为空，阻塞线程</span></div><div class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</div><div class="line">                    available.await();</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// leader为空，则把leader设置为当前线程，</span></div><div class="line">                    Thread thisThread = Thread.currentThread();</div><div class="line">                    leader = thisThread;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="comment">// 阻塞到执行时间</span></div><div class="line">                        available.awaitNanos(delay);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="comment">// 设置leader = null，让其他线程执行available.awaitNanos(delay);</span></div><div class="line">                        <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                            leader = <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// 如果leader不为空，则说明leader的线程正在执行available.awaitNanos(delay);</span></div><div class="line">        <span class="comment">// 如果queue[0] == null，说明队列为空</span></div><div class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</div><div class="line">            available.signal();</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>take方法是什么时候调用的呢？在<a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a>中，介绍了getTask方法，工作线程会循环地从workQueue中取任务。但定时任务却不同，因为如果一旦getTask方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在take方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p>
<p>再来说一下leader的作用，这里的leader是为了减少不必要的定时等待，当一个线程成为leader时，它只等待下一个节点的时间间隔，但其它线程无限期等待。 leader线程必须在从take（）或poll（）返回之前signal其它线程，除非其他线程成为了leader。</p>
<p>举例来说，如果没有leader，那么在执行take时，都要执行<code>available.awaitNanos(delay)</code>，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。多个这时执行该段代码是没有作用的，因为只能有一个线程会从take中返回queue[0]（因为有lock），其他线程这时再返回for循环执行时取的queue[0]，已经不是之前的queue[0]了，然后又要继续阻塞。</p>
<p>所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在finally中调用了signal()来唤醒一个线程，而不是signalAll()）。</p>
<h3 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h3><p>下面看下poll方法，与take类似，但这里要提供超时功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class="keyword">long</span> timeout, TimeUnit unit)</div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</div><div class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    nanos = available.awaitNanos(nanos);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</div><div class="line">                <span class="comment">// 如果delay &lt;= 0，说明已经到了任务执行的时间，返回。</span></div><div class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> finishPoll(first);</div><div class="line">                <span class="comment">// 如果nanos &lt;= 0，说明已经超时，返回null</span></div><div class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></div><div class="line">                <span class="comment">// nanos &lt; delay 说明需要等待的时间小于任务要执行的延迟时间</span></div><div class="line">                <span class="comment">// leader != null 说明有其它线程正在对任务进行阻塞</span></div><div class="line">                <span class="comment">// 这时阻塞当前线程nanos纳秒</span></div><div class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</div><div class="line">                    nanos = available.awaitNanos(nanos);</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    Thread thisThread = Thread.currentThread();</div><div class="line">                    leader = thisThread;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="comment">// 这里的timeLeft表示delay减去实际的等待时间</span></div><div class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</div><div class="line">                        <span class="comment">// 计算剩余的等待时间</span></div><div class="line">                        nanos -= delay - timeLeft;</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                            leader = <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</div><div class="line">            available.signal();</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="finishPoll方法"><a href="#finishPoll方法" class="headerlink" title="finishPoll方法"></a>finishPoll方法</h3><p>当调用了take或者poll方法能够获取到任务时，会调用该方法进行返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;</div><div class="line">    <span class="comment">// 数组长度-1</span></div><div class="line">    <span class="keyword">int</span> s = --size;</div><div class="line">    <span class="comment">// 取出最后一个节点</span></div><div class="line">    RunnableScheduledFuture&lt;?&gt; x = queue[s];</div><div class="line">    queue[s] = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 长度不为0，则从第一个元素开始排序，目的是要把最后一个节点放到合适的位置上</span></div><div class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</div><div class="line">        siftDown(<span class="number">0</span>, x);</div><div class="line">    setIndex(f, -<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="siftDown方法"><a href="#siftDown方法" class="headerlink" title="siftDown方法"></a>siftDown方法</h3><p>siftDown方法使堆从k开始向下调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据二叉树的特性，数组长度除以2，表示取有子节点的索引</span></div><div class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    <span class="comment">// 判断索引为k的节点是否有子节点</span></div><div class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</div><div class="line">        <span class="comment">// 左子节点的索引</span></div><div class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">        RunnableScheduledFuture&lt;?&gt; c = queue[child];</div><div class="line">        <span class="comment">// 右子节点的索引</span></div><div class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</div><div class="line">        <span class="comment">// 如果有右子节点并且左子节点的时间间隔大于右子节点，取时间间隔最小的节点</span></div><div class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="number">0</span>)</div><div class="line">            c = queue[child = right];</div><div class="line">        <span class="comment">// 如果key的时间间隔小于等于c的时间间隔，跳出循环</span></div><div class="line">        <span class="keyword">if</span> (key.compareTo(c) &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 设置要移除索引的节点为其子节点</span></div><div class="line">        queue[k] = c;</div><div class="line">        setIndex(c, k);</div><div class="line">        k = child;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将key放入索引为k的位置</span></div><div class="line">    queue[k] = key;</div><div class="line">    setIndex(key, k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>siftDown方法执行时包含两种情况，一种是没有子节点，一种是有子节点（根据half判断）。例如：</p>
<p><strong>没有子节点的情况：</strong></p>
<p>假设初始的堆如下：</p>
<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/QQ20170411-223120.png" alt="QQ20170411-223120.png" title="">
<p>假设 k = 3 ，那么 k = half ，没有子节点，在执行siftDown方法时直接把索引为3的节点设置为数组的最后一个节点：</p>
<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/siftdown-1.png" alt="siftdown-1.png" title="">
<p><strong>有子节点的情况：</strong></p>
<p>假设 k = 0 ，那么执行以下步骤：</p>
<ol>
<li>获取左子节点，child = 1 ，获取右子节点， right = 2 ：<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/siftdown-2.png" alt="siftdown-2.png" title=""></li>
<li>由于 <code>right &lt; size</code> ，这时比较左子节点和右子节点时间间隔的大小，这里 3 &lt; 7 ，所以 c = queue[child] ；</li>
<li>比较key的时间间隔是否小于c的时间间隔，这里不满足，继续执行，把索引为k的节点设置为c，然后将k设置为child，；<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/siftdown-3.png" alt="siftdown-3.png" title=""></li>
<li>因为 half = 3 ，k = 1 ，继续执行循环，这时的索引变为：<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/siftdown-4.png" alt="siftdown-4.png" title=""></li>
<li>这时再经过如上判断后，将k的值为3，最终的结果如下：<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/siftdown-6.png" alt="siftdown-6.png" title=""></li>
<li>最后，如果在finishPoll方法中调用的话，会把索引为0的节点的索引设置为-1，表示已经删除了该节点，并且size也减了1，最后的结果如下：<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/siftdown-6.png" alt="siftdown-6.png" title="">
</li>
</ol>
<p>可见，siftdown方法在执行完并不是有序的，但可以发现，子节点的下次执行时间一定比父节点的下次执行时间要大，由于每次都会取左子节点和右子节点中下次执行时间最小的节点，所以还是可以保证在take和poll时出队是有序的。</p>
<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object x)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = indexOf(x);</div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        setIndex(queue[i], -<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> s = --size;</div><div class="line">        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];</div><div class="line">        queue[s] = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (s != i) &#123;</div><div class="line">            <span class="comment">// 从i开始向下调整</span></div><div class="line">            siftDown(i, replacement);</div><div class="line">            <span class="comment">// 如果queue[i] == replacement，说明i是叶子节点</span></div><div class="line">            <span class="comment">// 如果是这种情况，不能保证子节点的下次执行时间比父节点的大</span></div><div class="line">            <span class="comment">// 这时需要进行一次向上调整</span></div><div class="line">            <span class="keyword">if</span> (queue[i] == replacement)</div><div class="line">                siftUp(i, replacement);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设初始的堆结构如下：</p>
<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/remove-1.png" alt="remove-1.png" title="">
<p>这时要删除8的节点，那么这时 k = 1，key为最后一个节点：</p>
<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/remove-2.png" alt="remove-2.png" title="">
<p>这时通过上文对siftDown方法的分析，siftDown方法执行后的结果如下：</p>
<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/remove-3.png" alt="remove-3.png" title="">
<p>这时会发现，最后一个节点的值比父节点还要小，所以这里要执行一次siftUp方法来保证子节点的下次执行时间要比父节点的大，所以最终结果如下：</p>
<img src="/2017/04/14/深入理解Java线程池：ScheduledThreadPoolExecutor/remove-4.png" alt="remove-4.png" title="">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细分析了ScheduedThreadPoolExecutor的实现，主要介绍了以下方面：</p>
<ul>
<li>与Timer执行定时任务的比较，相比Timer，ScheduedThreadPoolExecutor有什么优点；</li>
<li>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，所以它也是一个线程池，也有coorPoolSize和workQueue，ScheduledThreadPoolExecutor特殊的地方在于，自己实现了优先工作队列DelayedWorkQueue；</li>
<li>ScheduedThreadPoolExecutor实现了ScheduledExecutorService，所以就有了任务调度的方法，如schedule，scheduleAtFixedRate和scheduleWithFixedDelay，同时注意他们之间的区别；</li>
<li>内部类ScheduledFutureTask继承自FutureTask，实现了任务的异步执行并且可以获取返回结果。同时也实现了Delayed接口，可以通过getDelay方法获取将要执行的时间间隔；</li>
<li>周期任务的执行其实是调用了FutureTask类中的runAndReset方法，每次执行完不设置结果和状态。参考<a href="http://www.ideabuffer.cn/2017/04/06/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">FutureTask源码解析</a>；</li>
<li>详细分析了DelayedWorkQueue的数据结构，它是一个基于最小堆结构的优先队列，并且每次出队时能够保证取出的任务是当前队列中下次执行时间最小的任务。同时注意一下优先队列中堆的顺序，堆中的顺序并不是绝对的，但要保证子节点的值要比父节点的值要大，这样就不会影响出队的顺序。</li>
</ul>
<p>总体来说，ScheduedThreadPoolExecutor的重点是要理解下次执行时间的计算，以及优先队列的出队、入队和删除的过程，这两个是理解ScheduedThreadPoolExecutor的关键。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[FutureTask源码解析]]></title>
      <url>http://www.ideabuffer.cn/2017/04/06/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="FutureTask介绍"><a href="#FutureTask介绍" class="headerlink" title="FutureTask介绍"></a>FutureTask介绍</h2><p>FutureTask是一种可以取消的异步的计算任务。它的计算是通过Callable实现的，可以把它理解为是可以返回结果的Runnable。</p>
<p>使用FutureTask的优势有：</p>
<ol>
<li>可以获取线程执行后的返回结果；</li>
<li>提供了超时控制功能。</li>
</ol>
<p>它实现了Runnable接口和Future接口：</p>
<img src="/2017/04/06/FutureTask源码解析/QQ20170406-230647.png" alt="QQ20170406-230647.png" title="">
<p>什么是异步计算呢？也就是说，在让该任务执行时，不需要一直等待其运行结束返回结果，而是可以先去处理其他的事情，然后再获取返回结果。例如你想下载一个很大的文件，这时很耗时的操作，没必要一直等待着文件下载完，你可以先去吃个饭，然后再回来看下文件是否下载完成，如果下载完成就可以使用了，否则还需要继续等待。</p>
<a id="more"></a>
<h2 id="FutureTask的实现"><a href="#FutureTask的实现" class="headerlink" title="FutureTask的实现"></a>FutureTask的实现</h2><h3 id="FutureTask的状态"><a href="#FutureTask的状态" class="headerlink" title="FutureTask的状态"></a>FutureTask的状态</h3><p>FutureTask内部有这样几种状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</div></pre></td></tr></table></figure>
<p>看名字应该很好理解了，当创建一个FutureTask对象是，初始的状态是NEW，在运行时状态会转换，有4中状态的转换过程：</p>
<ul>
<li><strong>NEW -&gt; COMPLETING -&gt; NORMAL</strong>：正常执行并返回；</li>
<li><strong>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</strong>：执行过程中出现了异常；</li>
<li><strong>NEW -&gt; CANCELLED</strong>；执行前被取消；</li>
<li><strong>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</strong>：取消时被中断。</li>
</ul>
<h3 id="使用FutureTask"><a href="#使用FutureTask" class="headerlink" title="使用FutureTask"></a>使用FutureTask</h3><p>下面看一下具体的使用过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</div><div class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</div><div class="line">        FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                    result += i;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        executor.execute(future);</div><div class="line"></div><div class="line">        System.out.println(future.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="FutureTask内部结构"><a href="#FutureTask内部结构" class="headerlink" title="FutureTask内部结构"></a>FutureTask内部结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** The underlying callable; nulled out after running */</span></div><div class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</div><div class="line">    <span class="comment">/** The result to return or exception to throw from get() */</span></div><div class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></div><div class="line">    <span class="comment">/** 执行callable的线程 **/</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Treiber stack of waiting threads</div><div class="line">     * 使用Treiber算法实现的无阻塞的Stack，</div><div class="line">     * 用于存放等待的线程</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</div><div class="line">        <span class="keyword">volatile</span> Thread thread;</div><div class="line">        <span class="keyword">volatile</span> WaitNode next;</div><div class="line">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>这里的waiters理解为一个stack，因为在调用get方法时任务可能还没有执行完，这时需要将调用get方法的线程放入waiters中。</p>
<p>最重要的两个get方法，用于获取返回结果，第二种提供了超时控制功能。</p>
<h3 id="FutureTask构造方法"><a href="#FutureTask构造方法" class="headerlink" title="FutureTask构造方法"></a>FutureTask构造方法</h3><p>FutureTask有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.callable = callable;</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种构造方法传入一个Runnable对象和一个返回值对象，因为Runnable是没有返回值的，所以要通过result参数在执行完之后返回结果。</p>
<h3 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h3><p>FutureTask实现了Runnable接口，所以需要实现run方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 首先判断状态，如果不是初始状态，说明任务已经被执行或取消；</div><div class="line">     * runner是FutureTask的一个属性，用于保存执行任务的线程，</div><div class="line">     * 如果不为空则表示已经有线程正在执行，这里用CAS来设置，失败则返回。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (state != NEW ||</div><div class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</div><div class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        <span class="comment">// 只有初始状态才会执行</span></div><div class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            <span class="keyword">boolean</span> ran;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 执行任务</span></div><div class="line">                result = c.call();</div><div class="line">                <span class="comment">// 如果没出现异常，则说明执行成功了</span></div><div class="line">                ran = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                result = <span class="keyword">null</span>;</div><div class="line">                ran = <span class="keyword">false</span>;</div><div class="line">                <span class="comment">// 设置异常</span></div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果执行成功，则设置返回结果</span></div><div class="line">            <span class="keyword">if</span> (ran)</div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// runner must be non-null until state is settled to</span></div><div class="line">        <span class="comment">// prevent concurrent calls to run()</span></div><div class="line">        <span class="comment">// 无论是否执行成功，把runner设置为null</span></div><div class="line">        runner = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></div><div class="line">        <span class="comment">// leaked interrupts</span></div><div class="line">        <span class="keyword">int</span> s = state;</div><div class="line">        <span class="comment">// 如果被中断，则说明调用的cancel(true)，</span></div><div class="line">        <span class="comment">// 这里要保证在cancel方法中把state设置为INTERRUPTED</span></div><div class="line">        <span class="comment">// 否则可能在cancel方法中还没执行中断，造成中断的泄露</span></div><div class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</div><div class="line">            handlePossibleCancellationInterrupt(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下run方法的执行过程</p>
<ol>
<li>只有state为NEW的时候才执行任务；</li>
<li>执行前要设置runner为当前线程，使用CAS来设置是为了防止竞争；</li>
<li>如果任务执行成功，任务状态从NEW转换为COMPLETING，如果执行正常，设置最终状态为NORMAL；如果执行中出现了异常，设置最终状态为EXCEPTIONAL；</li>
<li>唤醒并删除Treiber Stack中的所有节点；</li>
<li>如果调用了cancel(true)方法进行了中断，要确保在run方法执行结束前的状态是INTERRUPTED。</li>
</ol>
<p>这里涉及到3个比较重要的方法：setException，set和handlePossibleCancellationInterrupt。</p>
<h3 id="setException方法"><a href="#setException方法" class="headerlink" title="setException方法"></a>setException方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</div><div class="line">        outcome = t;</div><div class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></div><div class="line">        finishCompletion();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在执行过程中（也就是调用call方法时）出现了异常，则要把状态先设置为COMPLETING，如果成功，设置<code>outcome = t</code>，outcome对象是Object类型的，用来保存异常或者返回结果对象，也就是说，在正常的执行过程中（没有异常，没有调用cancel方法），outcome保存着返回结果对象，会被返回，如果出现了异常或者中断，则不会返回并抛出异常，这个在介绍report方法时会讲到。</p>
<p>接着设置状态为EXCEPTIONAL，这也是最终的状态。</p>
<p>finishCompletion方法稍后再分析。</p>
<h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</div><div class="line">        outcome = v;</div><div class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></div><div class="line">        finishCompletion();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，与setException类似，只不过这里的outcome是返回结果对象，状态先设置为COMPLETING，然后再设置为MORMAL。</p>
<h3 id="handlePossibleCancellationInterrupt方法"><a href="#handlePossibleCancellationInterrupt方法" class="headerlink" title="handlePossibleCancellationInterrupt方法"></a>handlePossibleCancellationInterrupt方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">    <span class="comment">// It is possible for our interrupter to stall before getting a</span></div><div class="line">    <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></div><div class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</div><div class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</div><div class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></div><div class="line"></div><div class="line">    <span class="comment">// assert state == INTERRUPTED;</span></div><div class="line"></div><div class="line">    <span class="comment">// We want to clear any interrupt we may have received from</span></div><div class="line">    <span class="comment">// cancel(true).  However, it is permissible to use interrupts</span></div><div class="line">    <span class="comment">// as an independent mechanism for a task to communicate with</span></div><div class="line">    <span class="comment">// its caller, and there is no way to clear only the</span></div><div class="line">    <span class="comment">// cancellation interrupt.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Thread.interrupted();</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handlePossibleCancellationInterrupt方法要确保cancel(true)产生的中断发生在run或runAndReset方法执行的过程中。这里会循环的调用Thread.yield()来确保状态在cancel方法中被设置为INTERRUPTED。</p>
<p>这里不能够清除中断标记，因为不能确定中断一定来自于cancel方法。</p>
<h3 id="finishCompletion方法"><a href="#finishCompletion方法" class="headerlink" title="finishCompletion方法"></a>finishCompletion方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></div><div class="line">    <span class="comment">// 执行该方法时state必须大于COMPLETING</span></div><div class="line">    <span class="comment">// 逐个唤醒waiters中的线程</span></div><div class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</div><div class="line">        <span class="comment">// 设置栈顶节点为null</span></div><div class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                Thread t = q.thread;</div><div class="line">                <span class="comment">// 唤醒线程</span></div><div class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">                    q.thread = <span class="keyword">null</span>;</div><div class="line">                    LockSupport.unpark(t);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 如果next为空，说明栈空了，跳出循环</span></div><div class="line">                WaitNode next = q.next;</div><div class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="comment">// 方便gc回收</span></div><div class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></div><div class="line">                <span class="comment">// 重新设置栈顶node</span></div><div class="line">                q = next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 钩子方法</span></div><div class="line">    done();</div><div class="line"></div><div class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在调用get方法时，如果任务还没有执行结束，则会阻塞调用的线程，然后把调用的线程放入waiters中，这时，如果任务执行完毕，也就是调用了finishCompletion方法，waiters会依次出栈并逐个唤醒对应的线程。</p>
<p>由此可以想到，WaitNode一定是在get方法中被添加到栈中的，下面来看下get方法的实现。</p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">    <span class="keyword">int</span> s = state;</div><div class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</div><div class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    <span class="keyword">return</span> report(s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</div><div class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> s = state;</div><div class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</div><div class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">    <span class="keyword">return</span> report(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个方法类似，首先判断状态，如果<code>s &lt;= COMPLETING</code>，说明任务已经执行完毕，但set方法或setException方法还未执行结束（还未设置状态为NORMAL或EXCEPTIONAL），这时需要将当前线程添加到waiters中并阻塞。</p>
<p>第二种get提供了超时功能，如果在规定时间内任务还未执行完毕或者状态还是COMPLETING，则获取结果超时，抛出TimeoutException。而第一种get会一直阻塞直到<code>state &gt; COMPLETING</code>。</p>
<h3 id="awaitDone方法"><a href="#awaitDone方法" class="headerlink" title="awaitDone方法"></a>awaitDone方法</h3><p>awaitDone方法的工作是根据状态来判断是否能够返回结果，如果任务还未执行完毕，要添加到waiters中并阻塞，否则返回状态。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="comment">// 计算到期时间</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</div><div class="line">    WaitNode q = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="comment">// 如果被中断，删除节点，抛出异常</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">            removeWaiter(q);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> s = state;</div><div class="line">        <span class="comment">// 如果任务执行完毕并且设置了最终状态或者被取消，则返回</span></div><div class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</div><div class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</div><div class="line">                q.thread = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">return</span> s;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// s == COMPLETING时通过Thread.yield();让步其他线程执行，</span></div><div class="line">        <span class="comment">// 主要是为了让状态改变</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></div><div class="line">            Thread.yield();</div><div class="line">        <span class="comment">// 创建一个WaitNode</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</div><div class="line">            q = <span class="keyword">new</span> WaitNode();</div><div class="line">        <span class="comment">// CAS设置栈顶节点</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</div><div class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</div><div class="line">                                                 q.next = waiters, q);</div><div class="line">        <span class="comment">// 如果设置了超时，则计算是否已经到了开始设置的到期时间</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</div><div class="line">            nanos = deadline - System.nanoTime();</div><div class="line">            <span class="comment">// 如果已经到了到期时间，删除节点，返回状态</span></div><div class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</div><div class="line">                removeWaiter(q);</div><div class="line">                <span class="keyword">return</span> state;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 阻塞到到期时间</span></div><div class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果没有设置超时，会一直阻塞，直到被中断或者被唤醒</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="removeWaiter方法"><a href="#removeWaiter方法" class="headerlink" title="removeWaiter方法"></a>removeWaiter方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 将thread设置为null是因为下面要根据thread是否为null判断是否要把node移出</span></div><div class="line">        node.thread = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 这里自旋保证删除成功</span></div><div class="line">        retry:</div><div class="line">        <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></div><div class="line">            <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</div><div class="line">                s = q.next;</div><div class="line">                <span class="comment">// q.thread != null说明该q节点不需要移除</span></div><div class="line">                <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</div><div class="line">                    pred = q;</div><div class="line">                <span class="comment">// 如果q.thread == null，且pred != null，需要删除q节点</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// 删除q节点</span></div><div class="line">                    pred.next = s;</div><div class="line">                    <span class="comment">// pred.thread == null时说明在并发情况下被其他线程修改了；</span></div><div class="line">                    <span class="comment">// 返回第一个for循环重试</span></div><div class="line">                    <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></div><div class="line">                        <span class="keyword">continue</span> retry;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 如果q.thread != null且pred == null，说明q是栈顶节点</span></div><div class="line">                <span class="comment">// 设置栈顶元素为s节点，如果失败则返回重试</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</div><div class="line">                                                      q, s))</div><div class="line">                    <span class="keyword">continue</span> retry;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="cancel方法"><a href="#cancel方法" class="headerlink" title="cancel方法"></a>cancel方法</h3><p>cancel方法用于取消任务，这里可能有两种情况，一种是任务已经执行了，另一种是还未执行，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</div><div class="line">          UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</div><div class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></div><div class="line">        <span class="comment">// mayInterruptIfRunning参数表示是否要进行中断</span></div><div class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// runner保存着当前执行任务的线程</span></div><div class="line">                Thread t = runner;</div><div class="line">                <span class="comment">// 中断线程</span></div><div class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</div><div class="line">                    t.interrupt();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></div><div class="line">                <span class="comment">// 设置最终状态为INTERRUPTED</span></div><div class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        finishCompletion();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个if判断可能有些不好理解，其实等价于如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!state == NEW ||</div><div class="line">          !UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</div><div class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED))</div></pre></td></tr></table></figure>
<p>如果状态不是NEW，或者设置状态为INTERRUPTING或CANCELLED失败，则取消失败，返回false。</p>
<p>简单来说有一下两种情况：</p>
<ul>
<li>如果当前任务还没有执行，那么state == NEW，那么会尝试设置状态，如果设置状态失败会返回false，表示取消失败；</li>
<li>如果当前任务已经被执行了，那么state &gt; NEW，也就是!state == NEW为true，直接返回false。</li>
</ul>
<p>也就是说，如果任务一旦开始执行了（state != NEW），那么就不能被取消。</p>
<p>如果mayInterruptIfRunning为true，要中断当前执行任务的线程。</p>
<h3 id="report方法"><a href="#report方法" class="headerlink" title="report方法"></a>report方法</h3><p>get方法在调用awaitDone方法后，会调用report方法进行返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</div><div class="line">    Object x = outcome;</div><div class="line">    <span class="keyword">if</span> (s == NORMAL)</div><div class="line">        <span class="keyword">return</span> (V)x;</div><div class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，可以看到有3中执行情况：</p>
<ol>
<li>如果<code>s == NORMAL</code>为true，说明是正常执行结束，那么根据上述的分析，在正常执行结束时outcome存放的是返回结果，把outcome返回；</li>
<li>如果<code>s &gt;= CANCELLED</code>为true，说明是被取消了，抛出CancellationException；</li>
<li>如果<code>s &lt; CANCELLED</code>，那么状态只能是是EXCEPTIONAL，表示在执行过程中出现了异常，抛出ExecutionException。</li>
</ol>
<h3 id="runAndReset方法"><a href="#runAndReset方法" class="headerlink" title="runAndReset方法"></a>runAndReset方法</h3><p>该方法和run方法类似，区别在于这个方法不会设置任务的执行结果值，所以在正常执行时，不会修改state，除非发生了异常或者中断，最后返回是否正确的执行并复位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAndReset</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (state != NEW ||</div><div class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</div><div class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> s = state;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; s == NEW) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 不获取和设置返回值</span></div><div class="line">                c.call(); <span class="comment">// don't set result</span></div><div class="line">                ran = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// runner must be non-null until state is settled to</span></div><div class="line">        <span class="comment">// prevent concurrent calls to run()</span></div><div class="line">        runner = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></div><div class="line">        <span class="comment">// leaked interrupts</span></div><div class="line">        s = state;</div><div class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</div><div class="line">            handlePossibleCancellationInterrupt(s);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 是否正确的执行并复位</span></div><div class="line">    <span class="keyword">return</span> ran &amp;&amp; s == NEW;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了FutureTask的执行过程和获取返回值的过程，要注意以下几个地方：</p>
<ul>
<li>FutureTask是线程安全的，在多线程下任务也只会被执行一次；</li>
<li>注意在执行时各种状态的切换；</li>
<li>get方法调用时，如果任务没有结束，要阻塞当前线程，法阻塞的线程会保存在一个Treiber Stack中；</li>
<li>get方法超时功能如果超时未获取成功，会抛出TimeoutException；</li>
<li>注意在取消时的线程中断，在run方法中一定要保证结束时的状态是INTERRUPTED，否则在cancel方法中可能没有执行interrupt，造成中断的泄露。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java线程池：ThreadPoolExecutor]]></title>
      <url>http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/</url>
      <content type="html"><![CDATA[<h2 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h2><p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：</p>
<p><strong>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</strong></p>
<p>那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p>
<p>这就是线程池的目的了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</p>
<p><strong>什么时候使用线程池？</strong></p>
<ul>
<li>单个任务处理时间比较短 </li>
<li>需要处理的任务数量很大 </li>
</ul>
<p><strong>使用线程池的好处</strong> </p>
<p>引用自 <a href="http://ifeve.com/java-threadpool/" target="_blank" rel="external">http://ifeve.com/java-threadpool/</a> 的说明：</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>Java中的线程池是用ThreadPoolExecutor类来实现的. 本文就结合JDK 1.8对该类的源码来分析一下这个类内部对于线程的创建, 管理以及后台任务的调度等方面的执行原理。</p>
<p>先看一下线程池的类图：</p>
<img src="/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/QQ20170331-004227.png" alt="QQ20170331-004227.png" title="">
<a id="more"></a>
<h2 id="Executor框架接口"><a href="#Executor框架接口" class="headerlink" title="Executor框架接口"></a>Executor框架接口</h2><p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。</p>
<p>J.U.C中有三个Executor接口：</p>
<ul>
<li><strong>Executor</strong>：一个运行新任务的简单接口；</li>
<li><strong>ExecutorService</strong>：扩展了Executor接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；</li>
<li><strong>ScheduledExecutorService</strong>：扩展了ExecutorService。支持Future和定期执行任务。</li>
</ul>
<h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Executor接口只有一个execute方法，用来替代通常创建或启动线程的方法。例如，使用Thread来创建并启动线程的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread t = <span class="keyword">new</span> Thread();</div><div class="line">t.start();</div></pre></td></tr></table></figure>
<p>使用Executor来启动线程执行任务的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread t = <span class="keyword">new</span> Thread();</div><div class="line">executor.execute(t);</div></pre></td></tr></table></figure>
<p>对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接收传入的线程。</p>
<h3 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h3><p>ExecutorService接口继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。增加了shutDown()，shutDownNow()，invokeAll()，invokeAny()和submit()等方法。如果需要支持即时关闭，也就是shutDownNow()方法，则任务需要正确处理中断。</p>
<h3 id="ScheduledExecutorService接口"><a href="#ScheduledExecutorService接口" class="headerlink" title="ScheduledExecutorService接口"></a>ScheduledExecutorService接口</h3><p>ScheduledExecutorService扩展ExecutorService接口并增加了schedule方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。ScheduledExecutorService接口还定义了按照指定时间间隔定期执行任务的scheduleAtFixedRate()方法和scheduleWithFixedDelay()方法。</p>
<h2 id="ThreadPoolExecutor分析"><a href="#ThreadPoolExecutor分析" class="headerlink" title="ThreadPoolExecutor分析"></a>ThreadPoolExecutor分析</h2><p>ThreadPoolExecutor继承自AbstractExecutorService，也是实现了ExecutorService接口。</p>
<h3 id="几个重要的字段"><a href="#几个重要的字段" class="headerlink" title="几个重要的字段"></a>几个重要的字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// runState is stored in the high-order bits</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</div></pre></td></tr></table></figure>
<p><code>ctl</code>是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p>
<p>下面再介绍下线程池的运行状态. 线程池一共有五种状态, 分别是:</p>
<ol>
<li><strong>RUNNING </strong>：能接受新提交的任务，并且也能处理阻塞队列中的任务；</li>
<li><strong>SHUTDOWN</strong>：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；</li>
<li><strong>STOP</strong>：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；</li>
<li><strong>TIDYING</strong>：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。</li>
<li><strong>TERMINATED</strong>：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。<br>进入TERMINATED的条件如下：<ul>
<li>线程池不是RUNNING状态；</li>
<li>线程池状态不是TIDYING状态或TERMINATED状态；</li>
<li>如果线程池状态是SHUTDOWN并且workerQueue为空；</li>
<li>workerCount为0；</li>
<li>设置TIDYING状态成功。</li>
</ul>
</li>
</ol>
<p>下图为线程池的状态转换过程：</p>
<img src="/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/threadpool-status.png" alt="threadpool-status.png" title="">
<h3 id="ctl相关方法"><a href="#ctl相关方法" class="headerlink" title="ctl相关方法"></a>ctl相关方法</h3><p>这里还有几个对ctl进行计算的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>runStateOf</strong>：获取运行状态；</li>
<li><strong>workerCountOf</strong>：获取活动线程数；</li>
<li><strong>ctlOf</strong>：获取运行状态和活动线程数的值。</li>
</ul>
<h3 id="ThreadPoolExecutor构造方法"><a href="#ThreadPoolExecutor构造方法" class="headerlink" title="ThreadPoolExecutor构造方法"></a>ThreadPoolExecutor构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                          <span class="keyword">long</span> keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">    <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造方法中的字段含义如下：</p>
<ul>
<li><p><strong>corePoolSize</strong>：核心线程数量，当有新任务在execute()方法提交时，会执行以下判断：</p>
<ol>
<li>如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的； </li>
<li>如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；</li>
<li>如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；</li>
<li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；</li>
</ol>
<p>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</p>
</li>
<li><strong>maximumPoolSize</strong>：最大线程数量；</li>
<li><strong>workQueue</strong>：等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列；</li>
<li><strong>workQueue</strong>：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式: <ol>
<li><strong>直接切换</strong>：这种方式常用的队列是SynchronousQueue，但现在还没有研究过该队列，这里暂时还没法介绍；</li>
<li><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</li>
<li><strong>使用有界队列</strong>：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。<ul>
<li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li>
<li>如果提交的任务经常发生阻塞，那么可以考虑通过调用 setMaximumPoolSize() 方法来重新设定线程池的容量。</li>
<li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li>
</ul>
</li>
</ol>
</li>
<li><strong>keepAliveTime</strong>：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</li>
<li><strong>threadFactory</strong>：它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</li>
<li><strong>handler</strong>：它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：<ol>
<li>AbortPolicy：直接抛出异常，这是默认策略；</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>DiscardPolicy：直接丢弃任务；</li>
</ol>
</li>
</ul>
<h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><p>execute()方法用来提交任务，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * clt记录着runState和workerCount</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * workerCountOf方法取出低29位的值，表示当前活动的线程数；</div><div class="line">     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；</div><div class="line">     * 并把任务添加到该线程中。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</div><div class="line">         * 如果为true，根据corePoolSize来判断；</div><div class="line">         * 如果为false，则根据maximumPoolSize来判断</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 如果添加失败，则重新获取ctl值</div><div class="line">         */</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 如果当前线程池是运行状态并且任务添加到队列成功</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="comment">// 重新获取ctl值</span></div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="comment">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></div><div class="line">        <span class="comment">// 这时需要移除该command</span></div><div class="line">        <span class="comment">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</div><div class="line">         * 这里传入的参数表示：</div><div class="line">         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</div><div class="line">         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</div><div class="line">         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</div><div class="line">         */</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 如果执行到这里，有两种情况：</div><div class="line">     * 1. 线程池已经不是RUNNING状态；</div><div class="line">     * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。</div><div class="line">     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</div><div class="line">     * 如果失败则拒绝该任务</div><div class="line">     */</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单来说，在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：</p>
<ol>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>这里要注意一下<code>addWorker(null, false);</code>，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在<code>workerCountOf(recheck) == 0</code>时执行<code>addWorker(null, false);</code>也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。</p>
<p>execute方法执行流程如下：</p>
<img src="/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/executor.png" alt="executor.png" title="">
<h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">    retry:</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="comment">// 获取运行状态</span></div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line">        </div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 这个if判断</div><div class="line">         * 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</div><div class="line">         * 接着判断以下3个条件，只要有1个不满足，则返回false：</div><div class="line">         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</div><div class="line">         * 2. firsTask为空</div><div class="line">         * 3. 阻塞队列不为空</div><div class="line">         * </div><div class="line">         * 首先考虑rs == SHUTDOWN的情况</div><div class="line">         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</div><div class="line">         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，</div><div class="line">         * 因为队列中已经没有任务了，不需要再添加线程了</div><div class="line">         */</div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="comment">// 获取线程数</span></div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">            <span class="comment">// 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></div><div class="line">            <span class="comment">// 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，</span></div><div class="line">            <span class="comment">// 如果为false则根据maximumPoolSize来比较。</span></div><div class="line">            <span class="comment">// </span></div><div class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// 尝试增加workerCount，如果成功，则跳出第一个for循环</span></div><div class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                <span class="keyword">break</span> retry;</div><div class="line">            <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></div><div class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">            <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></div><div class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line">                <span class="keyword">continue</span> retry;</div><div class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</div><div class="line">    Worker w = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 根据firstTask来创建Worker对象</span></div><div class="line">        w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">        <span class="comment">// 每一个Worker对象都会创建一个线程</span></div><div class="line">        <span class="keyword">final</span> Thread t = w.thread;</div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// Recheck while holding lock.</span></div><div class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></div><div class="line">                <span class="comment">// shut down before lock acquired.</span></div><div class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line">                <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></div><div class="line">                <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></div><div class="line">                <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></div><div class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">                    <span class="comment">// workers是一个HashSet</span></div><div class="line">                    workers.add(w);</div><div class="line">                    <span class="keyword">int</span> s = workers.size();</div><div class="line">                    <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></div><div class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">                <span class="comment">// 启动线程</span></div><div class="line">                t.start();</div><div class="line">                workerStarted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (! workerStarted)</div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一下这里的<code>t.start()</code>这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</p>
<h3 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h3><p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，看一下Worker的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></div><div class="line">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">Runnable</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This class will never be serialized, but we provide a</div><div class="line">     * serialVersionUID to suppress a javac warning.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></div><div class="line">    <span class="keyword">final</span> Thread thread;</div><div class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></div><div class="line">    Runnable firstTask;</div><div class="line">    <span class="comment">/** Per-thread task counter */</span></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates with given first task and thread from ThreadFactory.</div><div class="line">     * <span class="doctag">@param</span> firstTask the first task (null if none)</div><div class="line">     */</div><div class="line">    Worker(Runnable firstTask) &#123;</div><div class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></div><div class="line">        <span class="keyword">this</span>.firstTask = firstTask;</div><div class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        runWorker(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Lock methods</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></div><div class="line">    <span class="comment">// The value 1 represents the locked state.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">        setState(<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t;</div><div class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                t.interrupt();</div><div class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p>
<p>在调用构造方法时，需要把任务传入，这里通过<code>getThreadFactory().newThread(this);</code>来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。</p>
<p>Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</li>
<li>如果正在执行任务，则不应该中断线程；</li>
<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li>
<li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</li>
<li>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</li>
</ol>
<p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。</p>
<p>此外，在构造方法中执行了<code>setState(-1);</code>，把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tryAcquire方法是根据state是否是0来判断的，所以，<code>setState(-1);</code>将state设置为-1是为了禁止在执行任务前对线程进行中断。</p>
<p>正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为0.</p>
<h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">    Thread wt = Thread.currentThread();</div><div class="line">    <span class="comment">// 获取第一个任务</span></div><div class="line">    Runnable task = w.firstTask;</div><div class="line">    w.firstTask = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 允许中断</span></div><div class="line">    w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line">    <span class="comment">// 是否因为异常退出循环</span></div><div class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 如果task为空，则通过getTask来获取任务</span></div><div class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">            w.lock();</div><div class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></div><div class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></div><div class="line">            <span class="comment">// requires a recheck in second case to deal with</span></div><div class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></div><div class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                 (Thread.interrupted() &amp;&amp;</div><div class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                !wt.isInterrupted())</div><div class="line">                wt.interrupt();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                beforeExecute(wt, task);</div><div class="line">                Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    task.run();</div><div class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                task = <span class="keyword">null</span>;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completedAbruptly = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里说明一下第一个if判断，目的是：</p>
<ul>
<li>如果线程池正在停止，那么要保证当前线程是中断状态；</li>
<li>如果不是的话，则要保证当前线程不是中断状态；</li>
</ul>
<p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：</p>
<blockquote>
<p>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。</p>
</blockquote>
<p>STOP状态要中断线程池中的所有线程，而这里使用<code>Thread.interrupted()</code>来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</p>
<p>总结一下runWorker方法的执行过程：</p>
<ol>
<li>while循环不断地通过getTask()方法获取任务；</li>
<li>getTask()方法从阻塞队列中取任务；</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</li>
<li>调用<code>task.run()</code>执行任务；</li>
<li>如果task为null则跳出循环，执行processWorkerExit()方法；</li>
<li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</li>
</ol>
<p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。</p>
<p>completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p>
<h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><p>getTask方法用来从阻塞队列中取任务，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span></div><div class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</div><div class="line">         * 1. rs &gt;= STOP，线程池是否正在stop；</div><div class="line">         * 2. 阻塞队列是否为空。</div><div class="line">         * 如果以上条件满足，则将workerCount减1并返回null。</div><div class="line">         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// Are workers subject to culling?</span></div><div class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></div><div class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></div><div class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></div><div class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></div><div class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line">        </div><div class="line">        <span class="comment">/*</span></div><div class="line">         * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</div><div class="line">         * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</div><div class="line">         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；</div><div class="line">         * 如果减1失败，则返回重试。</div><div class="line">         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</div><div class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</div><div class="line">             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</div><div class="line">             * </div><div class="line">             */</div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            <span class="comment">// 如果 r == null，说明已经超时，timedOut设置为true</span></div><div class="line">            timedOut = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">            <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></div><div class="line">            timedOut = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。</p>
<p>什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。</p>
<p>getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</p>
<h3 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；</span></div><div class="line">    <span class="comment">// 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。  </span></div><div class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></div><div class="line">        decrementWorkerCount();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//统计完成的任务数</span></div><div class="line">        completedTaskCount += w.completedTasks;</div><div class="line">        <span class="comment">// 从workers中移除，也就表示着从线程池中移除了一个工作线程</span></div><div class="line">        workers.remove(w);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据线程池状态进行判断是否结束线程池</span></div><div class="line">    tryTerminate();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；</div><div class="line">     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；</div><div class="line">     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</div><div class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</div><div class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</div><div class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</div><div class="line">                min = <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</div><div class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></div><div class="line">        &#125;</div><div class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：</p>
<img src="/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/threadpool-lifecycle.png" alt="threadpool-lifecycle.png" title="">
<h3 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h3><p>tryTerminate方法根据线程池状态进行判断是否结束线程池，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 当前线程池的状态为以下几种情况时，直接返回：</div><div class="line">         * 1. RUNNING，因为还在运行中，不能停止；</div><div class="line">         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；</div><div class="line">         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (isRunning(c) ||</div><div class="line">            runStateAtLeast(c, TIDYING) ||</div><div class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 如果线程数量不为0，则中断一个空闲的工作线程，并返回</span></div><div class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></div><div class="line">            interruptIdleWorkers(ONLY_ONE);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法</span></div><div class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// terminated方法默认什么都不做，留给子类实现</span></div><div class="line">                    terminated();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="comment">// 设置状态为TERMINATED</span></div><div class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</div><div class="line">                    termination.signalAll();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// else retry on failed CAS</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>interruptIdleWorkers(ONLY_ONE);</code>的作用是因为在getTask方法中执行<code>workQueue.take()</code>时，如果不执行中断会一直阻塞。在下面介绍的shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了getTask方法，这时如果workQueue中没有任务了，调用<code>workQueue.take()</code>时就会一直阻塞。所以每次在工作线程结束时调用tryTerminate方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况。</p>
<h3 id="shutdown方法"><a href="#shutdown方法" class="headerlink" title="shutdown方法"></a>shutdown方法</h3><p>shutdown方法要将线程池切换到SHUTDOWN状态，并调用interruptIdleWorkers方法请求中断所有空闲的worker，最后调用tryTerminate尝试结束线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 安全策略判断</span></div><div class="line">        checkShutdownAccess();</div><div class="line">        <span class="comment">// 切换状态为SHUTDOWN</span></div><div class="line">        advanceRunState(SHUTDOWN);</div><div class="line">        <span class="comment">// 中断空闲线程</span></div><div class="line">        interruptIdleWorkers();</div><div class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 尝试结束线程池</span></div><div class="line">    tryTerminate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里思考一个问题：在runWorker方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？</p>
<p>下面仔细分析一下：</p>
<ul>
<li>在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；</li>
<li>shutdown方法会调用interruptIdleWorkers来中断空闲的线程，interruptIdleWorkers持有mainLock，会遍历workers来逐个判断工作线程是否空闲。但getTask方法中没有mainLock；</li>
<li>在getTask中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用<code>workQueue.take()</code>进行阻塞；</li>
<li>如果在判断当前线程池状态是RUNNING后，这时调用了shutdown方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了<code>workQueue.take()</code>后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到workQueue中，这样一来线程池永远都关闭不了了；</li>
<li>由上可知，shutdown方法与getTask方法（从队列中获取任务时）存在竞态条件；</li>
<li>解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用<code>workQueue.take()</code>时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出InterruptedException，解除阻塞的状态；</li>
<li>但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；</li>
<li>所以Worker继承自AQS，在工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。</li>
</ul>
<p>下面就来分析一下interruptIdleWorkers方法。</p>
<h3 id="interruptIdleWorkers方法"><a href="#interruptIdleWorkers方法" class="headerlink" title="interruptIdleWorkers方法"></a>interruptIdleWorkers方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</div><div class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</div><div class="line">            Thread t = w.thread;</div><div class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    t.interrupt();</div><div class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (onlyOne)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>interruptIdleWorkers遍历workers中所有的工作线程，若线程没有被中断tryLock成功，就中断该线程。</p>
<p>为什么需要持有mainLock？因为workers是HashSet类型的，不能保证线程安全。</p>
<h3 id="shutdownNow方法"><a href="#shutdownNow方法" class="headerlink" title="shutdownNow方法"></a>shutdownNow方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Runnable&gt; tasks;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        checkShutdownAccess();</div><div class="line">        advanceRunState(STOP);</div><div class="line">        <span class="comment">// 中断所有工作线程，无论是否空闲</span></div><div class="line">        interruptWorkers();</div><div class="line">        <span class="comment">// 取出队列中没有被执行的任务</span></div><div class="line">        tasks = drainQueue();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    tryTerminate();</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>shutdownNow方法与shutdown方法类似，不同的地方在于：</p>
<ol>
<li>设置状态为STOP；</li>
<li>中断所有工作线程，无论是否是空闲的；</li>
<li>取出阻塞队列中没有被执行的任务并返回。</li>
</ol>
<p>shutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。</p>
<h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li><strong>getTaskCount</strong>：线程池已经执行的和未执行的任务总数；</li>
<li><strong>getCompletedTaskCount</strong>：线程池已完成的任务数量，该值小于等于taskCount；</li>
<li><strong>getLargestPoolSize</strong>：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li>
<li><strong>getPoolSize</strong>：线程池当前的线程数量；</li>
<li><strong>getActiveCount</strong>：当前线程池中正在执行任务的线程数量。</li>
</ul>
<p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文比较详细的分析了线程池的工作流程，总体来说有如下几个内容：</p>
<ul>
<li>分析了线程的创建，任务的提交，状态的转换以及线程池的关闭；</li>
<li>这里通过execute方法来展开线程池的工作流程，execute方法通过corePoolSize，maximumPoolSize以及阻塞队列的大小来判断决定传入的任务应该被立即执行，还是应该添加到阻塞队列中，还是应该拒绝任务。</li>
<li>介绍了线程池关闭时的过程，也分析了shutdown方法与getTask方法存在竞态条件；</li>
<li>在获取任务时，要通过线程池的状态来判断应该结束工作线程还是阻塞线程等待新的任务，也解释了为什么关闭线程池时要中断工作线程以及为什么每一个worker都需要lock。</li>
</ul>
<p>在向线程池提交任务时，除了execute方法，还有一个submit方法，submit方法会返回一个Future对象用于获取返回值，有关Future和Callable请自行了解一下相关的文章，这里就不介绍了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解AbstractQueuedSynchronizer（三）]]></title>
      <url>http://www.ideabuffer.cn/2017/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>前两篇文章中分析了AQS的独占功能和共享功能，AQS中还实现了Condition的功能。本文将通过ReentrantLock来分析在AQS中Condition的实现。</p>
<h2 id="Condition介绍"><a href="#Condition介绍" class="headerlink" title="Condition介绍"></a>Condition介绍</h2><p>Condition是在JDK1.5中才出现的，它可以替代传统的Object中的wait()、notify()和notifyAll()方法来实现线程间的通信，使线程间协作更加安全和高效。</p>
<p>Condition是一个接口，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>常用的方法是await()、signal()和signalAll()，Condition与Object类中的方法对应如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Object</th>
<th style="text-align:center">Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">wait()</td>
<td style="text-align:center">await()</td>
</tr>
<tr>
<td style="text-align:center">notify()</td>
<td style="text-align:center">signal()</td>
</tr>
<tr>
<td style="text-align:center">notifyAll()</td>
<td style="text-align:center">signalAll()</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>既然功能都一样，问什么还需要使用Condition呢？简单来说，Condition需要和Lock一起使用，在不使用Lock时，使用关键字<code>synchronized</code>时的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(obj)&#123; </div><div class="line">    obj.wait();</div><div class="line">&#125;</div><div class="line"><span class="keyword">synchronized</span>(obj)&#123; </div><div class="line">    obj.notify();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用Lock时的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lock.lock(); </div><div class="line">condition.await(); </div><div class="line">lock.unlock();</div><div class="line"></div><div class="line">lock.lock(); </div><div class="line">condition.signal(); </div><div class="line">lock.unlock();</div></pre></td></tr></table></figure>
<p>从代码上可以看出，使用<code>synchronized</code>关键字时，所有没有获取锁的线程都会等待，这时相当于只有1个等待队列；而在实际应用中可能有时需要多个等待队列，比如ReadLock和WriteLock。Lock中的等待队列和Condition中的等待队列是分开的，例如在独占模式下，Lock的独占保证了在同一时刻只会有一个线程访问临界区，也就是lock()方法返回后，Condition中的等待队列保存着被阻塞的线程，也就是调用await()方法后阻塞的线程。所以使用lock比使用<code>synchronized</code>关键字更加灵活。</p>
<h2 id="Condition的使用"><a href="#Condition的使用" class="headerlink" title="Condition的使用"></a>Condition的使用</h2><p>在Condition接口的javadoc中，有一个很好的例子来使用Condition，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </div><div class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </div><div class="line">     </div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</div><div class="line">    <span class="keyword">int</span> putptr, takeptr, count;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (count == items.length)</div><div class="line">                notFull.await();</div><div class="line">            items[putptr] = x;</div><div class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</div><div class="line">            ++count;</div><div class="line">            notEmpty.signal();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">                notEmpty.await();</div><div class="line">            Object x = items[takeptr];</div><div class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</div><div class="line">            --count;</div><div class="line">            notFull.signal();</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，定义了一个数组items，put用于向items中添加数据，take用于从items中取出数据，count代表当前items中存放了多少个对象，putptr表示下一个需要添加的索引，takeptr表示下一个需要取出的索引，这样就实现了数组的循环添加和取出数据的功能。put和take的具体功能如下：</p>
<ul>
<li><p><strong>put</strong></p>
<ol>
<li>当count与items的长度相同时，表示数组已满，则调用<code>notFull.await()</code>来等待同时释放了当前线程的锁；</li>
<li>当线程被唤醒时，将x添加到putptr索引的位置；</li>
<li>如果当前putptr的位置是最后一个，则下一个索引的位置从0开始；</li>
<li>调用<code>notEmpty.signal();</code>通知其他线程可以从数组中取出数据了。</li>
</ol>
</li>
<li><p><strong>take</strong></p>
<ol>
<li>当count为0时，表示数组是空的，则调用<code>notEmpty.await()</code>来等待同时释放了当前线程的锁；</li>
<li>当线程被唤醒时，将x添加到takeptr索引的位置；</li>
<li>如果当前takeptr的位置是最后一个，则下一个索引的位置从0开始；</li>
<li>调用<code>notFull.signal();</code>通知其他线程可以向数组中添加数据了。</li>
</ol>
</li>
</ul>
<h2 id="AQS中Condition的实现"><a href="#AQS中Condition的实现" class="headerlink" title="AQS中Condition的实现"></a>AQS中Condition的实现</h2><p>本文还是通过ReentrantLock来分析。</p>
<p>Condition必须被绑定到一个独占锁上使用，在ReentrantLock中，有一个newCondition方法，该方法调用了Sync中的newCondition方法，看下Sync中newCondition的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConditionObject是在AQS中定义的，它实现了Condition接口，自然也就实现了上述的Condition接口中的方法。该类有两个重要的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** First node of condition queue. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</div><div class="line"><span class="comment">/** Last node of condition queue. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</div></pre></td></tr></table></figure>
<p>这里的firstWaiter和lastWaiter是不是和之前说过的head和tail有些类似，而且都是Node类型的。对于Condition来说，它是不与独占模式或共享模式使用相同的队列的，它有自己的队列，所以这两个变量表示了队列的头节点和尾节点。</p>
<h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="comment">// 根据当前线程创建一个Node添加到Condition队列中</span></div><div class="line">    Node node = addConditionWaiter();</div><div class="line">    <span class="comment">// 释放当前线程的lock，从AQS的队列中移出</span></div><div class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</div><div class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 循环判断当前线程的Node是否在Sync队列中，如果不在，则park</span></div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">        LockSupport.park(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">// checkInterruptWhileWaiting方法根据中断发生的时机返回后续需要处理这次中断的方式，如果发生中断，退出循环</span></div><div class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// acquireQueued获取锁并返回线程是否中断</span></div><div class="line">    <span class="comment">// 如果线程被中断，并且中断的方式不是抛出异常，则设置中断后续的处理方式设置为REINTERRUPT</span></div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">        interruptMode = REINTERRUPT;</div><div class="line">    <span class="comment">// 从头到尾遍历Condition队列，移除被cancel的节点</span></div><div class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></div><div class="line">        unlinkCancelledWaiters();</div><div class="line">    <span class="comment">// 如果线程已经被中断，则根据之前获取的interruptMode的值来判断是继续中断还是抛出异常</span></div><div class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</div><div class="line">        reportInterruptAfterWait(interruptMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>await方法首先根据当前线程创建了一个Node，然后释放当前线程的独占锁。这里的savedState表示当前线程已经加锁的次数（ReentrantLock为重入锁）。while循环其实就是一直判断，当前的线程是否又被添加到了Sync队列中，如果已经在Sync队列中，则退出循环。</p>
<p>什么时候会把当前线程又加入到Sync队列中呢？当然是调用signal方法的时候，因为这里需要唤醒之前调用await方法的线程。</p>
<p>这里还需要注意的是，如果在park的状态下，这时线程中断了，park方法会返回，然后判断后续对此次中断的处理方式：抛出InterruptedException或者继续中断。</p>
<h3 id="addConditionWaiter方法"><a href="#addConditionWaiter方法" class="headerlink" title="addConditionWaiter方法"></a>addConditionWaiter方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node t = lastWaiter;</div><div class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></div><div class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</div><div class="line">        unlinkCancelledWaiters();</div><div class="line">        t = lastWaiter;</div><div class="line">    &#125;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">        firstWaiter = node;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        t.nextWaiter = node;</div><div class="line">    lastWaiter = node;</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法将根据当前线程创建一个Node并添加到Condition队列中。如果尾节点被取消，调用unlinkCancelledWaiters方法删除Condition队列中被cancel的节点。然后将lastWaiter的nextWaiter设置为node，并将node设置为lastWaiter。</p>
<h3 id="fullyRelease方法"><a href="#fullyRelease方法" class="headerlink" title="fullyRelease方法"></a>fullyRelease方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> savedState = getState();</div><div class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</div><div class="line">            failed = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> savedState;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            node.waitStatus = Node.CANCELLED;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前介绍过ReentrantLock的release方法，该方法在unlock方法中被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在unlock时传入的参数是1，因为是可重入的原因，只有在state为0的时候才会真的释放锁，所以在fullyRelease方法中，需要将之前加入的锁的次数全部释放，目的是将该线程从Sync队列中移出。</p>
<h3 id="isOnSyncQueue方法"><a href="#isOnSyncQueue方法" class="headerlink" title="isOnSyncQueue方法"></a>isOnSyncQueue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * node.prev can be non-null, but not yet on queue because</div><div class="line">     * the CAS to place it on queue can fail. So we have to</div><div class="line">     * traverse from tail to make sure it actually made it.  It</div><div class="line">     * will always be near the tail in calls to this method, and</div><div class="line">     * unless the CAS failed (which is unlikely), it will be</div><div class="line">     * there, so we hardly ever traverse much.</div><div class="line">     */</div><div class="line">    <span class="keyword">return</span> findNodeFromTail(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法判断当前线程的node是否在Sync队列中。</p>
<ol>
<li>如果当前线程node的状态是CONDITION或者node.prev为null时说明已经在Condition队列中了，所以返回false；</li>
<li>如果node.next不为null，说明在Sync队列中，返回true；</li>
<li>如果两个if都未返回时，可以断定node的prev一定不为null，next一定为null，这个时候可以认为node正处于放入Sync队列的执行CAS操作执行过程中。而这个CAS操作有可能失败，所以通过findNodeFromTail再尝试一次判断。</li>
</ol>
<h3 id="findNodeFromTail方法"><a href="#findNodeFromTail方法" class="headerlink" title="findNodeFromTail方法"></a>findNodeFromTail方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    Node t = tail;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">if</span> (t == node)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        t = t.prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法就是从Sync队列尾部开始判断，因为在isOnSyncQueue方法调用该方法时，node.prev一定不为null。但这时的node可能还没有完全添加到Sync队列中（因为node.next是null），这时可能是在自旋中。记得之前说过的enq方法吗，signal的时候会调用这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node t = tail;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev = t;</div><div class="line">            <span class="comment">// 执行findNodeFromTail方法时可能一直在此自旋</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                <span class="keyword">return</span> t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，这时如果CAS还未成功，那只好返回false了，</p>
<h3 id="checkInterruptWhileWaiting方法"><a href="#checkInterruptWhileWaiting方法" class="headerlink" title="checkInterruptWhileWaiting方法"></a>checkInterruptWhileWaiting方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Thread.interrupted() ?</div><div class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</div><div class="line">        <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前线程被中断，则调用transferAfterCancelledWait方法判断后续的处理应该是抛出InterruptedException还是重新中断。</p>
<h3 id="transferAfterCancelledWait方法"><a href="#transferAfterCancelledWait方法" class="headerlink" title="transferAfterCancelledWait方法"></a>transferAfterCancelledWait方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</div><div class="line">        enq(node);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If we lost out to a signal(), then we can't proceed</div><div class="line">     * until it finishes its enq().  Cancelling during an</div><div class="line">     * incomplete transfer is both rare and transient, so just</div><div class="line">     * spin.</div><div class="line">     */</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</div><div class="line">        Thread.yield();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法是判断，在线程中断的时候，是否这时有signal方法的调用。</p>
<ol>
<li>如果<code>compareAndSetWaitStatus(node, Node.CONDITION, 0)</code>执行成功，则说明中断发生时，没有signal的调用，因为signal方法会将状态设置为0；</li>
<li>如果第1步执行成功，则将node添加到Sync队列中，并返回true，表示中断在signal之前；</li>
<li>如果第1步失败，则检查当前线程的node是否已经在Sync队列中了，如果不在Sync队列中，则让步给其他线程执行，直到当前的node已经被signal方法添加到Sync队列中；</li>
<li>返回false。</li>
</ol>
<p>这里需要注意的地方是，如果第一次CAS失败了，则不能判断当前线程是先进行了中断还是先进行了signal方法的调用，可能是先执行了signal然后中断，也可能是先执行了中断，后执行了signal，当然，这两个操作肯定是发生在CAS之前。这时需要做的就是等待当前线程的node被添加到Sync队列后，也就是enq方法返回后，返回false告诉checkInterruptWhileWaiting方法返回REINTERRUPT，后续进行重新中断。</p>
<p>简单来说，该方法的返回值代表当前线程是否在park的时候被中断唤醒，如果为true表示中断在signal调用之前，signal还未执行，否则表示signal已经执行过了。</p>
<p>根据await的语义，在await时遇到中断要抛出InterruptedException，返回true则使上层方法checkInterruptWhileWaiting返回THROW_IE，否则返回REINTERRUPT。</p>
<h3 id="unlinkCancelledWaiters方法"><a href="#unlinkCancelledWaiters方法" class="headerlink" title="unlinkCancelledWaiters方法"></a>unlinkCancelledWaiters方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node t = firstWaiter;</div><div class="line">    Node trail = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">        Node next = t.nextWaiter;</div><div class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</div><div class="line">            t.nextWaiter = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</div><div class="line">                firstWaiter = next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                trail.nextWaiter = next;</div><div class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</div><div class="line">                lastWaiter = trail;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            trail = t;</div><div class="line">        t = next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法就是从头到尾遍历Condition队列，移除状态为非CONDITION的节点。因为在执行该方法时已经获取了独占锁，所以不需考虑多线程问题。</p>
<h3 id="reportInterruptAfterWait方法"><a href="#reportInterruptAfterWait方法" class="headerlink" title="reportInterruptAfterWait方法"></a>reportInterruptAfterWait方法</h3><p>如果当前线程被中断，则在await方法中调用reportInterruptAfterWait方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法根据interruptMode来确定是应该抛出InterruptedException还是继续中断。</p>
<h3 id="awaitNanos方法"><a href="#awaitNanos方法" class="headerlink" title="awaitNanos方法"></a>awaitNanos方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">                <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    Node node = addConditionWaiter();</div><div class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</div><div class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</div><div class="line">            transferAfterCancelledWait(node);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</div><div class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        nanosTimeout = deadline - System.nanoTime();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">        interruptMode = REINTERRUPT;</div><div class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</div><div class="line">        unlinkCancelledWaiters();</div><div class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</div><div class="line">        reportInterruptAfterWait(interruptMode);</div><div class="line">    <span class="keyword">return</span> deadline - System.nanoTime();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法进行超时控制，功能与await类似，不同在于该方法中每次park是有时间限制的，对于spinForTimeoutThreshold在<a href="http://www.ideabuffer.cn/2017/03/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer%EF%BC%88%E4%BA%8C%EF%BC%89/">深入理解AbstractQueuedSynchronizer（二）</a>中的<strong>超时控制的await方法</strong>方法已经说明。</p>
<h3 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    Node first = firstWaiter;</div><div class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">        doSignal(first);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该方法中判断当前线程是否占有独占锁，然后通过firstWaiter依次唤醒Condition队列中的node，并把node添加到Sync队列中。</p>
<p>在await方法中可以知道添加到Condition队列中的node每次都是添加到队列的尾部，在signal方法中是从头开始唤醒的，所以Condition是公平的，signal是按顺序来进行唤醒的。</p>
<h3 id="doSignal方法"><a href="#doSignal方法" class="headerlink" title="doSignal方法"></a>doSignal方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</div><div class="line">            lastWaiter = <span class="keyword">null</span>;</div><div class="line">        first.nextWaiter = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</div><div class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>doSignal方法先将队列前面节点依次从队列中取出，然后调用transferForSignal方法去唤醒节点，这个方法有可能失败，因为等待线程可能已经到时或者被中断，因此while循环这个操作直到成功唤醒或队列为空。</p>
<h3 id="transferForSignal方法"><a href="#transferForSignal方法" class="headerlink" title="transferForSignal方法"></a>transferForSignal方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If cannot change waitStatus, the node has been cancelled.</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Splice onto queue and try to set waitStatus of predecessor to</div><div class="line">     * indicate that thread is (probably) waiting. If cancelled or</div><div class="line">     * attempt to set waitStatus fails, wake up to resync (in which</div><div class="line">     * case the waitStatus can be transiently and harmlessly wrong).</div><div class="line">     */</div><div class="line">    Node p = enq(node);</div><div class="line">    <span class="keyword">int</span> ws = p.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class="line">        LockSupport.unpark(node.thread);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法首先尝试设置node的状态为0：</p>
<ul>
<li>如果设置失败，说明已经被取消，没必要再进入Sync队列了，doSignal中的循环会找到一个node再次执行；</li>
<li>如果设置成功，但之后又被取消了呢？无所谓，虽然会进入到Sync队列，但在获取锁的时候会调用shouldParkAfterFailedAcquire方法，该方法中会移除此节点。</li>
</ul>
<p>如果执行成功，则将node加入到Sync队列中，enq会返回node的前继节点p。这里的if判断只有在p节点是取消状态或者设置p节点的状态为SIGNAL失败的时候才会执行unpark。</p>
<p>什么时候compareAndSetWaitStatus(p, ws, Node.SIGNAL)会执行失败呢？如果p节点的线程在这时执行了unlock方法，就会调用unparkSuccessor方法，unparkSuccessor方法可能就将p的状态改为了0，那么执行就会失败。</p>
<p>到这里，signal方法已经完成了所有的工作，唤醒的线程已经成功加入Sync队列并已经参与锁的竞争了，返回true。</p>
<h3 id="signalAll方法"><a href="#signalAll方法" class="headerlink" title="signalAll方法"></a>signalAll方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isHeldExclusively())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    Node first = firstWaiter;</div><div class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</div><div class="line">        doSignalAll(first);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是判断当前线程是否占有独占锁，然后执行doSignalAll方法。</p>
<h3 id="doSignalAll方法"><a href="#doSignalAll方法" class="headerlink" title="doSignalAll方法"></a>doSignalAll方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</div><div class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        Node next = first.nextWaiter;</div><div class="line">        first.nextWaiter = <span class="keyword">null</span>;</div><div class="line">        transferForSignal(first);</div><div class="line">        first = next;</div><div class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以与doSignal方法比较一下，doSignal方法只是唤醒了一个node并加入到Sync队列中，而doSignalAll方法唤醒了所有的Condition节点，并加入到Sync队列中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ConditionObject是AQS的内部类，它实现了Condition接口，提供了类似wait、notify和notifyAll类似的功能。</p>
<p>Condition必须与一个独占锁绑定使用，在await或signal之前必须现持有独占锁。Condition队列是一个单向链表，他是公平的，按照先进先出的顺序从队列中被唤醒并添加到Sync队列中，这时便恢复了参与竞争锁的资格。</p>
<p>Condition队列与Sync队列是不同的，Condition队列是单向的，队列的第一个节点firstWaiter中是可以绑定线程的；而Sync队列是双向的，队列的第一个节点head是不与线程进行绑定的。</p>
<p>Condition在设计时就充分考虑了Object中的监视器方法的缺陷，设计为一个lock可以对应多个Condition，从而可以使线程分散到多个等待队列中，使得应用更为灵活，并且在实现上使用了FIFO队列来保存等待线程，确保了可以做到使用signal按FIFO方式唤醒等待线程，避免每次唤醒所有线程导致数据竞争。</p>
<p>但这样也会导致Condition在使用上要比Object中的提供的监视器方法更为复杂，这时考虑使用Condition的数量、何时使用Condition以及使用哪个condition等等。由于Condition是结合Lock一起使用的，所以是否使用Condition需要和Lock一起进行综合的考虑。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解AbstractQueuedSynchronizer（二）]]></title>
      <url>http://www.ideabuffer.cn/2017/03/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在上篇文章<a href="http://www.ideabuffer.cn/2017/03/15/深入理解AbstractQueuedSynchronizer（一）/">深入理解AbstractQueuedSynchronizer（一）</a>中，通过ReentrantLock详细介绍了AQS独占模式的实现，本文通过工具类CountDownLatch来分析一下共享功能的实现。</p>
<h2 id="CountDownLatch是什么"><a href="#CountDownLatch是什么" class="headerlink" title="CountDownLatch是什么"></a>CountDownLatch是什么</h2><p>CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p>
<p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>
<p>执行过程如下图所示：</p>
<img src="/2017/03/19/深入理解AbstractQueuedSynchronizer（二）/f65cc83b7b4664916fad5d1398a36005.png" alt="f65cc83b7b4664916fad5d1398a36005.png" title="">
<p><em>参考自：<a href="http://www.importnew.com/15731.html" target="_blank" rel="external">http://www.importnew.com/15731.html</a></em></p>
<a id="more"></a>
<h2 id="CountDownLatch的使用"><a href="#CountDownLatch的使用" class="headerlink" title="CountDownLatch的使用"></a>CountDownLatch的使用</h2><p>下面通过一个例子来说明一下CountDownLatch的使用，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownTest</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"in "</span> + Thread.currentThread().getName() + <span class="string">"..."</span>);</div><div class="line">        System.out.println(<span class="string">"before latch.await()..."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="string">"T"</span> + i) &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    System.out.println(<span class="string">"enter Thread "</span> + getName() + <span class="string">"..."</span>);</div><div class="line">                    System.out.println(<span class="string">"execute countdown..."</span>);</div><div class="line">                    latch.countDown();</div><div class="line">                    System.out.println(<span class="string">"exit Thread"</span> + getName() + <span class="string">"."</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        latch.await();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"in "</span> + Thread.currentThread().getName() + <span class="string">"..."</span>);</div><div class="line">        System.out.println(<span class="string">"after latch.await()..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建了一个初始值为3的CountDownLatch对象latch，然后创建了3个线程，每个线程执行时都会执行<code>latch.countDown()</code>使计数器的值减1，而主线程在执行到<code>latch.await()</code>时会等待直到计数器的值为0。输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">in main...</div><div class="line">before latch.await()...</div><div class="line">enter Thread T1...</div><div class="line">enter Thread T2...</div><div class="line">execute countdown...</div><div class="line">execute countdown...</div><div class="line">enter Thread T3...</div><div class="line">execute countdown...</div><div class="line">exit ThreadT2.</div><div class="line">exit ThreadT1.</div><div class="line">exit ThreadT3.</div><div class="line">in main...</div><div class="line">after latch.await()...</div></pre></td></tr></table></figure>
<h2 id="AQS共享模式的实现"><a href="#AQS共享模式的实现" class="headerlink" title="AQS共享模式的实现"></a>AQS共享模式的实现</h2><h3 id="CountDownLatch构造方法"><a href="#CountDownLatch构造方法" class="headerlink" title="CountDownLatch构造方法"></a>CountDownLatch构造方法</h3><p>CountDownLatch的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传入一个参数count，CountDownLatch也使用了内部类Sync来实现，Sync继承自AQS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</div><div class="line"></div><div class="line">    Sync(<span class="keyword">int</span> count) &#123;</div><div class="line">        setState(count);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getState();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> c = getState();</div><div class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里调用了AQS类中的setState方法来设置count，AQS的state属性在上篇文章已经提到，它是AQS中的状态标识，具体的含义由子类来定义，可见这里把state定义为数量。</p>
<h3 id="CountDownLatch的await方法"><a href="#CountDownLatch的await方法" class="headerlink" title="CountDownLatch的await方法"></a>CountDownLatch的await方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接调用了AQS类中的acquireSharedInterruptibly方法。</p>
<h3 id="acquireSharedInterruptibly方法"><a href="#acquireSharedInterruptibly方法" class="headerlink" title="acquireSharedInterruptibly方法"></a>acquireSharedInterruptibly方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="comment">// 如果线程被中断则抛出异常</span></div><div class="line">    <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">    <span class="comment">// 尝试获取共享锁，该方法在Sync类中实现</span></div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">        <span class="comment">// 如果获取失败，需要根据当前线程创建一个mode为SHARE的的Node放入队列中并循环获取</span></div><div class="line">        doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的tryAcquireShared方法在Sync中被重写。</p>
<h3 id="CountDownLatch的tryAcquireShared方法"><a href="#CountDownLatch的tryAcquireShared方法" class="headerlink" title="CountDownLatch的tryAcquireShared方法"></a>CountDownLatch的tryAcquireShared方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仅仅是根据状态来判断，如果state等于0的时候，说明计数器为0了，返回1表示成功，否则返回-1表示失败。</p>
<h3 id="doAcquireSharedInterruptibly方法"><a href="#doAcquireSharedInterruptibly方法" class="headerlink" title="doAcquireSharedInterruptibly方法"></a>doAcquireSharedInterruptibly方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="comment">// 创建一个共享模式的节点</span></div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                <span class="comment">// 如果 p == head 表示是队列的第一个节点，尝试获取</span></div><div class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 设置当前节点为head，并向后面的节点传播</span></div><div class="line">                    setHeadAndPropagate(node, r);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的重点是setHeadAndPropagate方法。</p>
<h3 id="setHeadAndPropagate方法"><a href="#setHeadAndPropagate方法" class="headerlink" title="setHeadAndPropagate方法"></a>setHeadAndPropagate方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</div><div class="line">    Node h = head; <span class="comment">// Record old head for check below</span></div><div class="line">    setHead(node);</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Try to signal next queued node if:</div><div class="line">     *   Propagation was indicated by caller,</div><div class="line">     *     or was recorded (as h.waitStatus either before</div><div class="line">     *     or after setHead) by a previous operation</div><div class="line">     *     (note: this uses sign-check of waitStatus because</div><div class="line">     *      PROPAGATE status may transition to SIGNAL.)</div><div class="line">     * and</div><div class="line">     *   The next node is waiting in shared mode,</div><div class="line">     *     or we don't know, because it appears null</div><div class="line">     *</div><div class="line">     * The conservatism in both of these checks may cause</div><div class="line">     * unnecessary wake-ups, but only when there are multiple</div><div class="line">     * racing acquires/releases, so most need signals now or soon</div><div class="line">     * anyway.</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</div><div class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</div><div class="line">        Node s = node.next;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</div><div class="line">            doReleaseShared();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先先将之前的head记录一下，用于下面的判断；然后设置当前节点为头节点；最后在判断是否需要唤醒。这里的propagate值是根据tryAcquireShared方法的返回值传入的，所以对于CountDownLatch来说，如果获取成功，则应该是1。</p>
<p>这里的if判断条件比较多，这里用了之前保存的head节点变量h来进行判断，让我疑惑的地方是，什么时候h会等于null？这个地方目前还没想明白。</p>
<p>如果<code>h.waitStatus &gt;= 0</code>，表示是初始状态或者是取消状态，那么当<code>propagate &lt;= 0</code>时将不唤醒节点。</p>
<p>获取node的下一个节点s，如果<code>s == null || s.isShared()</code>则释放节点并唤醒。为什么下一个节点为null的时候也需要唤醒操作呢？仔细理解一下这句话：</p>
<blockquote>
<p>The conservatism in both of these checks may cause unnecessary wake-ups, but only when there are multiple racing acquires/releases, so most need signals now or soon anyway.</p>
</blockquote>
<p>这种保守的检查方式可能会引起多次不必要的线程唤醒操作，但这些情况仅存在于多线程并发的acquires/releases操作，所以大多线程数需要立即或者很快地一个信号。这个信号就是执行unpark方法。因为LockSupport在unpark的时候，相当于给了一个信号，即使这时候没有线程在park状态，之后有线程执行park的时候也会读到这个信号就不会被挂起。</p>
<p>在简单点说，就是线程在执行时，如果之前没有unpark操作，在执行park时会阻塞该线程；但如果在park之前执行过一次或多次unpark（unpark调用多次和一次是一样的，结果不会累加）这时执行park时并不会阻塞该线程。</p>
<p>所以，如果在唤醒node的时候下一个节点刚好添加到队列中，就可能避免了一次阻塞的操作。</p>
<p>所以这里的propagate表示传播，传播的过程就是只要成功的获取到共享所就唤醒下一个节点。</p>
<h3 id="doReleaseShared方法"><a href="#doReleaseShared方法" class="headerlink" title="doReleaseShared方法"></a>doReleaseShared方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Ensure that a release propagates, even if there are other</div><div class="line">     * in-progress acquires/releases.  This proceeds in the usual</div><div class="line">     * way of trying to unparkSuccessor of head if it needs</div><div class="line">     * signal. But if it does not, status is set to PROPAGATE to</div><div class="line">     * ensure that upon release, propagation continues.</div><div class="line">     * Additionally, we must loop in case a new node is added</div><div class="line">     * while we are doing this. Also, unlike other uses of</div><div class="line">     * unparkSuccessor, we need to know if CAS to reset status</div><div class="line">     * fails, if so rechecking.</div><div class="line">     */</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">            <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">            <span class="comment">// 如果head的状态是SIGNAL，证明是等待一个信号，这时尝试将状态复位；</span></div><div class="line">            <span class="comment">// 如果复位成功，则唤醒下一节点，否则继续循环。</span></div><div class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                unparkSuccessor(h);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果状态是0，尝试设置状态为传播状态，表示节点向后传播；</span></div><div class="line">            <span class="comment">// 如果不成功则继续循环。</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果头节点有变化，则继续循环</span></div><div class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>什么时候状态会是SIGNAL呢？回顾一下shouldParkAfterFailedAcquire方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This node has already set status asking a release</div><div class="line">         * to signal it, so it can safely park.</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Predecessor was cancelled. Skip over predecessors and</div><div class="line">         * indicate retry.</div><div class="line">         */</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class="line">         * need a signal, but don't park yet.  Caller will need to</div><div class="line">         * retry to make sure it cannot acquire before parking.</div><div class="line">         */</div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当状态不为CANCEL或者是SIGNAL时，为了保险起见，这里把状态都设置成了SIGNAL，然后会再次循环进行判断是否需要阻塞。</p>
<p>回到doReleaseShared方法，这里为什么不直接把SIGNAL设置为PROPAGATE，而是先把SIGNAL设置为0，然后再设置为PROPAGATE呢？</p>
<p>原因在于unparkSuccessor方法，该方法会判断当前节点的状态是否小于0，如果小于0则将h的状态设置为0，如果在这里直接设置为PROPAGATE状态的话，则相当于多做了一次CAS操作。unparkSuccessor中的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ws = node.waitStatus;</div><div class="line"><span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>其实这里只判断状态为SIGNAL和0还有另一个原因，那就是当前执行doReleaseShared循环时的状态只可能为SIGNAL和0，因为如果这时没有后继节点的话，当前节点状态没有被修改，是初始的0；如果在执行setHead方法之前，这时刚好有后继节点被添加到队列中的话，因为这时后继节点判断<code>p == head</code>为false，所以会执行shouldParkAfterFailedAcquire方法，将当前节点的状态设置为SIGNAL。当状态为0时设置状态为PROPAGATE成功，则判断<code>h == head</code>结果为true，表示当前节点是队列中的唯一一个节点，所以直接就返回了；如果为false，则说明已经有后继节点的线程设置了head，这时不返回继续循环，但刚才获取的h已经用不到了，等待着被回收。</p>
<h3 id="CountDownLatch的countDown方法"><a href="#CountDownLatch的countDown方法" class="headerlink" title="CountDownLatch的countDown方法"></a>CountDownLatch的countDown方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是调用了AQS中的releaseShared方法。</p>
<h3 id="releaseShared方法"><a href="#releaseShared方法" class="headerlink" title="releaseShared方法"></a>releaseShared方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 尝试释放共享节点，如果成功则执行释放和唤醒操作</span></div><div class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">        doReleaseShared();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里调用的tryReleaseShared方法是在CountDownLatch中的Sync类重写的，而doReleaseShared方法已在上文中介绍过了。</p>
<h3 id="CountDownLatch中的tryReleaseShared方法"><a href="#CountDownLatch中的tryReleaseShared方法" class="headerlink" title="CountDownLatch中的tryReleaseShared方法"></a>CountDownLatch中的tryReleaseShared方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="comment">// 获取计数器数量</span></div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="comment">// 为0是返回false表示不需要释放</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 否则将计数器减1</span></div><div class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里设置state的操作需要循环来设置以确保成功。</p>
<h3 id="超时控制的await方法"><a href="#超时控制的await方法" class="headerlink" title="超时控制的await方法"></a>超时控制的await方法</h3><p>对应于上文中提到的doAcquireSharedInterruptibly方法，还有一个提供了超时控制的doAcquireSharedNanos方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">	<span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</div><div class="line">	    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</div><div class="line">	<span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	    <span class="keyword">for</span> (;;) &#123;</div><div class="line">	        <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">	        <span class="keyword">if</span> (p == head) &#123;</div><div class="line">	            <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">	            <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">	                setHeadAndPropagate(node, r);</div><div class="line">	                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">	                failed = <span class="keyword">false</span>;</div><div class="line">	                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">	        nanosTimeout = deadline - System.nanoTime();</div><div class="line">	        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</div><div class="line">	            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">	            nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">	            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">	        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">	            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">	    &#125;</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">	    <span class="keyword">if</span> (failed)</div><div class="line">	        cancelAcquire(node);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与doAcquireSharedInterruptibly方法新增了以下功能：</p>
<ul>
<li>增加了一个deadline变量表示超时的截止时间，根据当前时间与传入的nanosTimeout计算得出；</li>
<li>每次循环判断是否已经超出截止时间，即<code>deadline - System.nanoTime()</code>是否大于0，大于0表示已经超时，返回false，小于0表示还未超时；</li>
<li>如果未超时通过调用shouldParkAfterFailedAcquire方法判断是否需要park，如果返回true则再判断<code>nanosTimeout &gt; spinForTimeoutThreshold</code>，spinForTimeoutThreshold是自旋的最小阈值，这里被Doug Lea设置成了1000，表示1000纳秒，也就是说如果剩余的时间不足1000纳秒，则不需要park。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过CountDownLatch来分析了AQS共享模式的实现，实现方式如下：</p>
<p><strong>调用await时</strong></p>
<ul>
<li>共享锁获取失败（计数器还不为0），则将该线程封装为一个Node对象放入队列中，并阻塞该线程；</li>
<li>共享锁获取成功（计数器为0），则从第一个节点开始依次唤醒后继节点，实现共享状态的传播。</li>
</ul>
<p><strong>调用countDown时</strong></p>
<ul>
<li>如果计数器不为0，则不释放，继续阻塞，并把state的值减1；</li>
<li>如果计数器为0，则唤醒节点，解除线程的阻塞状态。</li>
</ul>
<p>在这里再对比一下独占模式和共享模式的相同点和不同点：</p>
<p><strong>相同点</strong></p>
<ul>
<li>锁的获取和释放的判断都是由子类来实现的。</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>独占功能在获取节点之后并且还未释放时，其他的节点会一直阻塞，直到第一个节点被释放才会唤醒；</li>
<li>共享功能在获取节点之后会立即唤醒队列中的后继节点，每一个节点都会唤醒自己的后继节点，这就是共享状态的传播。</li>
</ul>
<p>根据以上的总结可以看出，AQS不关心state具体是什么，含义由子类去定义，子类则根据该变量来进行获取和释放的判断，AQS只是维护了该变量，并且实现了一系列用来判断资源是否可以访问的API，它提供了对线程的入队和出队的操作，它还负责处理线程对资源的访问方式，例如：什么时候可以对资源进行访问，什么时候阻塞线程，什么时候唤醒线程，线程被取消后如何处理等。而子类则用来实现资源是否可以被访问的判断。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解AbstractQueuedSynchronizer（一）]]></title>
      <url>http://www.ideabuffer.cn/2017/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="AbstractQueuedSynchronizer简介"><a href="#AbstractQueuedSynchronizer简介" class="headerlink" title="AbstractQueuedSynchronizer简介"></a>AbstractQueuedSynchronizer简介</h2><p>AbstractQueuedSynchronizer提供了一个FIFO队列，可以看做是一个可以用来实现锁以及其他需要同步功能的框架。这里简称该类为AQS。AQS的使用依靠继承来完成，子类通过继承自AQS并实现所需的方法来管理同步状态。例如ReentrantLock，CountDownLatch等。</p>
<p>本篇文章基于JDK1.8来介绍，该类有许多实现类：</p>
<img src="/2017/03/15/深入理解AbstractQueuedSynchronizer（一）/QQ20170313-231557@2x.png" alt="QQ20170313-231557@2x.png" title="">
<a id="more"></a>
<p>其中，我们最常用的大概就是ReentrantLock和CountDownLatch了。ReentrantLock提供了对代码块的并发访问控制，也就是锁，说是锁，但其实并没有用到关键字<code>synchronized</code>，这么神奇？其实其内部就是基于同步器来实现的，本文结合ReentrantLock的使用来分析同步器独占锁的原理。</p>
<p>##AQS的两种功能</p>
<p>从使用上来说，AQS的功能可以分为两种：独占和共享。对于这两种功能，有一个很常用的类：ReentrantReadWriteLock，其就是通过两个内部类来分别实现了这两种功能，提供了读锁和写锁的功能。但子类实现时，只能实现其中的一种功能，即要么是独占功能，要么是共享功能。</p>
<p>对于独占功能，例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        </div><div class="line">    <span class="comment">// do something...</span></div><div class="line">        </div><div class="line">        </div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个很好理解，通过ReentrantLock来保证在<code>lock.lock()</code>之后的代码在同一时刻只能有一个线程来执行，其余的线程将会被阻塞，直到该线程执行了<code>lock.unlock()</code>。这就是一个独占锁的功能。</p>
<p>对于共享功能，例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">    lock.readLock().lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        </div><div class="line">    <span class="comment">// do something...</span></div><div class="line">        </div><div class="line">        </div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.readLock().unlock();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码中的<code>lock</code>是<code>ReentrantReadWriteLock</code>类的实例，而<code>lock.readLock()</code>为获取其中的读锁，即共享锁，使用方式并无差别，但和独占锁是有区别的：</p>
<ul>
<li>读锁与读锁可以共享</li>
<li>读锁与写锁不可以共享（排他）</li>
<li>写锁与写锁不可以共享（排他）</li>
</ul>
<h2 id="AQS独占锁的内部实现"><a href="#AQS独占锁的内部实现" class="headerlink" title="AQS独占锁的内部实现"></a>AQS独占锁的内部实现</h2><h3 id="AQS的主要数据结构"><a href="#AQS的主要数据结构" class="headerlink" title="AQS的主要数据结构"></a>AQS的主要数据结构</h3><p>由于使用AQS可以实现锁的功能，那么下面就要分析一下究竟是如何实现的。</p>
<p>AQS内部维护着一个FIFO的队列，该队列就是用来实现线程的并发访问控制。队列中的元素是一个Node类型的节点，Node的主要属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> waitStatus;</div><div class="line">    Node prev;</div><div class="line">    Node next;</div><div class="line">    Node nextWaiter;</div><div class="line">    Thread thread;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><em>waitStatus</em>：表示节点的状态，其中包含的状态有：<ul>
<li><em>CANCELLED</em>：值为1，表示当前节点被取消；</li>
<li><em>SIGNAL</em>：值为-1，表示当前节点的的后继节点将要或者已经被阻塞，在当前节点释放的时候需要unpark后继节点；</li>
<li><em>CONDITION</em>：值为-2，表示当前节点在等待condition，即在condition队列中；</li>
<li><em>PROPAGATE</em>：值为-3，表示releaseShared需要被传播给后续节点（仅在共享模式下使用）；</li>
<li><em>0</em>：无状态，表示当前节点在队列中等待获取锁。</li>
</ul>
</li>
<li><em>prev</em>：前继节点；</li>
<li><em>next</em>：后继节点；</li>
<li><em>nextWaiter</em>：存储condition队列中的后继节点；</li>
<li><em>thread</em>：当前线程。</li>
</ul>
<p>其中，队列里还有一个<code>head</code>节点和一个<code>tail</code>节点，分别表示头结点和尾节点，其中头结点不存储Thread，仅保存next结点的引用。</p>
<p>AQS中有一个<code>state</code>变量，该变量对不同的子类实现具有不同的意义，对ReentrantLock来说，它表示加锁的状态：</p>
<ul>
<li>无锁时state=0，有锁时state&gt;0；</li>
<li>第一次加锁时，将state设置为1；</li>
<li>由于ReentrantLock是可重入锁，所以持有锁的线程可以多次加锁，经过判断加锁线程就是当前持有锁的线程时（即<code>exclusiveOwnerThread==Thread.currentThread()</code>），即可加锁，每次加锁都会将state的值+1，state等于几，就代表当前持有锁的线程加了几次锁;</li>
<li>解锁时每解一次锁就会将state减1，state减到0后，锁就被释放掉，这时其它线程可以加锁；</li>
<li>当持有锁的线程释放锁以后，如果是等待队列获取到了加锁权限，则会在等待队列头部取出第一个线程去获取锁，获取锁的线程会被移出队列；</li>
</ul>
<p><code>state</code>变量定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The synchronization state.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div></pre></td></tr></table></figure>
<h3 id="ReentrantLock类的结构"><a href="#ReentrantLock类的结构" class="headerlink" title="ReentrantLock类的结构"></a>ReentrantLock类的结构</h3><p>下面通过ReentrantLock的实现进一步分析重入锁的实现。</p>
<p>首先看一下lock方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.lock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法调用了<code>sync</code>实例的lock方法，这里要说明一下ReentrantLock中的几个内部类：</p>
<ul>
<li>Sync</li>
<li>FairSync</li>
<li>NonfairSync</li>
</ul>
<p>对于ReentrantLock，有两种获取锁的模式：公平锁和非公平锁。所以对应有两个内部类，都继承自Sync。而Sync继承自AQS：</p>
<img src="/2017/03/15/深入理解AbstractQueuedSynchronizer（一）/QQ20170314-003640.png" alt="QQ20170314-003640.png" title="">
<p>本文主要通过公平锁来介绍，看一下FairSync的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Sync object for fair locks</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Fair version of tryAcquire.  Don't grant access unless</div><div class="line">     * recursive call or no waiters or is first.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">        <span class="comment">// 获取state</span></div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="comment">// state=0表示当前队列中没有线程被加锁</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * 首先判断是否有前继结点，如果没有则当前队列中还没有其他线程；</div><div class="line">             * 设置状态为acquires，即lock方法中写死的1（这里为什么不直接setState？因为可能同时有多个线程同时在执行到此处，所以用CAS来执行）；</div><div class="line">             * 设置当前线程独占锁。</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 如果state不为0，表示已经有线程独占锁了，这时还需要判断独占锁的线程是否是当前的线程，原因是由于ReentrantLock为可重入锁；</div><div class="line">         * 如果独占锁的线程是当前线程，则将状态加1，并setState;</div><div class="line">         * 这里为什么不用compareAndSetState？因为独占锁的线程已经是当前线程，不需要通过CAS来设置。</div><div class="line">         */</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">            <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">            setState(nextc);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AQS获取独占锁的实现"><a href="#AQS获取独占锁的实现" class="headerlink" title="AQS获取独占锁的实现"></a>AQS获取独占锁的实现</h3><h4 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h4><p><code>acquire</code>是AQS中的方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法主要工作如下：</p>
<ol>
<li>尝试获取独占锁；</li>
<li>获取成功则返回，否则执行步骤3;</li>
<li>addWaiter方法将当前线程封装成Node对象，并添加到队列尾部；</li>
<li>自旋获取锁，并判断中断标志位。如果中断标志位为<code>true</code>，执行步骤5，否则返回；</li>
<li>设置线程中断。</li>
</ol>
<h4 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h4><p><code>tryAcquire</code>方法在FairSync中已经说明，它重写了AQS中的方法，在AQS中它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然该方法需要子类来实现，为什么不使用<code>abstract</code>来修饰呢？上文中提到过，AQS有两种功能：独占和共享，而且子类只能实现其一种功能，所以，如果使用<code>abstract</code>来修饰，那么每个子类都需要同时实现两种功能的方法，这对子类来说不太友好，所以没有使用<code>abstract</code>来修饰。</p>
<p>该方法是在ReentrantLock中的FairSync和NonfairSync的两个内部类来实现的，这里以FairSysc-公平锁来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h4><p>看下addWaiter方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据当前线程创建一个Node对象</span></div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="comment">// 判断tail是否为空，如果为空表示队列是空的，直接enq</span></div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="comment">// 这里尝试CAS来设置队尾，如果成功则将当前节点设置为tail，否则enq</span></div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法就是根据当前线程创建一个Node，然后添加到队列尾部。</p>
<h4 id="enq方法"><a href="#enq方法" class="headerlink" title="enq方法"></a>enq方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">// 重复直到成功</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node t = tail;</div><div class="line">        <span class="comment">// 如果tail为null，则必须创建一个Node节点并进行初始化</span></div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev = t;</div><div class="line">            <span class="comment">// 尝试CAS来设置队尾</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                <span class="keyword">return</span> t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="acquireQueued方法"><a href="#acquireQueued方法" class="headerlink" title="acquireQueued方法"></a>acquireQueued方法</h4><p>该方法的功能是循环的尝试获取锁，直到成功为止，最后返回中断标志位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 中断标志位</span></div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="comment">// 获取前继节点</span></div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="comment">// 如果前继节点是head，则尝试获取</span></div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                <span class="comment">// 设置head为当前节点（head中不包含thread）</span></div><div class="line">                setHead(node);</div><div class="line">                <span class="comment">// 清除之前的head</span></div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果p不是head或者获取锁失败，判断是否需要进行park</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有几个问题很重要：</p>
<ul>
<li>什么条件下需要park？</li>
<li>为什么要判断中断状态？</li>
<li>死循环不会引起CPU使用率飙升？</li>
</ul>
<p>下面分别来分析一下。</p>
<p><strong>什么条件下需要park？</strong></p>
<p>看下<code>shouldParkAfterFailedAcquire</code>方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This node has already set status asking a release</div><div class="line">         * to signal it, so it can safely park.</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Predecessor was cancelled. Skip over predecessors and</div><div class="line">         * indicate retry.</div><div class="line">         */</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class="line">         * need a signal, but don't park yet.  Caller will need to</div><div class="line">         * retry to make sure it cannot acquire before parking.</div><div class="line">         */</div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果前一个节点的状态是<em>SIGNAL</em>，则需要park；</li>
<li>如果<code>ws &gt; 0</code>，表示已被取消，删除状态是已取消的节点；</li>
<li>其他情况，设置前继节点的状态为<em>SIGNAL</em>。</li>
</ul>
<p>可见，只有在前继节点的状态是<em>SIGNAL</em>时，需要park。第二种情况稍后会详细介绍。</p>
<p><strong>为什么要判断中断状态？</strong></p>
<p>首先要知道，acquireQueued方法中获取锁的方式是死循环，判断是否中断是在parkAndCheckInterrupt方法中实现的，看下该方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简单，阻塞当前线程，然后返回线程的中断状态并复位中断状态。</p>
<blockquote>
<p>注意interrupted()方法的作用，该方法是获取线程的中断状态，并复位，也就是说，如果当前线程是中断状态，则第一次调用该方法获取的是<code>true</code>，第二次则是<code>false</code>。而isInterrupted()方法则只是返回线程的中断状态，不执行复位操作。</p>
</blockquote>
<p>如果acquireQueued执行完毕，返回中断状态，回到acquire方法中，根据返回的中断状态判断是否需要执行<code>Thread.currentThread().interrupt()</code>。</p>
<p>为什么要多做这一步呢？先判断中断状态，然后复位，如果之前线程是中断状态，再进行中断？</p>
<p>这里就要介绍一下park方法了。park方法是Unsafe类中的方法，与之对应的是unpark方法。简单来说，当前线程如果执行了park方法，也就是阻塞了当前线程，反之，unpark就是唤醒一个线程。</p>
<p>具体的说明请参考<a href="http://blog.csdn.net/hengyunabc/article/details/28126139" target="_blank" rel="external">http://blog.csdn.net/hengyunabc/article/details/28126139</a></p>
<p>park与wait的作用类似，但是对中断状态的处理并不相同。如果当前线程不是中断的状态，park与wait的效果是一样的；如果一个线程是中断的状态，这时执行wait方法会报<code>java.lang.IllegalMonitorStateException</code>，而执行park时并不会报异常，而是直接返回。</p>
<p>所以，知道了这一点，就可以知道为什么要进行中断状态的复位了：</p>
<ul>
<li>如果当前线程是非中断状态，则在执行park时被阻塞，这是返回中断状态是<code>false</code>；</li>
<li>如果当前线程是中断状态，则park方法不起作用，会立即返回，然后parkAndCheckInterrupt方法会获取中断的状态，也就是<code>true</code>，并复位；</li>
<li>再次执行循环的时候，由于在前一步已经把该线程的中断状态进行了复位，则再次调用park方法时会阻塞。</li>
</ul>
<p>所以，这里判断线程中断的状态实际上是为了不让循环一直执行，要让当前线程进入阻塞的状态。想象一下，如果不这样判断，前一个线程在获取锁之后执行了很耗时的操作，那么岂不是要一直执行该死循环？这样就造成了CPU使用率飙升，这是很严重的后果。</p>
<p><strong>死循环不会引起CPU使用率飙升？</strong></p>
<p>上面已经说明。</p>
<h4 id="cancelAcquire方法"><a href="#cancelAcquire方法" class="headerlink" title="cancelAcquire方法"></a>cancelAcquire方法</h4><p>在acquireQueued方法的finally语句块中，如果在循环的过程中出现了异常，则执行cancelAcquire方法，用于将该节点标记为取消状态。该方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">// Ignore if node doesn't exist</span></div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="comment">// 设置该节点不再关联任何线程</span></div><div class="line">    node.thread = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Skip cancelled predecessors</span></div><div class="line">    <span class="comment">// 通过前继节点跳过取消状态的node</span></div><div class="line">    Node pred = node.prev;</div><div class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</div><div class="line">        node.prev = pred = pred.prev;</div><div class="line"></div><div class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></div><div class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></div><div class="line">    <span class="comment">// or signal, so no further action is necessary.</span></div><div class="line">    <span class="comment">// 获取过滤后的前继节点的后继节点</span></div><div class="line">    Node predNext = pred.next;</div><div class="line"></div><div class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></div><div class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></div><div class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></div><div class="line">    <span class="comment">// 设置状态为取消状态</span></div><div class="line">    node.waitStatus = Node.CANCELLED;</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * If we are the tail, remove ourselves.</div><div class="line">     * 1.如果当前节点是tail：</div><div class="line">     * 尝试更新tail节点，设置tail为pred；</div><div class="line">     * 更新失败则返回，成功则设置tail的后继节点为null</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</div><div class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></div><div class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></div><div class="line">        <span class="keyword">int</span> ws;</div><div class="line">        <span class="comment">/* </span></div><div class="line">         * 2.如果当前节点不是head的后继节点：</div><div class="line">         * 判断当前节点的前继节点的状态是否是SIGNAL，如果不是则尝试设置前继节点的状态为SIGNAL；</div><div class="line">         * 上面两个条件如果有一个返回true，则再判断前继节点的thread是否不为空；</div><div class="line">         * 若满足以上条件，则尝试设置当前节点的前继节点的后继节点为当前节点的后继节点，也就是相当于将当前节点从队列中删除</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</div><div class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</div><div class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</div><div class="line">            pred.thread != <span class="keyword">null</span>) &#123;</div><div class="line">            Node next = node.next;</div><div class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                compareAndSetNext(pred, predNext, next);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 3.如果是head的后继节点或者状态判断或设置失败，则唤醒当前节点的后继节点</span></div><div class="line">            unparkSuccessor(node);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        node.next = node; <span class="comment">// help GC</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法中执行的过程有些复杂，首先是要获取当前节点的前继节点，如果前继节点的状态不是取消状态（即<code>pred.waitStatus &gt; 0</code>），则向前遍历队列，直到遇到第一个<code>waitStatus &lt;= 0</code>的节点，并把当前节点的前继节点设置为该节点，然后设置当前节点的状态为取消状态。</p>
<p>接下来的工作可以分为3种情况：</p>
<ul>
<li>当前节点是tail；</li>
<li>当前节点不是head的后继节点（即队列的第一个节点，不包括head），也不是tail；</li>
<li>当前节点是head的后继节点。</li>
</ul>
<p>我们依次来分析一下：</p>
<p><strong>当前节点是tail</strong></p>
<p>这种情况很简单，因为tail是队列的最后一个节点，如果该节点需要取消，则直接把该节点的前继节点的next指向null，也就是把当前节点移除队列。出队的过程如下：</p>
<img src="/2017/03/15/深入理解AbstractQueuedSynchronizer（一）/QQ20170314-235854.png" alt="QQ20170314-235854.png" title="">
<p>注意：经验证，这里并没有设置node的prev为null。</p>
<p><strong>当前节点不是head的后继节点，也不是tail</strong></p>
<img src="/2017/03/15/深入理解AbstractQueuedSynchronizer（一）/QQ20170315-014004.png" alt="QQ20170315-014004.png" title="">
<p>这里将node的前继节点的next指向了node的后继节点，真正执行的代码就是如下一行：</p>
<p><code>compareAndSetNext(pred, predNext, next);</code></p>
<p><strong>当前节点是head的后继节点</strong></p>
<img src="/2017/03/15/深入理解AbstractQueuedSynchronizer（一）/QQ20170315-014948.png" alt="QQ20170315-014948.png" title="">
<p>这里直接unpark后继节点的线程，然后将next指向了自己。</p>
<p>这里可能会有疑问，既然要删除节点，为什么都没有对prev进行操作，而仅仅是修改了next？</p>
<p>要明确的一点是，这里修改指针的操作都是CAS操作，在AQS中所有以<code>compareAndSet</code>开头的方法都是尝试更新，并不保证成功，图中所示的都是执行成功的情况。</p>
<p>那么在执行cancelAcquire方法时，当前节点的前继节点有可能已经执行完并移除队列了（参见<code>setHead</code>方法），所以在这里只能用CAS来尝试更新，而就算是尝试更新，也只能更新next，不能更新prev，因为prev是不确定的，否则有可能会导致整个队列的不完整，例如把prev指向一个已经移除队列的node。</p>
<p>什么时候修改prev呢？其实prev是由其他线程来修改的。回去看下shouldParkAfterFailedAcquire方法，该方法有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    node.prev = pred = pred.prev;</div><div class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">pred.next = node;</div></pre></td></tr></table></figure>
<p>该段代码的作用就是通过prev遍历到第一个不是取消状态的node，并修改prev。</p>
<p>这里为什么可以更新prev？因为shouldParkAfterFailedAcquire方法是在获取锁失败的情况下才能执行，因此进入该方法时，说明已经有线程获得锁了，并且在执行该方法时，当前节点之前的节点不会变化（因为只有当下一个节点获得锁的时候才会设置head），所以这里可以更新prev，而且不必用CAS来更新。</p>
<h3 id="AQS释放独占锁的实现"><a href="#AQS释放独占锁的实现" class="headerlink" title="AQS释放独占锁的实现"></a>AQS释放独占锁的实现</h3><p>释放通过unlock方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法调用了release方法，release是在AQS中定义的，看下release代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 尝试释放锁</span></div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        <span class="comment">// 释放成功后unpark后继节点的线程</span></div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里首先尝试着去释放锁，成功了之后要去唤醒后继节点的线程，这样其他的线程才有机会去执行。</p>
<p>tryRelease代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是和tryAcquire方法类似？该方法也需要被重写，在Sync类中的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里是将锁的数量减1</span></div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 由于重入的关系，不是每次释放锁c都等于0，</span></div><div class="line">    <span class="comment">// 直到最后一次释放锁时，才会把当前线程释放</span></div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 记录锁的数量</span></div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当前线程被释放之后，需要唤醒下一个节点的线程，通过unparkSuccessor方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If status is negative (i.e., possibly needing signal) try</div><div class="line">     * to clear in anticipation of signalling.  It is OK if this</div><div class="line">     * fails or if status is changed by waiting thread.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Thread to unpark is held in successor, which is normally</div><div class="line">     * just the next node.  But if cancelled or apparently null,</div><div class="line">     * traverse backwards from tail to find the actual</div><div class="line">     * non-cancelled successor.</div><div class="line">     */</div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要功能就是要唤醒下一个线程，这里<code>s == null || s.waitStatus &gt; 0</code>判断后继节点是否为空或者是否是取消状态，然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点，至于为什么从尾部开始向前遍历，回想一下cancelAcquire方法的处理过程，cancelAcquire只是设置了next的变化，没有设置prev的变化，在最后有这样一行代码：<code>node.next = node</code>，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的。</p>
<p>到这里，通过ReentrantLock的lock和unlock来分析AQS独占锁的实现已经基本完成了，但ReentrantLock还有一个非公平锁NonfairSync。</p>
<p>其实NonfairSync和FairSync主要就是在获取锁的方式上不同，公平锁是按顺序去获取，而非公平锁是抢占式的获取，lock的时候先去尝试修改state变量，如果抢占成功，则获取到锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非公平锁的tryAcquire方法调用了nonfairTryAcquire方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法比公平锁的tryAcquire方法在第二个if判断中少了一个是否存在前继节点判断，FairSync中的tryAcquire代码中的这个if语句块如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">    setExclusiveOwnerThread(current);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从ReentrantLock出发，比较完整的分析了AQS内部独占锁的实现，总体来说实现的思路很清晰，就是使用了标志位+队列的方式来处理锁的状态，包括锁的获取，锁的竞争以及锁的释放。在AQS中，state可以表示锁的数量，也可以表示其他状态，state的含义由子类去定义，自己只是提供了对state的维护。AQS通过state来实现线程对资源的访问控制，而state具体的含义要在子类中定义。</p>
<p>AQS在队列的维护上的实现比较复杂，尤其是节点取消时队列的维护，这里并不是通过一个线程来完成的。同时，AQS中大量的使用CAS来实现更新，这种更新能够保证状态和队列的完整性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat源码：类加载器]]></title>
      <url>http://www.ideabuffer.cn/2016/12/24/Tomcat%E6%BA%90%E7%A0%81%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>在<a href="/2016/11/26/Tomcat源码：Bootstrap启动流程/">Tomcat源码：Bootstrap启动流程</a>文章中简单介绍过Java类加载器和Tomcat的类加载器，可以知道，每一个应用都有一个单独的类加载器来加载位于该应用下的WEB-INF/lib中的jar文件和WEB-INF/classes中的class文件，该应用不可以访问其他路径的class或jar。</p>
<p>Tomcat中实现自定义加载器还有另一个原因，就是为了提供自动重载的功能，如果当WEB-INF/classes目录或WEB-INF/lib目录中的类发生变化时，Web应用会重新加载这些类。</p>
<p>下面来看一下Tomcat中类加载器的类图：</p>
<img src="/2016/12/24/Tomcat源码：类加载器/QQ20161224-0@2x.png" alt="QQ20161224-0@2x.png" title="">
<a id="more"></a>
<h2 id="Loader接口"><a href="#Loader接口" class="headerlink" title="Loader接口"></a>Loader接口</h2><p>要实现Tomcat的类载入器必须遵守一些规则，例如，Web应用程序必须只能使用WEB-INF/classes目录或WEB-INF/lib目录中的类，不能访问其他路径中的类，即使这些类已经包含在当前Tomcat的JVM的CLASSPATH环境变量中。</p>
<p>Web应用程序的类加载器必须实现<code>org.apache.catalina.Loader</code>接口，其有一个实现类是<code>org.apache.catalina.loader.WebappLoader</code>，下面来看一下Loader接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Loader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backgroundProcess</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context context)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getDelegate</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(<span class="keyword">boolean</span> delegate)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getReloadable</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReloadable</span><span class="params">(<span class="keyword">boolean</span> reloadable)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">modified</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removePropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>org.apache.catalina.loader.WebappLoader</code>类作为Loader接口的实现，它的实例使用了<code>org.apache.catalina.loader.WebappClassLoader</code>作为其类加载器。</p>
<h2 id="WebappLoader类"><a href="#WebappLoader类" class="headerlink" title="WebappLoader类"></a>WebappLoader类</h2><p>WebappLoader类同样实现了<code>org.apache.catalina.LifeCycle</code>接口，可以通过与其相关联的容器来启动或关闭，下面看一下用于WebappLoader启动的startInternal方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</div><div class="line">        log.debug(sm.getString(<span class="string">"webappLoader.starting"</span>));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (context.getResources() == <span class="keyword">null</span>) &#123;</div><div class="line">        log.info(<span class="string">"No resources for "</span> + context);</div><div class="line">        setState(LifecycleState.STARTING);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Construct a class loader based on our current repositories list</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 创建类载入器，是WebappClassLoaderBase类的实例</span></div><div class="line">        classLoader = createClassLoader();</div><div class="line">        <span class="comment">// 设置用来描述当前Web应用的资源信息的实例，是WebResourceRoot类型</span></div><div class="line">        <span class="comment">// 对于Context来说，是StandardRoot类的实例</span></div><div class="line">        classLoader.setResources(context.getResources());</div><div class="line">        classLoader.setDelegate(<span class="keyword">this</span>.delegate);</div><div class="line"></div><div class="line">        <span class="comment">// 设置类路径</span></div><div class="line">        <span class="comment">// Configure our repositories</span></div><div class="line">        setClassPath();</div><div class="line">        </div><div class="line">        <span class="comment">// 设置访问权限</span></div><div class="line">        setPermissions();</div><div class="line"></div><div class="line">        <span class="comment">// 启动WebappClassLoader</span></div><div class="line">        ((Lifecycle) classLoader).start();</div><div class="line"></div><div class="line">        String contextName = context.getName();</div><div class="line">        <span class="keyword">if</span> (!contextName.startsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">            contextName = <span class="string">"/"</span> + contextName;</div><div class="line">        &#125;</div><div class="line">        ObjectName cloname = <span class="keyword">new</span> ObjectName(context.getDomain() + <span class="string">":type="</span> +</div><div class="line">                classLoader.getClass().getSimpleName() + <span class="string">",host="</span> +</div><div class="line">                context.getParent().getName() + <span class="string">",context="</span> + contextName);</div><div class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>)</div><div class="line">            .registerComponent(classLoader, cloname, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        t = ExceptionUtils.unwrapInvocationTargetException(t);</div><div class="line">        ExceptionUtils.handleThrowable(t);</div><div class="line">        log.error( <span class="string">"LifecycleException "</span>, t );</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(<span class="string">"start: "</span>, t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setState(LifecycleState.STARTING);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在startInternal方法中，主要做了以下几种工作：</p>
<ol>
<li>创建类加载器</li>
<li>设置类加载器的WebResourceRoot</li>
<li>设置类路径</li>
<li>设置访问权限</li>
<li>启动WebappClassLoader</li>
</ol>
<h3 id="创建类加载器"><a href="#创建类加载器" class="headerlink" title="创建类加载器"></a>创建类加载器</h3><p>在前面介绍的Loader接口中，可以看到声明了<code>getClassLoader()</code>方法，但其中并没有声明<code>setClassLoader()</code>方法，是不是就只能使用默认的类加载器呢？</p>
<p>可以看到，在WebappLoader类中有一个属性是<code>loaderClass</code>，该属性的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> String loaderClass = ParallelWebappClassLoader.class.getName();</div></pre></td></tr></table></figure>
<p>它是String类型，默认是<code>ParallelWebappClassLoader</code>类的全限定名，同时有一个<code>setLoaderClass</code>方法用来设置该属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoaderClass</span><span class="params">(String loaderClass)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loaderClass = loaderClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见，默认情况下<code>loaderClass</code>的值是<code>org.apache.catalina.loader.ParallelWebappClassLoader</code>，可以通过继承<code>WebappClassLoaderBase</code>类的方式来实现自己的类加载器，同时调用<code>setLoaderClass</code>方法来使用自己的类加载器。下面看一下<code>createClassLoader</code>方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> WebappClassLoaderBase <span class="title">createClassLoader</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 加载loaderClass</span></div><div class="line">    Class&lt;?&gt; clazz = Class.forName(loaderClass);</div><div class="line">    WebappClassLoaderBase classLoader = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 设置父加载器</span></div><div class="line">    <span class="keyword">if</span> (parentClassLoader == <span class="keyword">null</span>) &#123;</div><div class="line">        parentClassLoader = context.getParentClassLoader();</div><div class="line">    &#125;</div><div class="line">    Class&lt;?&gt;[] argTypes = &#123; ClassLoader.class &#125;;</div><div class="line">    Object[] args = &#123; parentClassLoader &#125;;</div><div class="line">    Constructor&lt;?&gt; constr = clazz.getConstructor(argTypes);</div><div class="line">    <span class="comment">// 实例化类加载器</span></div><div class="line">    classLoader = (WebappClassLoaderBase) constr.newInstance(args);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> classLoader;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见该方法返回的类型是<code>WebappClassLoaderBase</code>类型，所以如果要自定义类加载器的话要继承该类。</p>
<h3 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h3><p>通过调用<code>setClassPath</code>方法来设置类路径，这里会遍历调用classLoader以及其父加载器的repositories，并保存到<code>classpath</code>变量中，这里先不过多介绍了。</p>
<h3 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h3><p>若使用了安全管理器，则<code>setPermissions</code>方法会为类加载器设置相关的目录访问权限，例如只能访问WEB-INF/classes和WEB-INF/lib目录，若没有使用安全管理器，则该方法并不做任何处理。</p>
<h2 id="WebappClassLoaderBase类"><a href="#WebappClassLoaderBase类" class="headerlink" title="WebappClassLoaderBase类"></a>WebappClassLoaderBase类</h2><p>该类的实例是具体负责类的载入工作的。它继承自<code>java.net.URLClassLoader</code>类。该类在载入的时候做了优化的方案，它会先缓存已经载入的类用来提升性能，同时，还会缓存载入失败的类，如果再次加载同一个类时，会从缓存中找，如果存在则直接抛出ClassNotFoundException异常，不会再尝试加载该类了。</p>
<p>下面看一下该类中几个重要的方法。</p>
<p>首先看下loadClass方法，这里对代码做了简化，只保留了最核心的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class="line">        </div><div class="line">        Class&lt;?&gt; clazz = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 1. 先从缓存中查找，有则返回</span></div><div class="line">        <span class="comment">// (0) Check our previously loaded local class cache</span></div><div class="line">        clazz = findLoadedClass0(name);</div><div class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (resolve)</div><div class="line">                resolveClass(clazz);</div><div class="line">            <span class="keyword">return</span> (clazz);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 从parent中查找</span></div><div class="line">        <span class="comment">// (0.1) Check our previously loaded class cache</span></div><div class="line">        clazz = findLoadedClass(name);</div><div class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (resolve)</div><div class="line">                resolveClass(clazz);</div><div class="line">            <span class="keyword">return</span> (clazz);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 获取扩展类加载器</span></div><div class="line">        ClassLoader javaseLoader = getJavaseClassLoader();</div><div class="line">        <span class="keyword">boolean</span> tryLoadingFromJavaseLoader;</div><div class="line">        <span class="keyword">try</span> &#123;            </div><div class="line">            tryLoadingFromJavaseLoader = (javaseLoader.getResource(resourceName) != <span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassCircularityError cce) &#123;            </div><div class="line">            tryLoadingFromJavaseLoader = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (tryLoadingFromJavaseLoader) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 3. 从扩展类加载器中查找</span></div><div class="line">                clazz = javaseLoader.loadClass(name);</div><div class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (resolve)</div><div class="line">                        resolveClass(clazz);</div><div class="line">                    <span class="keyword">return</span> (clazz);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                <span class="comment">// Ignore</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 判断是否让parent代理</span></div><div class="line">        <span class="keyword">boolean</span> delegateLoad = delegate || filter(name, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 4. 如果为true，则先从parent中加载</span></div><div class="line">        <span class="comment">// (1) Delegate to our parent if requested</span></div><div class="line">        <span class="keyword">if</span> (delegateLoad) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</div><div class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (resolve)</div><div class="line">                        resolveClass(clazz);</div><div class="line">                    <span class="keyword">return</span> (clazz);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                <span class="comment">// Ignore</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 5. 从该classLoader中的库加载，如果加载成功则写入缓存中</span></div><div class="line">        <span class="comment">// (2) Search local repositories</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            clazz = findClass(name);</div><div class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;               </div><div class="line">                <span class="keyword">if</span> (resolve)</div><div class="line">                    resolveClass(clazz);</div><div class="line">                <span class="keyword">return</span> (clazz);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            <span class="comment">// Ignore</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 6. 以上都加载失败，则通过parent代理加载</span></div><div class="line">        <span class="comment">// (3) Delegate to parent unconditionally</span></div><div class="line">        <span class="keyword">if</span> (!delegateLoad) &#123;            </div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</div><div class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (resolve)</div><div class="line">                        resolveClass(clazz);</div><div class="line">                    <span class="keyword">return</span> (clazz);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                <span class="comment">// Ignore</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看到，在载入类时，会执行一下步骤：</p>
<ol>
<li>因为已经载入的类会缓存起来，所以先从缓存中查找；</li>
<li>若缓存中没有，则检查parent的缓存，即调用<code>java.lang.ClassLoader</code>类中的findLoadedClass()方法；</li>
<li>若以上两步都没有找到，则使用扩展类加载器进行加载，防止Web应用程序中的类覆盖JavaSE中的类；</li>
<li>判断是否需要代理加载，判断依据是若<code>delegate</code>或<code>filter(name)</code>为true，则让parent来加载；</li>
<li>从当前classLoader中的库加载，如果加载成功则写入缓存中；</li>
<li>以上都加载失败，若delegateLoad为<code>false</code>，则通过parent代理加载（因为为<code>true</code>时已经执行过了，所以不用考虑）；</li>
<li>若仍然未找到类，则抛出<code>ClassNotFoundException</code>。</li>
</ol>
<p>其中的<code>filter</code>方法用来判断要加载的类是否需要被过滤，有一些特殊的包以及子包下的类是不允许被载入进来的，具体可以参考代码。</p>
<p>下面看一下<code>findLoadedClass0</code>方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; findLoadedClass0(String name) &#123;</div><div class="line"></div><div class="line">    String path = binaryNameToPath(name, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    ResourceEntry entry = resourceEntries.get(path);</div><div class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> entry.loadedClass;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法从缓存中查找名字为name的类，<code>resourceEntries</code>是一个<code>ConcurrentHashMap</code>类型的实例，它保存了加载成功的类，每一个类的信息会封装成一个<code>ResourceEntry</code>的实例，该类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceEntry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The "last modified" time of the origin file at the time this resource</div><div class="line">     * was loaded, in milliseconds since the epoch.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> lastModified = -<span class="number">1</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Loaded class.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Class&lt;?&gt; loadedClass = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>loadClass会调用findClass方法，下面是findClass的精简过后的代码，去掉了securityManager和log：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line"></div><div class="line">    Class&lt;?&gt; clazz = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 尝试从本地库加载</span></div><div class="line">            clazz = findClassInternal(name);</div><div class="line">        &#125; <span class="keyword">catch</span>(AccessControlException ace) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, ace);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果没有找到并且存在外部的库，则请求parent加载</span></div><div class="line">        <span class="keyword">if</span> ((clazz == <span class="keyword">null</span>) &amp;&amp; hasExternalRepositories) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                clazz = <span class="keyword">super</span>.findClass(name);</div><div class="line">            &#125; <span class="keyword">catch</span>(AccessControlException ace) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, ace);</div><div class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">                <span class="keyword">throw</span> e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (clazz);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里调用了<code>findClassInternal</code>方法，看下这个方法精简后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClassInternal(String name) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    String path = binaryNameToPath(name, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    ResourceEntry entry = resourceEntries.get(path);</div><div class="line">    WebResource resource = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">        resource = resources.getClassLoaderResource(path);</div><div class="line">        </div><div class="line">        <span class="comment">// 对应的class不存在，返回null</span></div><div class="line">        <span class="keyword">if</span> (!resource.exists()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        entry = <span class="keyword">new</span> ResourceEntry();</div><div class="line">        entry.lastModified = resource.getLastModified();</div><div class="line">        </div><div class="line">        <span class="comment">// 把entry添加到本地库中</span></div><div class="line">        <span class="comment">// resourceEntries虽然是ConcurrentHashMap类型</span></div><div class="line">        <span class="comment">// 但这里为了保证添加后的entry是同一个对象，所以做了同步</span></div><div class="line">        <span class="comment">// Add the entry in the local resource repository</span></div><div class="line">        <span class="keyword">synchronized</span> (resourceEntries) &#123;</div><div class="line">            <span class="comment">// Ensures that all the threads which may be in a race to load</span></div><div class="line">            <span class="comment">// a particular class all end up with the same ResourceEntry</span></div><div class="line">            <span class="comment">// instance</span></div><div class="line">            ResourceEntry entry2 = resourceEntries.get(path);</div><div class="line">            <span class="keyword">if</span> (entry2 == <span class="keyword">null</span>) &#123;</div><div class="line">                resourceEntries.put(path, entry);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                entry = entry2;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// entry.loadedClass不为空，表示已经加载过了，直接返回</span></div><div class="line">    Class&lt;?&gt; clazz = entry.loadedClass;</div><div class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> clazz;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class="line">        clazz = entry.loadedClass;</div><div class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> clazz;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (resource == <span class="keyword">null</span>) &#123;</div><div class="line">            resource = resources.getClassLoaderResource(path);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 对应的class不存在，返回null</span></div><div class="line">        <span class="keyword">if</span> (!resource.exists()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">byte</span>[] binaryContent = resource.getContent();</div><div class="line">        Manifest manifest = resource.getManifest();</div><div class="line">        URL codeBase = resource.getCodeBase();</div><div class="line">        Certificate[] certificates = resource.getCertificates();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (transformers.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// If the resource is a class just being loaded, decorate it</span></div><div class="line">            <span class="comment">// with any attached transformers</span></div><div class="line">            String className = name.endsWith(CLASS_FILE_SUFFIX) ?</div><div class="line">                    name.substring(<span class="number">0</span>, name.length() - CLASS_FILE_SUFFIX.length()) : name;</div><div class="line">            String internalName = className.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (ClassFileTransformer transformer : <span class="keyword">this</span>.transformers) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">byte</span>[] transformed = transformer.transform(</div><div class="line">                            <span class="keyword">this</span>, internalName, <span class="keyword">null</span>, <span class="keyword">null</span>, binaryContent);</div><div class="line">                    <span class="keyword">if</span> (transformed != <span class="keyword">null</span>) &#123;</div><div class="line">                        binaryContent = transformed;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (IllegalClassFormatException e) &#123;</div><div class="line">                    log.error(sm.getString(<span class="string">"webappClassLoader.transformError"</span>, name), e);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Looking up the package</span></div><div class="line">        String packageName = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> pos = name.lastIndexOf(<span class="string">'.'</span>);</div><div class="line">        <span class="keyword">if</span> (pos != -<span class="number">1</span>)</div><div class="line">            packageName = name.substring(<span class="number">0</span>, pos);</div><div class="line"></div><div class="line">        Package pkg = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (packageName != <span class="keyword">null</span>) &#123;</div><div class="line">            pkg = getPackage(packageName);</div><div class="line">            <span class="comment">// Define the package (if null)</span></div><div class="line">            <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (manifest == <span class="keyword">null</span>) &#123;</div><div class="line">                        definePackage(packageName, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        definePackage(packageName, manifest, codeBase);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                pkg = getPackage(packageName);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            clazz = defineClass(name, binaryContent, <span class="number">0</span>,</div><div class="line">                    binaryContent.length, <span class="keyword">new</span> CodeSource(codeBase, certificates));</div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedClassVersionError ucve) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedClassVersionError(</div><div class="line">                    ucve.getLocalizedMessage() + <span class="string">" "</span> +</div><div class="line">                    sm.getString(<span class="string">"webappClassLoader.wrongVersion"</span>,</div><div class="line">                            name));</div><div class="line">        &#125;</div><div class="line">        entry.loadedClass = clazz;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> clazz;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑还是比较简单的：</p>
<ol>
<li>从缓存中查找，若没有找到执行第2步，找到执行第4步；</li>
<li>判断class是否存在，不存在返回null，否则执行第3步；</li>
<li>创建一个entry，添加到resourceEntries中；</li>
<li>判断entry.loadedClass是否为空，为空返回null；</li>
<li>判断class是否存在，不存在返回null；</li>
<li>调用defineClass方法加载；</li>
<li>设置entry.loadedClass。</li>
</ol>
<p>本文中介绍了Tomcat类加载器有关的类和方法的介绍，下篇文章会介绍一下具体的使用过程以及Tomcat是如何加载每个Web应用中的类。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMX：Dynamic MBean]]></title>
      <url>http://www.ideabuffer.cn/2016/12/21/JMX%EF%BC%9ADynamic-MBean/</url>
      <content type="html"><![CDATA[<p>Dynamic MBean不需要自定义MBean接口，只需要实现DynamicMBean接口即可，Dynamic MBean没有任何明显些在代码里的属性和方法，所有的属性和方法都是通过反射结合JMX提供的辅助元数据从而动态生成。换句话说，它可以使用动态的配置来实现一个类中的哪些方法或者属性可以被注册到jmx去管理。</p>
<p>下面实现一个具体的代码，其中主要涉及3个类，分别是Hello,HelloDynamic和HelloAgent。其中Hello是一个普通的JavaBean，可以看做实际被管理的bean；HelloDynamic是一个动态的MBean，通过它来代理Hello类型的JavaBean，对其暴露一些需要被管理的属性和方法；HelloAgent中有main方法，用于启动。这里同样使用了<code>HtmlAdaptorServer</code>来通过浏览器查看和管理MBean。</p>
<a id="more"></a>
<p>下面看一下Hello类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name = <span class="string">"Hello World"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很普通，没必要说了，再看一下HelloDynamic类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDynamic</span> <span class="keyword">implements</span> <span class="title">DynamicMBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Hello hello = <span class="keyword">new</span> Hello();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;MBeanAttributeInfo&gt; attributeInfos = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;MBeanConstructorInfo&gt; constructorInfos = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;MBeanOperationInfo&gt; operationInfos = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;MBeanNotificationInfo&gt; notificationInfos = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MBeanInfo mBeanInfo;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDynamic</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            init();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</div><div class="line">        buildDynamicInfo();</div><div class="line">        mBeanInfo = createMBeanInfo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建需要被管理的构造器、属性和方法</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> NoSuchMethodException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildDynamicInfo</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</div><div class="line">        constructorInfos.add(<span class="keyword">new</span> MBeanConstructorInfo(<span class="string">"Hello构造器"</span>, hello.getClass().getConstructors()[<span class="number">0</span>]));</div><div class="line">        attributeInfos.add(<span class="keyword">new</span> MBeanAttributeInfo(<span class="string">"name"</span>, <span class="string">"java.lang.String"</span>, <span class="string">"name属性"</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>));</div><div class="line">        operationInfos.add(<span class="keyword">new</span> MBeanOperationInfo(<span class="string">"print()方法."</span>, hello.getClass().getMethod(<span class="string">"print"</span>, <span class="keyword">null</span>)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建MBeanInfo对象</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> MBeanInfo <span class="title">createMBeanInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MBeanInfo(<span class="keyword">this</span>.getClass().getName(),</div><div class="line">                <span class="string">"HelloDynamic"</span>,</div><div class="line">                attributeInfos.toArray(<span class="keyword">new</span> MBeanAttributeInfo[attributeInfos.size()]),</div><div class="line">                constructorInfos.toArray(<span class="keyword">new</span> MBeanConstructorInfo[constructorInfos.size()]),</div><div class="line">                operationInfos.toArray(<span class="keyword">new</span> MBeanOperationInfo[operationInfos.size()]),</div><div class="line">                notificationInfos.toArray(<span class="keyword">new</span> MBeanNotificationInfo[notificationInfos.size()])</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String attribute)</span> <span class="keyword">throws</span> AttributeNotFoundException, MBeanException, ReflectionException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> PropertyUtils.getProperty(hello, attribute);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(Attribute attribute)</span> <span class="keyword">throws</span> AttributeNotFoundException, InvalidAttributeValueException, MBeanException, ReflectionException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            PropertyUtils.setProperty(hello, attribute.getName(), attribute.getValue());</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AttributeList <span class="title">getAttributes</span><span class="params">(String[] attributes)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (attributes == <span class="keyword">null</span> || attributes.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            AttributeList attrList = <span class="keyword">new</span> AttributeList();</div><div class="line">            <span class="keyword">for</span> (String attrName : attributes) &#123;</div><div class="line">                Object obj = <span class="keyword">this</span>.getAttribute(attrName);</div><div class="line">                Attribute attribute = <span class="keyword">new</span> Attribute(attrName, obj);</div><div class="line">                attrList.add(attribute);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> attrList;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AttributeList <span class="title">setAttributes</span><span class="params">(AttributeList attributes)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (attributes == <span class="keyword">null</span> || attributes.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> attributes;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (Object attribute1 : attributes) &#123;</div><div class="line">                Attribute attribute = (Attribute) attribute1;</div><div class="line">                setAttribute(attribute);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> attributes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(String actionName, Object[] params, String[] signature)</span> <span class="keyword">throws</span> MBeanException, ReflectionException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Method methods[] = hello.getClass().getMethods();</div><div class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">                String name = method.getName();</div><div class="line">                <span class="keyword">if</span> (name.equals(actionName)) &#123;</div><div class="line">                    Object result = method.invoke(hello, params);</div><div class="line">                    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">                        System.out.println(result);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MBeanInfo <span class="title">getMBeanInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mBeanInfo;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里实现了<code>DynamicMBean</code>接口，可见该类中的方法都是通过反射来工作的，这样就可以理解为什么叫做Dynamic MBean了，利用反射可以动态的增加或删除属性和方法。</p>
<p>HelloAgent类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAgent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedObjectNameException, NotCompliantMBeanException, InstanceAlreadyExistsException, MBeanRegistrationException </span>&#123;</div><div class="line">        String domain = <span class="string">"DynamicTest"</span>;</div><div class="line">        MBeanServer server = MBeanServerFactory.createMBeanServer();</div><div class="line">        <span class="comment">//创建DynamicMBean对象</span></div><div class="line">        HelloDynamic helloDynamic = <span class="keyword">new</span> HelloDynamic();</div><div class="line"></div><div class="line">        HtmlAdaptorServer htmlAdaptorServer = <span class="keyword">new</span> HtmlAdaptorServer();</div><div class="line">        htmlAdaptorServer.setPort(<span class="number">9999</span>);</div><div class="line">        ObjectName objName = <span class="keyword">new</span> ObjectName(domain + <span class="string">":name=HelloDynamic"</span>);</div><div class="line">        ObjectName htmlObjName = <span class="keyword">new</span> ObjectName(domain + <span class="string">":name=HtmlAdaptor"</span>);</div><div class="line">        <span class="comment">// 注册MBean</span></div><div class="line">        server.registerMBean(helloDynamic, objName);</div><div class="line">        <span class="comment">// 注册adaptor</span></div><div class="line">        server.registerMBean(htmlAdaptorServer, htmlObjName);</div><div class="line">        <span class="comment">//启动服务</span></div><div class="line">        htmlAdaptorServer.start();</div><div class="line">        System.out.println(<span class="string">"starting..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果看过前两篇的JMX内容，那么可以看出，没什么不一样的地方，我们运行一下该程序，打开浏览器，输入<a href="http://localhost:9999" target="_blank" rel="external">http://localhost:9999</a> 查看：</p>
<img src="/2016/12/21/JMX：Dynamic-MBean/QQ20161222-0@2x.png" alt="QQ20161222-0@2x.png" title="">
<p>点击<code>name=HelloDynamic</code>后，可以看到，Hello中的属性和方法已经被注册进来了：</p>
<img src="/2016/12/21/JMX：Dynamic-MBean/QQ20161222-0.png" alt="QQ20161222-0.png" title="">
<p>点击<code>print</code>按钮后，在控制台可以看到效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">starting...</div><div class="line">Hello World</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMX：Model MBean]]></title>
      <url>http://www.ideabuffer.cn/2016/12/21/JMX%EF%BC%9AModel-MBean/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMX：Notification]]></title>
      <url>http://www.ideabuffer.cn/2016/12/18/JMX%EF%BC%9ANotification/</url>
      <content type="html"><![CDATA[<h2 id="Notification介绍"><a href="#Notification介绍" class="headerlink" title="Notification介绍"></a>Notification介绍</h2><p>从前两篇文章可以知道，MBean提供的管理接口允许代理对其管理资源进行控制和配置。然而，对管理复杂的分布式系统来说，这些接口只是提供了一部分功能。一般来说，管理应用程序需要对管理的资源进行监控，以便发生一些行为或者状态变化时能够作出相应的反映。</p>
<p>Notification起到了MBean之间的沟通桥梁的作用。JMX Notification模型和Java Event模型类似，将一些重要的信息，状态的转变，数据的变更传递给Notification Listener，以便资源的管理。</p>
<p>JMX的Notification由四部分组成：</p>
<ul>
<li>Notification，一个通用的事件类型，该类标识事件的类型，可以被直接使用，也可以根据传递的事件的需要而被扩展。</li>
<li>NotificationListener，接收通知的对象需实现此接口。</li>
<li>NotificationFilter，作为通知过滤器的对象需实现此接口，为通知监听者提供了一个过滤通知的过滤器。</li>
<li>NotificationBroadcaster，通知发送者需实现此接口，该接口允许希望得到通知的监听者注册。</li>
</ul>
<a id="more"></a>
<h2 id="Notification实例"><a href="#Notification实例" class="headerlink" title="Notification实例"></a>Notification实例</h2><p>下面写一个具体的例子来演示一下Notification的使用。</p>
<p>假设Jack要与Rose打招呼，Jack会先开口，说”Hello Rose!”，而Rose会听到，下面看一下Jack的MBean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JackMBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有一个<code>sayHello</code>方法，看一下它的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jack</span> <span class="keyword">extends</span> <span class="title">NotificationBroadcasterSupport</span> <span class="keyword">implements</span> <span class="title">JackMBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Jack said : Hello Rose!"</span>);</div><div class="line">        Notification notification = <span class="keyword">new</span> Notification(</div><div class="line">                <span class="string">"jack"</span>,  <span class="comment">// 类型</span></div><div class="line">                <span class="keyword">this</span>, <span class="comment">// 发送通知的源</span></div><div class="line">                <span class="number">1</span>, <span class="comment">// 序号</span></div><div class="line">                System.currentTimeMillis(), <span class="comment">// 时间戳</span></div><div class="line">                <span class="string">"Hello Rose!"</span> <span class="comment">// 消息内容</span></div><div class="line">        );</div><div class="line">        <span class="keyword">super</span>.sendNotification(notification);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Jack在打完招呼后创建了一个<code>Notification</code>对象用来传递一个通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoseMBean</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heard</span><span class="params">( String message)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Rose的MBean只有一个<code>heard</code>方法来显示听到的内容，实现类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rose</span> <span class="keyword">implements</span> <span class="title">RoseMBean</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heard</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Rose heard : "</span> + message);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简单，下面创建一个<code>NotificationListener</code>，作用是在接收到<code>sayHello</code>方法中传递的通知后应该做什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JackListener</span> <span class="keyword">implements</span> <span class="title">NotificationListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNotification</span><span class="params">(Notification notification, Object handback)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Type="</span> + notification.getType());</div><div class="line">        System.out.println(<span class="string">"Source="</span> + notification.getSource());</div><div class="line">        System.out.println(<span class="string">"Seq="</span> + notification.getSequenceNumber());</div><div class="line">        System.out.println(<span class="string">"send time="</span> + notification.getTimeStamp());</div><div class="line">        System.out.println(<span class="string">"message="</span> + notification.getMessage());</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (handback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (handback <span class="keyword">instanceof</span> Rose) &#123;</div><div class="line">                Rose rose = (Rose) handback;</div><div class="line">                rose.heard(notification.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>handleNotification</code>方法先打印了通知的信息，然后调用rose的<code>heard</code>方法。将各个MBean注册到<code>MBeanServer</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAgent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedObjectNameException, NotCompliantMBeanException, InstanceAlreadyExistsException, MBeanRegistrationException </span>&#123;</div><div class="line">        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();</div><div class="line">        ObjectName jackName = <span class="keyword">new</span> ObjectName(<span class="string">"TestMBean:name=Jack"</span>);</div><div class="line">        Jack jack = <span class="keyword">new</span> Jack();</div><div class="line">        mBeanServer.registerMBean(jack, jackName);</div><div class="line"></div><div class="line">        ObjectName adapterName = <span class="keyword">new</span> ObjectName(<span class="string">"TestMBean:name=htmladapter,port=9999"</span>);</div><div class="line">        HtmlAdaptorServer adapter = <span class="keyword">new</span> HtmlAdaptorServer();</div><div class="line">        adapter.setPort(<span class="number">9999</span>);</div><div class="line">        mBeanServer.registerMBean(adapter,adapterName);</div><div class="line"></div><div class="line">        Rose rose = <span class="keyword">new</span> Rose();</div><div class="line">        ObjectName roseName = <span class="keyword">new</span> ObjectName(<span class="string">"TestMBean:name=Rose"</span>);</div><div class="line">        mBeanServer.registerMBean(rose, roseName);</div><div class="line"></div><div class="line"></div><div class="line">        jack.addNotificationListener(<span class="keyword">new</span> JackListener(), <span class="keyword">null</span>, rose);</div><div class="line"></div><div class="line">        adapter.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后，在浏览器中输入<a href="http://localhost:9999，查看：" target="_blank" rel="external">http://localhost:9999，查看：</a></p>
<img src="/2016/12/18/JMX：Notification/QQ20161218-0.png" alt="QQ20161218-0.png" title="">
<p>点击<code>name=Java</code></p>
<img src="/2016/12/18/JMX：Notification/QQ20161218-1.png" alt="QQ20161218-1.png" title="">
<p>再点击<code>sayHello</code>按钮，查看控制台，会输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Jack said : Hello Rose!</div><div class="line">Type=jack</div><div class="line">Source=cn.ideabuffer.jmx.notification.Jack@3a43df66</div><div class="line">Seq=1</div><div class="line">send time=1482050137393</div><div class="line">message=Hello Rose!</div><div class="line">Rose heard : Hello Rose!</div></pre></td></tr></table></figure>
<h2 id="Notification的实现"><a href="#Notification的实现" class="headerlink" title="Notification的实现"></a>Notification的实现</h2><p>下面可以看一下具体的源代码来了解一下Notification工作的流程。</p>
<p>在<code>Jack</code>类中调用了<code>super.sendNotification(notification);</code>后，会执行<code>NotificationBroadcasterSupport</code>类中的<code>sendNotification</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotification</span><span class="params">(Notification notification)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (notification == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> enabled;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (ListenerInfo li : listenerList) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            enabled = li.filter == <span class="keyword">null</span> ||</div><div class="line">                li.filter.isNotificationEnabled(notification);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">if</span> (logger.debugOn()) &#123;</div><div class="line">                logger.debug(<span class="string">"sendNotification"</span>, e);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (enabled) &#123;</div><div class="line">            executor.execute(<span class="keyword">new</span> SendNotifJob(notification, li));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，就是遍历所有注册的listener，然后把notification和listener封装成一个<code>SendNotifJob</code>对象，在线程池中执行，看一下<code>SendNotifJob</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SendNotifJob</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SendNotifJob</span><span class="params">(Notification notif, ListenerInfo listenerInfo)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.notif = notif;</div><div class="line">        <span class="keyword">this</span>.listenerInfo = listenerInfo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            handleNotification(listenerInfo.listener,</div><div class="line">                               notif, listenerInfo.handback);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">if</span> (logger.debugOn()) &#123;</div><div class="line">                logger.debug(<span class="string">"SendNotifJob-run"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Notification notif;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListenerInfo listenerInfo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该类实现了<code>Runnable</code>接口，在<code>run</code>方法中，调用<code>handleNotification</code>方法，看一下该方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleNotification</span><span class="params">(NotificationListener listener,</span></span></div><div class="line">                                      Notification notif, Object handback) &#123;</div><div class="line">    listener.handleNotification(notif, handback);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里调用了listener的<code>handleNotification</code>方法，在<code>JackListener</code>中实现的就是该方法。下面是<code>NotificationListener</code>接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NotificationListener</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">EventListener</span>   </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNotification</span><span class="params">(Notification notification, Object handback)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该接口只有一个方法，同时<code>NotificationListener</code>继承自<code>java.util.EventListener</code>，这个接口并没有任何方法的定义，仅仅代表一种类型。</p>
<p>看到这就应该很好理解了，这就是观察者模式的实现，不熟悉的话可以参考一下之前的文章：<a href="/2016/12/04/设计模式：观察者模式/">设计模式：观察者模式</a>，其实还有一个更具体的例子，参考<a href="/2016/12/05/Tomcat源码：生命周期/">Tomcat源码：生命周期</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMX：Standard MBean]]></title>
      <url>http://www.ideabuffer.cn/2016/12/14/JMX%EF%BC%9AStandard-MBean/</url>
      <content type="html"><![CDATA[<p>Standard MBean（标准管理构件）是JMX管理构件中最简单的一种，只需要开发一个MBean接口，一个实现MBean接口的类，并且把他们注册到MBeanServer中就可以了。</p>
<p>下面例子使用的是Java8，其中已经包含了jmx。该例中使用了<code>HtmlAdaptorServer</code>类，需要用到jmxtools.jar, 可以到 <a href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-java-plat-419418.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-java-plat-419418.html</a> 下载，下载后的文件是jmx-1_2_1-ri.zip，解压后将jmxtools.jar导入到项目中即可。</p>
<a id="more"></a>
<h2 id="Standard-MBean实例"><a href="#Standard-MBean实例" class="headerlink" title="Standard MBean实例"></a>Standard MBean实例</h2><p>首先定义一个MBean的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloMBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>包含在MBean中方法都将是可以被管理的。MBean起名是有规范的，后缀必须是MBean，否则会报错。</p>
<p>再创建一个要被管理的类<code>Hello</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">HelloMBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello : "</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该类有一个<code>name</code>属性，实现了<code>sayHello</code>方法用来输出<code>name</code>属性。</p>
<p>再创建一个Agent类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAgent</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="comment">// 以下两种创建MBeanServer的方式都可以，但第一种不可以通过JConsole来查看</span></div><div class="line"><span class="comment">//        MBeanServer mBeanServer = MBeanServerFactory.createMBeanServer();</span></div><div class="line">        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();</div><div class="line">        </div><div class="line">        <span class="comment">// 使用默认的domain</span></div><div class="line">        String domain = mBeanServer.getDefaultDomain();</div><div class="line">        ObjectName objectName = <span class="keyword">new</span> ObjectName(domain+ <span class="string">":name=Hello"</span>);</div><div class="line">        <span class="comment">// 注册到mBeanServer中</span></div><div class="line">        mBeanServer.registerMBean(<span class="keyword">new</span> Hello(), objectName);</div><div class="line"></div><div class="line">        <span class="comment">// 这里的port只不过是一个名字，取什么都无所谓</span></div><div class="line">        ObjectName adapterName = <span class="keyword">new</span> ObjectName(domain +</div><div class="line">                <span class="string">":name=htmladapter,port=8888"</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 创建一个AdaptorServer，这个类将决定MBean的管理界面</span></div><div class="line">        <span class="comment">// HtmlAdaptorServer属于分布服务层, 提供了一个HtmlAdaptor</span></div><div class="line">        <span class="comment">// 支持Http访问协议，并且有一个HTML的管理界面</span></div><div class="line">        <span class="comment">// HtmlAdaptor是一个简单的HttpServer，它将Http请求转换为JMX Agent的请求</span></div><div class="line">        HtmlAdaptorServer adapter = <span class="keyword">new</span> HtmlAdaptorServer();</div><div class="line">        <span class="comment">// 设置访问的端口</span></div><div class="line">        adapter.setPort(<span class="number">8888</span>);</div><div class="line">        adapter.start();</div><div class="line">        mBeanServer.registerMBean(adapter, adapterName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ObjectName介绍"><a href="#ObjectName介绍" class="headerlink" title="ObjectName介绍"></a>ObjectName介绍</h2><p>其中介绍一下<code>ObjectName</code>，这个类的实例表示一个MBean的对象名，下面的内容参考自JDK文档：</p>
<blockquote>
<p>表示 MBean 的对象名，或者能够与多个 MBean 名称相匹配的模式。此类的实例是不可变的。</p>
<p>可使用此类的实例表示：</p>
<ul>
<li>对象名</li>
<li>查询的上下文中的对象名模式</li>
</ul>
<p>由两部分（域和键属性）组成的对象名。</p>
<p><em>域</em> 是一个不包括冒号字符 (:) 的由字符组成的字符串。建议域不要包含字符串 “//“，该字符串保留供将来使用。</p>
<p>如果域至少包括一个通配符星号 (*) 或问号 (?)，则该对象名就是一个模式。星号匹配任意零或多个字符的序列，而问号则匹配任意单个字符。</p>
<p>如果域为空，则由 MBean 服务器（在其中使用 ObjectName）的默认域 在特定的上下文中替换它。</p>
<p><em>键</em>属性 是一个无序的键和关联值的集合。</p>
<p>每个<em>键</em> 都是一个由字符组成的非空字符串，不可以包含任何逗号 (,)、等号 (=)、冒号、星号或问号字符。在一个给定的 ObjectName 中，同一个键不能出现两次。</p>
<p>每个与键关联的值 都是由字符组成的字符串，或者由引号括起来或者不括起来。</p>
<p>无引号值 可能是一个空的字符串，不包含任意逗号、等号、冒号和引号。</p>
<p>如果无引号值 包括至少一个通配符星号或问号，则该对象名就是一个属性值模式。</p>
<p>有引号值 由一个引号 (“)，后跟可能为空的字符串，然后是另一个引号所组成。在字符串中，反斜线 () 具有特殊的含义，它后面必须是下列某个字符：</p>
<ul>
<li>另一个反斜线。第二个反斜线不具有特殊的含义，两个字符表示单个反斜线。</li>
<li>字符 ‘n’。这两个字符表示新行（Java 中的 ‘\n’）。</li>
<li>引号。这两个字符表示一个引号，并且不将该引号视为有引号值的终止。为了使有引号值有效，必须有结束的闭合引号。</li>
<li>问号 (?) 或星号 (*)。这两个字符分别表示一个问号或一个星号。<br>引号可能不出现在有引号值中，但紧跟在奇数个连续反斜线后的情况除外。</li>
</ul>
<p>括住有引号值的引号和该值中的所有反斜线都被视为该值的一部分。</p>
<p>如果<em>引号值</em> 包括至少一个星号或问号，且星号或问号之前没有反斜杠，则将其视为通配符，并且该对象名是一个属性值模式。星号匹配任意零或多个字符的序列，而问号则匹配任意单个字符。</p>
<p>ObjectName 可能是一种<em>属性列表模式</em>。在这种情况下，它可以有零个或多个键和关联值。它与非模式的 ObjectName 匹配，该 ObjectName 的域与相同的键和关联值匹配且包含它们，并且可能包括其他键和值。</p>
<p>当至少有一个 ObjectName 的有引号 或无引号 键属性值包含通配符星号或问号（如上所述）时，ObjectName 是一个属性值模式。在这种情况下，它有一个或多个键以及关联值，并至少有一个值包含通配符。它与一个无模式 ObjectName 相匹配，该 ObjectName 的域与之匹配，或者包含值与之匹配的相同键；如果属性值模式也是属性列表模式，则无模式 ObjectName 也可以包含其他键和值。</p>
<p>如果 ObjectName 是属性列表模式 或属性值模式，或者两者都是，则它是一个属性模式。</p>
<p>如果某个 ObjectName 的域包含通配符或者 ObjectName 是一个属性模式，则该 ObjectName 是一个模式。</p>
<p>如果某个 ObjectName 不是一个模式，那么它必须至少包含一个键及其关联值。</p>
<p>ObjectName 模式的示例有：</p>
<ul>
<li>*:type=Foo,name=Bar 匹配键的具体设置为 type=Foo,name=Bar 的任何域中的名称。<br>d:type=Foo,name=Bar,* 匹配具有键 type=Foo,name=Bar 以及 0 或其他键的域 d 中的名称。</li>
<li>*:type=Foo,name=Bar,* 匹配具有键 type=Foo,name=Bar 以及 0 或其他键的域中的名称。</li>
<li>d:type=F?o,name=Bar 将与诸如 d:type=Foo,name=Bar 和 d:type=Fro,name=Bar 之类的键和名称匹配。</li>
<li>d:type=F*o,name=Bar 将与诸如 d:type=Fo,name=Bar 和 d:type=Frodo,name=Bar 之类的键和名称匹配。</li>
<li>d:type=Foo,name=”B*“ 将与诸如 d:type=Foo,name=”Bling” 之类的键和名称匹配。通配符在引号中也能被识别，并且像其他特殊字符一样可以使用 \ 转义。</li>
</ul>
<p>按顺序使用下列元素可将 ObjectName 写为 String：</p>
<ul>
<li>域。</li>
<li>一个冒号 (:)。</li>
<li>如下定义的键属性列表。<br>写为 String 的键属性列表是一个逗号分隔的元素列表。每个元素都是一个星号或一个键属性。键属性由键、等号 (=) 和关联值组成。</li>
</ul>
<p>键属性列表中最多只能有一个元素为星号。如果键属性列表包含星号元素，则该 ObjectName 是一个属性列表模式。</p>
<p>在表示 ObjectName 的 String 中，空格没有任何特殊含意。例如，String：</p>
<p>domain: key1 = value1 , key2 = value2</p>
<p>表示具有两个键的 ObjectName。每个键的名字包含 6 个字符，其中第一个和最后一个都是空格。与键 “ key1 “ 相关联的值同样以空格开头和结尾。</p>
<p>除了上述提及的字符限制外，ObjectName 的任何部分都不能包含换行符 (‘\n’)，无论这些部分是域、键还是值（无引号值和有引号值）。可使用序列 \n 将换行符表示为有引号值。</p>
<p>不管使用何种构造方法构建 ObjectName，关于特殊字符和引号的规则都适用。</p>
<p>为了避免不同供应商所提供的 MBean 之间出现冲突，提供了一个有用的约定：域名由指定该 MBean 的企业的反向 DNS 名开始，后跟一个句点和一个字符串，由该企业决定该字符串的解释。例如，由 Sun Microsystems Inc.（DNS 名是 sun.com）所指定的 MBean 将有 com.sun.MyDomain 这样的域。这基本上与 Java 语言包名的约定相同。</p>
</blockquote>
<h2 id="使用HtmlAdaptorServer查看MBean"><a href="#使用HtmlAdaptorServer查看MBean" class="headerlink" title="使用HtmlAdaptorServer查看MBean"></a>使用HtmlAdaptorServer查看MBean</h2><p>下面运行一下该程序，访问<a href="http://localhost:8888来查看一下：" target="_blank" rel="external">http://localhost:8888来查看一下：</a></p>
<img src="/2016/12/14/JMX：Standard-MBean/屏幕快照%202016-12-14%20下午11.50.40.png" alt="屏幕快照 2016-12-14 下午11.50.40.png" title="">
<p>可以看到在默认域名下注册的“name=Hello”，点进去后可以看到MBean中的属性和方法：</p>
<img src="/2016/12/14/JMX：Standard-MBean/屏幕快照%202016-12-14%20下午11.37.23.png" alt="屏幕快照 2016-12-14 下午11.37.23.png" title="">
<p>可以看到，在<code>Access</code>列中的值是<code>RW</code>，说明是可读写的，因为在<code>HelloMBean</code>接口中定义了<code>setName</code>和<code>getName</code>方法，如果只定义了<code>getName</code>方法，<code>Access</code>的值将会是<code>RO</code>，表示是只读的。在<code>Name</code>列中的值是<code>Name</code>，这个是和getter和setter方法对应的，并不与定义的<code>name</code>属性对应。在<code>Value</code>列中可以修改<code>Name</code>的值，然后点击<code>Apply</code>按钮后，就可以将属性的值设置到MBean当中。</p>
<p>在下面的operations中，可以看到之前定义的<code>sayHello</code>方法，点击这个按钮后，可以在控制台上查看输出的结果。例如，将<code>Name</code>的值设置为123，点击<code>Apply</code>按钮，然后点击<code>sayHello</code>按钮，页面显示：</p>
<img src="/2016/12/14/JMX：Standard-MBean/屏幕快照%202016-12-14%20下午11.46.53.png" alt="屏幕快照 2016-12-14 下午11.46.53.png" title="">
<p>在控制台中可以看到输出的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello : 123</div></pre></td></tr></table></figure>
<h2 id="使用jconsole查看MBean"><a href="#使用jconsole查看MBean" class="headerlink" title="使用jconsole查看MBean"></a>使用jconsole查看MBean</h2><p>还可以通过<code>jconsole</code>来查看MBean，可以通过<code>jconsole</code>作为客户端来管理MBean。</p>
<p>将本例中的<code>HelloAgent</code>中的代码修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();</div><div class="line"><span class="comment">//        MBeanServer mBeanServer = MBeanServerFactory.createMBeanServer();</span></div><div class="line">    String domain = mBeanServer.getDefaultDomain();</div><div class="line">    ObjectName objectName = <span class="keyword">new</span> ObjectName(domain+ <span class="string">":name=Hello"</span>);</div><div class="line">    mBeanServer.registerMBean(<span class="keyword">new</span> Hello(), objectName);</div><div class="line"></div><div class="line">    ObjectName adapterName = <span class="keyword">new</span> ObjectName(domain +</div><div class="line">            <span class="string">":name=htmladapter,port=8888"</span>);</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"start....."</span>);</div><div class="line"></div><div class="line">    Thread.sleep(Integer.MAX_VALUE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进入命令行，输入<code>jconsole</code>命令打开jsonsole：</p>
<img src="/2016/12/14/JMX：Standard-MBean/屏幕快照%202016-12-15%20上午12.03.56.png" alt="屏幕快照 2016-12-15 上午12.03.56.png" title="">
<p>选中本例运行的进程后点击“连接”，进入管理页面，选择”MBean”标签：</p>
<img src="/2016/12/14/JMX：Standard-MBean/屏幕快照%202016-12-15%20上午12.05.36.png" alt="屏幕快照 2016-12-15 上午12.05.36.png" title="">
<p>在这里可以看到注册的MBean，可以看到在<code>Hello</code>这个MBean中的属性和操作，这里的使用与<code>HtmlAdaptorServer</code>的使用类似，大家可以自己试一下。在这里将属性的值设置为123，然后在“操作”中点击<code>sayHello</code>按钮：</p>
<img src="/2016/12/14/JMX：Standard-MBean/屏幕快照%202016-12-15%20上午12.09.16.png" alt="屏幕快照 2016-12-15 上午12.09.16.png" title="">
<p>在控制台同样可以看到输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello : 123</div></pre></td></tr></table></figure>
<p>jconsole还可以通过远程来连接，很轻松的来管理MBean。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JMX架构简介]]></title>
      <url>http://www.ideabuffer.cn/2016/12/14/JMX%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h2 id="JMX简单介绍"><a href="#JMX简单介绍" class="headerlink" title="JMX简单介绍"></a>JMX简单介绍</h2><p>Java管理扩展JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理。<br>JMX是一种应用编程接口，可扩充对象和方法的集合体，可以用于跨越一系列不同的异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用它提供了用户界面指导、Java类和开发集成系统、网络及网络管理应用的规范。</p>
<p>管理对象是JMX应用程序的核心。JMX结构包括：支持Java的Web浏览器用户接口，管理运行模块ARM(Admin Runtime Module)和应用。这三个部件之间通过RMI（Remote Method Invocation）进行通信。这里需要说明的是，RMI是使得一个Java虚拟机（JVM）上运行的程序可以调用远程服务器上另一个JVM总的对象。</p>
<h2 id="Java管理扩展JMX的体系结构"><a href="#Java管理扩展JMX的体系结构" class="headerlink" title="Java管理扩展JMX的体系结构"></a>Java管理扩展JMX的体系结构</h2><p>JMX框架如下图所示：</p>
<img src="/2016/12/14/JMX架构简介/CIlaw2Y.png" alt="CIlaw2Y.png" title="">
<a id="more"></a>
<h3 id="设备层（Instrumentation-Level）"><a href="#设备层（Instrumentation-Level）" class="headerlink" title="设备层（Instrumentation Level）"></a>设备层（Instrumentation Level）</h3><p>主要定义了信息模型。在JMX中，各种管理对象以管理构件的形式存在，需要管理时，向MBean服务器进行注册。该层还定义了通知机制以及一些辅助元数据类。</p>
<p>设备层其实就是和被管设备通信的模块，对于上层的管理者来说，Instrumentation 就是设备，具体设备如何通信，是采用SNMP,还是采用ICMP，是MBean的事情。在网管系统中，把系统的各种服务，例如拓扑发现，用户管理等等都作为一个MBean,作为一个被管理的单元。</p>
<p>该层定义了如何实现JMX管理资源的规范。一个JMX管理资源可以是一个Java应用、一个服务或一个设备，它们可以用Java开发，或者至少能用Java进行包装，并且能被置入JMX框架中，从而成为JMX的一个管理构件(Managed Bean)，简称MBean。管理构件可以是标准的，也可以是动态的，标准的管理构件遵从JavaBeans构件的设计模式；动态的管理构件遵从特定的接口，提供了更大的灵活性。感觉管理构件应该翻译为被管理构件才好。该层还定义了通知机制以及实现管理构件的辅助元数据类（元数据类就是构成一个MBean的各种元素：属性、方法等等）。</p>
<p>在JMX规范中，管理构件定义如下：它是一个能代表管理资源的Java对象，遵从一定的设计模式，还需实现该规范定义的特定的接口。该定义了保证了所有的管理构件以一种标准的方式来表示被管理资源。<br>管理接口就是被管理资源暴露出的一些信息，通过对这些信息的修改就能控制被管理资源。一个管理构件的管理接口包括： </p>
<ul>
<li>能被接触的属性值； </li>
<li>能够执行的操作； </li>
<li>能发出的通知事件； </li>
<li>管理构件的构建器。</li>
</ul>
<p>管理构件通过公共的方法以及遵从特定的设计模式封装了属性和操作，以便暴露给管理应用程序。例如，一个只读属性在管理构件中只有Get方法，既有Get又有Set方法表示是一个可读写的属性。<br>其余的JMX的构件，例如JMX代理提供的各种服务，也是作为一个管理构件注册到代理中才能提供相应的服务。</p>
<p>JMX对管理构件的存储位置没有任何限制，管理构件可以存储在运行JMX代理的Java虚拟机的类路径的任何位置，也可以从网络上的任何位置导入。</p>
<p>JMX定义了四种管理构件（MBean）：标准、动态、开放和模型管理构件。每一种管理构件可以根据不同的环境需要进行制定。</p>
<h4 id="标准管理构件"><a href="#标准管理构件" class="headerlink" title="标准管理构件"></a>标准管理构件</h4><p>标准管理构件的设计和实现是最简单的，它们的管理接口通过方法名来描述。标准管理构件的实现依靠一组命名规则，称之为设计模式。这些命名规则定义了属性和操作。</p>
<p>检查标准管理构件接口和应用设计模式的过程被称为内省（Introspection）。JMX代理通过内省来查看每一个注册在MBean 服务器上的管理构件的方法和超类，看它是否遵从一定设计模式，决定它是否代表了一个管理构件，并辨认出它的属性和操作。</p>
<h4 id="动态管理构件"><a href="#动态管理构件" class="headerlink" title="动态管理构件"></a>动态管理构件</h4><p>动态管理构件提供了更大的灵活性，它可以在运行期暴露自己的管理接口。它的实现是通过实现一个特定的接口DynamicMBean。</p>
<p>JMX代理通过getMBeanInfo方法来获取该动态管理构件暴露的管理接口，该方法返回的对象是MbeanInfo类的实例，包含了属性和操作的签名。由于该方法的调用是发生在动态管理构件向MBean服务器注册以后，因此管理接口是在运行期获取的。不同于标准管理构件，JMX代理不需要通过内省机制来确定动态管理构件的管理接口。由于DynamicMBean的接口是不变的，因此可以屏蔽实现细节。由于这种在运行期获取管理接口的特性，动态管理构件提供了更大的灵活性。</p>
<h4 id="开放管理构件"><a href="#开放管理构件" class="headerlink" title="开放管理构件"></a>开放管理构件</h4><p>开放管理构件是一种专门化的动态管理构件，其中所有的与该管理构件相关的参数、返回类型和属性都围绕一组预定义的数据类型（String、Integer、Float 等）来建立，并且通过一组特定的接口来进行自我描述。JMX代理通过获得一个OpenMBeanInfo对象来获取开放管理构件的管理接口，OpenMBeanInfo是MbeanInfo的子类。</p>
<h4 id="模型管理构件"><a href="#模型管理构件" class="headerlink" title="模型管理构件"></a>模型管理构件</h4><p>模型管理构件也是一种专门化的动态管理构件。它是预制的、通用的和动态的 MBean 类，已经包含了所有必要缺省行为的实现，并允许在运行时添加或覆盖需要定制的那些实现。JMX规范规定该类必须实现为<code>javax.management.modelmbean.RequiredModelMBean</code>，管理者要做的就是实例化该类，并配置该构件的默认行为并注册到JMX代理中，即可实现对资源的管理。JMX代理通过获得一个ModelMBeanInfo对象来获取管理接口。</p>
<p>模型管理构件具有以下新的特点： </p>
<ul>
<li>持久性：定义了持久机制，可以利用Java的序列化或JDBC来存储模型MBean的状态。 就是要保存到硬盘上。</li>
<li>通知和日志功能：能记录每一个发出的通知，并能自动发出属性变化通知。 </li>
<li>属性值缓存：具有缓存属性值的能力。</li>
</ul>
<h4 id="通知模型"><a href="#通知模型" class="headerlink" title="通知模型"></a>通知模型</h4><p>一个管理构件提供的管理接口允许代理对其管理资源进行控制和配置。然而，对管理复杂的分布式系统来说，这些接口只是提供了一部分功能。通常，管理应用程序需要对状态变化或者当特别情况发生变化时作出反映。</p>
<p>为此，JMX定义了通知模型。通知模型仅仅涉及了在同一个JMX代理中的管理构件之间的事件传播。JMX通知模型依靠以下几个部分： </p>
<ul>
<li>Notification，一个通用的事件类型，该类标识事件的类型，可以被直接使用，也可以根据传递的事件的需要而被扩展。 </li>
<li>NotificationListener接口，接受通知的对象需实现此接口。 </li>
<li>NotificationFilter接口，作为通知过滤器的对象需实现此接口，为通知监听者提供了一个过滤通知的过滤器。 </li>
<li>NotificationBroadcaster接口，通知发送者需实现此接口，该接口允许希望得到通知的监听者注册。<br>发送一个通用类型的通知，任何一个监听者都会得到该通知。因此，监听者需提供过滤器来选择所需要接受的通知。</li>
</ul>
<p>任何类型的管理构件，标准的或动态的，都可以作为一个通知发送者，也可以作为一个通知监听者，或两者都是。</p>
<h4 id="辅助元数据"><a href="#辅助元数据" class="headerlink" title="辅助元数据"></a>辅助元数据</h4><p>辅助元数据类用来描述管理构件。辅助元数据类不仅被用来内省标准管理构件，也被动态管理构件用来进行自我描述。这些类根据属性、操作、构建器和通告描述了管理接口。JMX代理通过这些元数据类管理所有管理构件，而不管这些管理构件的类型。<br>部分辅助元类如下： </p>
<ul>
<li>MBeanInfo：包含了属性、操作、构建器和通知的信息。 </li>
<li>MBeanFeatureInfo：为下面类的超类。 </li>
<li>MBeanAttributeInfo：用来描述管理构件中的属性。 </li>
<li>MBeanConstructorInfo：用来描述管理构件中的构建器。 </li>
<li>MBeanOperationInfo：用来描述管理构件中的操作。 </li>
<li>MBeanParameterInfo：用来描述管理构件操作或构建器的参数。 </li>
<li>MBeanNotificationInfo：用来描述管理构件发出的通知。 </li>
</ul>
<h3 id="代理层（Agent-Level）"><a href="#代理层（Agent-Level）" class="headerlink" title="代理层（Agent Level）"></a>代理层（Agent Level）</h3><p>这里首先要理解的Agent和SNMP中的Agent不一样，SNMP中的Agent是设备上的一个程序，可以理解为被管理的设备。而JMX中的Agent并不是被管理的设备，而是进行管理设备（设备就是MBean）的一个程序，它对于JMX的上层来说，是一个被管理设备，针对下面的具体设备来说，它又是一个管理者。其实也就是MBeanServer。</p>
<p>主要定义了各种服务以及通信模型。该层的核心是一个MBean服务器，所有的管理构件都需要向它注册，才能被管理。注册在MBean服务器上管理构件并不直接和远程应用程序进行通信，它们通过协议适配器和连接器进行通信。而协议适配器和连接器也以管理构件的形式向MBean服务器注册才能提供相应的服务。这段话比较模糊，其实管理构件就是MBean，也可以看作是被管理的设备，其中说的管理构件并不和远程应用程序进行通信，就是说被管理的MBean不和控制台，也就是前台控制程序（web、服务器等）通信。</p>
<p>代理层是一个运行在Java虚拟机上的管理实体，它活跃在管理资源和管理者之间，用来直接管理资源，并使这些资源可以被远程的管理程序所控制。代理层由一个MBean服务器和一系列处理被管理资源的服务所组成。</p>
<h4 id="MBean服务器"><a href="#MBean服务器" class="headerlink" title="MBean服务器"></a>MBean服务器</h4><p>Mbean服务器为代理层的核心，设备层的所有管理构件都在其注册，管理者只用通过它才能访问管理构件。<br>管理构件可以通过以下三种方法实例化和注册： </p>
<ol>
<li>通过另一个管理构件 </li>
<li>管理代理本身 </li>
<li>远程应用程序</li>
</ol>
<p>注册一个管理构件时，必须提供一个唯一的对象名。管理应用程序用这个对象名进行标识管理构件并对其操作。这些操作包括：</p>
<ol>
<li>发现管理构件的管理接口 </li>
<li>读写属性值 </li>
<li>执行管理构件中定义的操作 </li>
<li>获得管理构件发出的通告 </li>
<li>基于对象名和属性值来查询管理构件</li>
</ol>
<h4 id="协议适配器和连接器"><a href="#协议适配器和连接器" class="headerlink" title="协议适配器和连接器"></a>协议适配器和连接器</h4><p>MBean服务器依赖于协议适配器和连接器来和运行该代理的Java虚拟机之外的管理应用程序进行通信。协议适配器通过特定的协议提供了一张注册在MBean服务器的管理构件的视图。例如，一个HTML适配器可以将所有注册过的管理构件显示在Web 页面上。不同的协议，提供不同的视图。</p>
<p>连接器还必须提供管理应用一方的接口以使代理和管理应用程序进行通信，即针对不同的协议，连接器必须提供同样的远程接口来封装通信过程。当远程应用程序使用这个接口时，就可以通过网络透明的和代理进行交互，而忽略协议本身。</p>
<p>适配器和连接器使MBean服务器与管理应用程序能进行通信。因此，一个代理要被管理，它必须提供至少一个协议适配器或者连接器。面临多种管理应用时，代理可以包含各种不同的协议适配器和连接器。</p>
<p>当前已经实现和将要实现的协议适配器和连接器包括： </p>
<ul>
<li>RMI连接器 </li>
<li>SNMP协议适配器 </li>
<li>IIOP协议适配器 </li>
<li>HTML协议适配器 </li>
<li>HTTP连接器</li>
</ul>
<h3 id="分布服务层（Distributed-Service-Level）"><a href="#分布服务层（Distributed-Service-Level）" class="headerlink" title="分布服务层（Distributed Service Level）"></a>分布服务层（Distributed Service Level）</h3><p>主要定义了能对代理层进行操作的管理接口和构件，这样管理者就可以操作代理。然而，当前的JMX规范并没有给出这一层的具体规范。</p>
<h3 id="附加管理协议API"><a href="#附加管理协议API" class="headerlink" title="附加管理协议API"></a>附加管理协议API</h3><p>定义的API主要用来支持当前已经存在的网络管理协议，如SNMP、TMN、CIM/WBEM等。</p>
<h2 id="JMX架构的使用场景及优点"><a href="#JMX架构的使用场景及优点" class="headerlink" title="JMX架构的使用场景及优点"></a>JMX架构的使用场景及优点</h2><p>JMX应该说是关于网络应用管理的的框架，如果你开发了一个比较复杂的系统，无疑你要提供这个系统的自身管理 系统，JMX更多应用是体现在Server上，如果你要使用java开发一个自己Server或复杂的应用系统，那么推荐你基于JMX架构来开发， JBoss 3.0 weblogic等就是基于JMX开发的符合J2EE规范的服务器软件。</p>
<p>了解JMX可以使你深入了解J2EE服务器， 为什么我们平时说 “EJB”是个比较”Weight”的方案选择，其中一个原因是J2EE服务器软件本身 也是你的系统中一部分，它作为你系统的容器，对你的系统有至关重要的作用，如果无法直接介入 管理或“调教”它，那么无疑你的系统本身存在着隐含的危险， 现在，通过JMX，你现在可以深入到你J2EE容器内部的管理了。 (好像国内出现了第一个自己J2ee服务器，不知道那是不是基于JMX开发的?)</p>
<p>J2EE并不能概括所有的应用领域，比如对速度和性能要求极高的游戏或股票行情等系统就需要自己直接来开发Server， 如果是能够基于JMX开发，那么可以说就大大提高编写管理程序的效率，可以将你的模块变成JMX的MBean，可以通过Agent在程序内部或者通过 WEB管理页面对你的MBean模块进行初始化 重启 以及参数设置。</p>
<p>JMX的好处还有：可以方便整合连接现有的Java技术，如JNDI、 JDBC 、JTS及其它。特别是能够使用Jini的查询 发现机制以及协议，我们知道,Jini提供了一种服务的查询和发现机制，这些services都可以通过JMX 来实现管理。</p>
<hr>
<p>原文链接：<a href="http://blog.csdn.net/drykilllogic/article/details/38379623" target="_blank" rel="external">http://blog.csdn.net/drykilllogic/article/details/38379623</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat源码：Connector]]></title>
      <url>http://www.ideabuffer.cn/2016/12/08/Tomcat%E6%BA%90%E7%A0%81%EF%BC%9AConnector/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat源码：生命周期]]></title>
      <url>http://www.ideabuffer.cn/2016/12/05/Tomcat%E6%BA%90%E7%A0%81%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>从前几篇文章可以知道，Tomcat包含很多组件，并且一个组件可以包含多个组件，当Tomcat启动时，只需要启动最上层的组件，那么包含于该组件中的其他组件也会一并启动，关闭也一样。这就是通过实现<code>org.apache.catalina.Lifecycle</code>接口来实现的单一启动/关闭的效果。</p>
<p>Tomcat的生命周期主要涉及到4种类型：<code>Lifecycle</code>、<code>LifecycleEvent</code>、<code>LifecycleState</code>和<code>LifecycleListener</code>，Tomcat也提供了<code>LifecycleBase</code>抽象类来简化生命周期的处理，它实现了<code>Lifecycle</code>接口，并提供了钩子函数来扩展各个组件在生命周期中的处理行为。</p>
<p>生命周期的基本类图如下：</p>
<img src="/2016/12/05/Tomcat源码：生命周期/QQ20161206-0@2x.png" alt="QQ20161206-0@2x.png" title="">
<a id="more"></a>
<h2 id="Lifecycle接口"><a href="#Lifecycle接口" class="headerlink" title="Lifecycle接口"></a>Lifecycle接口</h2><p>Tomcat中的组件可以包含多个其他组件，这些组件的启动和关闭并不需要进行单独的启动和关闭，而是只启动或关闭最上层的组件即可使全部组件都能够启动或关闭，这种单一启动/关闭机制就是通过<code>Lifecycle</code>接口来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_INIT_EVENT = <span class="string">"before_init"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_INIT_EVENT = <span class="string">"after_init"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String START_EVENT = <span class="string">"start"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_START_EVENT = <span class="string">"before_start"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_START_EVENT = <span class="string">"after_start"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOP_EVENT = <span class="string">"stop"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_STOP_EVENT = <span class="string">"before_stop"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_STOP_EVENT = <span class="string">"after_stop"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_DESTROY_EVENT = <span class="string">"after_destroy"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_DESTROY_EVENT = <span class="string">"before_destroy"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERIODIC_EVENT = <span class="string">"periodic"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURE_START_EVENT = <span class="string">"configure_start"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURE_STOP_EVENT = <span class="string">"configure_stop"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> LifecycleState <span class="title">getState</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStateName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingleUse</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口中定义了很多触发事件，常用的例如<code>before_init</code>、<code>after_init</code>、<code>before_start</code>、<code>start</code>、<code>after_start</code>等等，只看名字也能知道是做什么的了。</p>
<p><code>start</code>和<code>stop</code>方法是对组件进行启动和关闭的操作；<code>addLifecycleListener</code>、<code>removeLifecycleListener</code>和<code>findLifecycleListeners</code>都是与事件监听相关的。一个组件可以注册多个事件监听器来监听该组件对应的某些事件，当触发了该事件时，会通知相应的监听器。</p>
<p>这里面还有一个很有意思的内部接口<code>SingleUse</code>，它是一个标记接口，用于指示实例应该只使用一次。当一个组件实例实现了这个接口会在<code>stop</code>方法完成时自动调用<code>destroy</code>方法。例如在<code>LifecycleBase</code>中的<code>stop</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    stopInternal();</div><div class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">    ExceptionUtils.handleThrowable(t);</div><div class="line">    setStateInternal(LifecycleState.FAILED, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">"lifecycleBase.stopFail"</span>,toString()), t);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 如果实现了Lifecycle.SingleUse接口，则设置状态为已关闭，然后调用destroy()方法</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Lifecycle.SingleUse) &#123;</div><div class="line">        <span class="comment">// Complete stop process first</span></div><div class="line">        setStateInternal(LifecycleState.STOPPED, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">        destroy();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>作为一个标记接口，并没有需要实现的方法，仅仅代表了一种能力，例如实现了<code>java.io.Serializable</code>接口的实例，表示该实例可以序列化，在判断时会使用<code>instanceof</code>关键字来进行判断。<br>其实在<code>java.util.Map&lt;K,V&gt;</code>接口中也定义了一个内部接口<code>Map.Entry&lt;K, V&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么为什么要定义一个内部接口呢，内部接口的作用是什么？具体现在我也不太清楚，这里先标记一下，有空专门研究一下。</p>
<h2 id="LifecycleEvent类"><a href="#LifecycleEvent类" class="headerlink" title="LifecycleEvent类"></a>LifecycleEvent类</h2><p><code>LifecycleEvent</code>类的实例表示一个生命周期的事件，类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Construct a new LifecycleEvent with the specified parameters.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> lifecycle Component on which this event occurred</div><div class="line">     * <span class="doctag">@param</span> type Event type (required)</div><div class="line">     * <span class="doctag">@param</span> data Event data (if any)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleEvent</span><span class="params">(Lifecycle lifecycle, String type, Object data)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(lifecycle);</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The event data associated with this event.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object data;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The event type this instance represents.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@return</span> the event data of this event.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@return</span> the Lifecycle on which this event occurred.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (Lifecycle) getSource();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@return</span> the event type of this event.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在构造方法中，第一个参数为生命周期的组件，第二个参数为事件类型，第三个参数为传入的数据，可以看成是对这三种类型的封装。</p>
<p>另外介绍一下<code>EventObject</code>对象，它里面定义了一个事件源对象，所谓事件源就是事件发生的地方，而在Tomcat的设计中，事件源就是实现了<code>Lifecycle</code>接口的各个需要管理生命周期的组件。每个组件都继承自<code>LifecycleBase</code>，那么组件就是通过<code>LifecycleBase</code>来实现事件源的传递，这样在<code>LifecycleBase</code>触发事件的时候，可以通过事件源（也就是相当于当前组件<em>this</em>）构建<code>EventObject</code>.这样以来<code>LifecycleListener</code>就可以通过事件对象获取到事件源，从而做一些与事件源相关的操作。如果还是不太清楚的话，继续往下看。</p>
<h2 id="LifecycleListener接口"><a href="#LifecycleListener接口" class="headerlink" title="LifecycleListener接口"></a>LifecycleListener接口</h2><p>一个生命周期的事件监听器是该接口的实例，该接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleListener</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Acknowledge the occurrence of the specified event.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> event LifecycleEvent that has occurred</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有一个方法<code>lifecycleEvent</code>，看到该方法的参数正是上面所讲到的<code>LifecycleEvent</code>，当某个事件监听器监听到相关事件时，会调用该方法。例如，当<code>Server</code>组件启动时，看下<code>StandardServer</code>中的<code>startInternal</code>方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 该方法继承自LifecycleBase</span></div><div class="line">    fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="keyword">null</span>);</div><div class="line">    setState(LifecycleState.STARTING);</div><div class="line"></div><div class="line">    globalNamingResources.start();</div><div class="line"></div><div class="line">    <span class="comment">// Start our defined Services</span></div><div class="line">    <span class="keyword">synchronized</span> (servicesLock) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</div><div class="line">            services[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>fireLifecycleEvent</code>方法继承自<code>LifecycleBase</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</div><div class="line">    LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(<span class="keyword">this</span>, type, data);</div><div class="line">    <span class="keyword">for</span> (LifecycleListener listener : lifecycleListeners) &#123;</div><div class="line">        listener.lifecycleEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在该方法中，创建了一个<code>LifecycleEvent</code>对象，并将当前对象（<code>StandardServer</code>）作为第一个参数传入<code>LifecycleEvent</code>构造器中，然后监听器会调用<code>lifecycleEvent</code>方法来执行具体的操作。</p>
<h2 id="LifecycleBase类"><a href="#LifecycleBase类" class="headerlink" title="LifecycleBase类"></a>LifecycleBase类</h2><p><code>LifecycleBase</code>实现了<code>Lifecycle</code>接口，添加了几个新的方法如<code>setStateInternal</code>(更新组件状态)、<code>fireLifecycleEvent</code>(触发LifecycleEvent)，以及一些钩子方法例如<code>initInternal</code>、<code>startInternal</code>等。</p>
<img src="/2016/12/05/Tomcat源码：生命周期/屏幕快照%202016-12-06%20下午10.54.49.png" alt="屏幕快照 2016-12-06 下午10.54.49.png" title="">
<p>例如上文中提到的<code>fireLifecycleEvent</code>方法，用来触发事件；再例如，执行<code>init</code>方法时，会调用抽象方法<code>initInternal</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</div><div class="line">        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</div><div class="line">    &#125;</div><div class="line">    setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        initInternal();</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        ExceptionUtils.handleThrowable(t);</div><div class="line">        setStateInternal(LifecycleState.FAILED, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</div><div class="line">                sm.getString(<span class="string">"lifecycleBase.initFail"</span>,toString()), t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</div></pre></td></tr></table></figure>
<p>具体的规则在子类中实现。</p>
<p>该类中定义了两个重要的变量：<code>lifecycleListeners</code>和<code>state</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The list of registered LifecycleListeners for event notifications.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;LifecycleListener&gt; lifecycleListeners = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The current state of the source component.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> LifecycleState state = LifecycleState.NEW;</div></pre></td></tr></table></figure>
<p><code>lifecycleListeners</code>用来保存监听器，<code>state</code>表示当前生命周期的状态。</p>
<h3 id="lifecycleListeners属性"><a href="#lifecycleListeners属性" class="headerlink" title="lifecycleListeners属性"></a>lifecycleListeners属性</h3><p>首先来看下<code>lifecycleListeners</code>，它是<code>CopyOnWriteArrayList</code>的类型，这里简单介绍一下：</p>
<blockquote>
<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
</blockquote>
<p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>那么在<code>LifecycleBase</code>中，为什么将<code>lifecycleListeners</code>变量定义为这种类型？从上面的分析可知，<code>CopyOnWriteArrayList</code>适用于读多写少的情况。回顾一下<a href="/2016/11/27/Tomcat源码：Catalina启动流程/">Tomcat源码：Catalina启动流程</a>中提到的<code>createStartDigester</code>方法，在该方法中有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建listener，其中第二个参数为空，表示必须在配置文件中指定className</span></div><div class="line">digester.addObjectCreate(<span class="string">"Server/Listener"</span>,</div><div class="line">                         <span class="keyword">null</span>, <span class="comment">// MUST be specified in the element</span></div><div class="line">                         <span class="string">"className"</span>);</div><div class="line">digester.addSetProperties(<span class="string">"Server/Listener"</span>);</div><div class="line">digester.addSetNext(<span class="string">"Server/Listener"</span>,</div><div class="line">                    <span class="string">"addLifecycleListener"</span>,</div><div class="line">                    <span class="string">"org.apache.catalina.LifecycleListener"</span>);</div></pre></td></tr></table></figure>
<p>对于服务器组件<code>Server</code>，监听器是在调用<code>StandardServer</code>的构造方法和解析配置文件<code>server.xml</code>时通过调用<code>addLifecycleListener</code>方法来添加到<code>lifecycleListeners</code>变量中的，那么当Tomcat启动后，就基本不会再添加新的Listener了。但注意，是<em>基本</em>不会添加，并不绝对，例如<code>org.apache.catalina.startup.HostConfig</code>，它也是一个监听器，看下其中的<code>reload</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Note: If either of fileToRemove and newDocBase are null, both will be</div><div class="line"> *       ignored.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">(DeployedApplication app, File fileToRemove, String newDocBase)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(log.isInfoEnabled())</div><div class="line">        log.info(sm.getString(<span class="string">"hostConfig.reload"</span>, app.name));</div><div class="line">    Context context = (Context) host.findChild(app.name);</div><div class="line">    <span class="keyword">if</span> (context.getState().isAvailable()) &#123;</div><div class="line">        <span class="keyword">if</span> (fileToRemove != <span class="keyword">null</span> &amp;&amp; newDocBase != <span class="keyword">null</span>) &#123;</div><div class="line">            context.addLifecycleListener(</div><div class="line">                    <span class="keyword">new</span> ExpandedDirectoryRemovalListener(fileToRemove, newDocBase));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Reload catches and logs exceptions</span></div><div class="line">        context.reload();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// If the context was not started (for example an error</span></div><div class="line">        <span class="comment">// in web.xml) we'll still get to try to start</span></div><div class="line">        <span class="keyword">if</span> (fileToRemove != <span class="keyword">null</span> &amp;&amp; newDocBase != <span class="keyword">null</span>) &#123;</div><div class="line">            ExpandWar.delete(fileToRemove);</div><div class="line">            context.setDocBase(newDocBase);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            context.start();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            log.warn(sm.getString</div><div class="line">                     (<span class="string">"hostConfig.context.restart"</span>, app.name), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法是重新加载一个context，那么可以看到，这里为<code>context</code>增加了一个监听器，该监听器用来确保在重新加载context时，将之前WAR包解压出来的目录删除，并且将dcoBase设置到指定的WAR。</p>
<p>在使用<code>CopyOnWriteArrayList</code>时需要注意两个问题：</p>
<ul>
<li>内存占用问题</li>
<li>数据一致性问题</li>
</ul>
<p><em>内存占用问题：</em>因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，如果列表中的对象比较大，假设为100M，那么再写入100M的对象进去，内存就会占用200M，那么这个时候很有可能造成频繁的Yong GC和Full GC，从而会导致整个系统响应时间过长。</p>
<p><em>数据一致性问题：</em>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据能够立即读到，那么请不要使用CopyOnWrite容器。</p>
<p>总体来说，一般组件启动之后，就基本不会再添加新的监听器了，所以使用<code>CopyOnWriteArrayList</code>类型是很合适的。</p>
<h3 id="state属性"><a href="#state属性" class="headerlink" title="state属性"></a>state属性</h3><p>再来看下<code>state</code>属性，该属性被<code>volatile</code>关键字修饰，保证了<code>state</code>属性的可见性，但也仅仅是可见性，而不具有原子性，所以，它与<code>synchronized</code>关键字相比，少了原子性，可以看做是”轻量级的<code>synchronized</code>“。</p>
<p>这里为什么用<code>volatile</code>关键字修饰？</p>
<p>先考虑一下是否需要原子性。我们现在可以知道，一个组件的状态是在调用生命周期的<code>init</code>、<code>start</code>等<code>Lifecycle</code>接口中定义的生命周期行为的方法时才会被设置，一个组件不可能在同一时间调用不同的生命周期行为，所以原子性是不必要的。</p>
<p>再来考虑一下可见性。当组件的状态改变时，当然是需要立即被读取到，通过组件生命周期的状态来判断是否应该执行指定的生命周期的行为，例如一个组件已经执行了<code>destroy</code>方法，那么就不可能再调用该组件的<code>start</code>方法，所以可见性是必须的。</p>
<h2 id="LifecycleState类"><a href="#LifecycleState类" class="headerlink" title="LifecycleState类"></a>LifecycleState类</h2><p><code>LifecycleState</code>是一个枚举类型，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The list of valid states for components that implement &#123;<span class="doctag">@link</span> Lifecycle&#125;.</div><div class="line"> * See &#123;<span class="doctag">@link</span> Lifecycle&#125; for the state transition diagram.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> LifecycleState &#123;</div><div class="line">    NEW(<span class="keyword">false</span>, <span class="keyword">null</span>),</div><div class="line">    INITIALIZING(<span class="keyword">false</span>, Lifecycle.BEFORE_INIT_EVENT),</div><div class="line">    INITIALIZED(<span class="keyword">false</span>, Lifecycle.AFTER_INIT_EVENT),</div><div class="line">    STARTING_PREP(<span class="keyword">false</span>, Lifecycle.BEFORE_START_EVENT),</div><div class="line">    STARTING(<span class="keyword">true</span>, Lifecycle.START_EVENT),</div><div class="line">    STARTED(<span class="keyword">true</span>, Lifecycle.AFTER_START_EVENT),</div><div class="line">    STOPPING_PREP(<span class="keyword">true</span>, Lifecycle.BEFORE_STOP_EVENT),</div><div class="line">    STOPPING(<span class="keyword">false</span>, Lifecycle.STOP_EVENT),</div><div class="line">    STOPPED(<span class="keyword">false</span>, Lifecycle.AFTER_STOP_EVENT),</div><div class="line">    DESTROYING(<span class="keyword">false</span>, Lifecycle.BEFORE_DESTROY_EVENT),</div><div class="line">    DESTROYED(<span class="keyword">false</span>, Lifecycle.AFTER_DESTROY_EVENT),</div><div class="line">    FAILED(<span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> available;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lifecycleEvent;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LifecycleState</span><span class="params">(<span class="keyword">boolean</span> available, String lifecycleEvent)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.available = available;</div><div class="line">        <span class="keyword">this</span>.lifecycleEvent = lifecycleEvent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * May the public methods other than property getters/setters and lifecycle</div><div class="line">     * methods be called for a component in this state? It returns</div><div class="line">     * &lt;code&gt;true&lt;/code&gt; for any component in any of the following states:</div><div class="line">     * &lt;ul&gt;</div><div class="line">     * &lt;li&gt;&#123;<span class="doctag">@link</span> #STARTING&#125;&lt;/li&gt;</div><div class="line">     * &lt;li&gt;&#123;<span class="doctag">@link</span> #STARTED&#125;&lt;/li&gt;</div><div class="line">     * &lt;li&gt;&#123;<span class="doctag">@link</span> #STOPPING_PREP&#125;&lt;/li&gt;</div><div class="line">     * &lt;/ul&gt;</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> &lt;code&gt;true&lt;/code&gt; if the component is available for use,</div><div class="line">     *         otherwise &lt;code&gt;false&lt;/code&gt;</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> available;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLifecycleEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lifecycleEvent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LifecycleState</code>包含两个属性：<code>available</code>和<code>lifecycleEvent</code>。</p>
<ul>
<li><p>available：判断在当前状态下是否可以调用除getter/setter方法以外的public方法以及生命周期中的方法。当前状态为以下状态时返回<code>true</code>:</p>
<ul>
<li>STARTING</li>
<li>STARTED</li>
<li>STOPPING_PREP</li>
</ul>
</li>
<li><p>getLifecycleEvent：获取处于此状态的组件正在进行的事件</p>
</li>
</ul>
<p>例如，在<code>StandardServer</code>中的<code>addService</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(Service service)</span> </span>&#123;</div><div class="line"></div><div class="line">    service.setServer(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (servicesLock) &#123;</div><div class="line">        Service results[] = <span class="keyword">new</span> Service[services.length + <span class="number">1</span>];</div><div class="line">        System.arraycopy(services, <span class="number">0</span>, results, <span class="number">0</span>, services.length);</div><div class="line">        results[services.length] = service;</div><div class="line">        services = results;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (getState().isAvailable()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                service.start();</div><div class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</div><div class="line">                <span class="comment">// Ignore</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Report this property change to interested listeners</span></div><div class="line">        support.firePropertyChange(<span class="string">"service"</span>, <span class="keyword">null</span>, service);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前Server正在启动或者已经启动，就可以直接启动服务组件<code>service</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Tomcat生命周期的核心内容，了解了生命周期，就可以很清楚的明白Tomcat的启动流程，通过Lifecycle，Tomcat只需启动最顶层组件<code>Server</code>，即可启动所有的组件，关闭也是类似，这就是单一启动/关闭机制。</p>
<p>通过对源码的阅读，不仅需要知道代码是怎么设计的，还需要知道代码为什么这样设计，例如本文中提到的<code>LifecycleBase</code>中的两个属性：<code>lifecycleListeners</code>和<code>state</code>，<code>lifecycleListeners</code>为什么要定义为<code>CopyOnWriteArrayList</code>类型？<code>state</code>为什么要用<code>volatile</code>关键字修饰？结合它们的使用，便可以知道它们的使用场景，可以更加透彻的分析出整个流程执行的机制，从而也会收获的更多。<br>最后，希望对大家有所帮助。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式：观察者模式]]></title>
      <url>http://www.ideabuffer.cn/2016/12/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="观察者模式的定义"><a href="#观察者模式的定义" class="headerlink" title="观察者模式的定义"></a>观察者模式的定义</h2><p>观察者模式（Observer Pattern），也叫发布/订阅模式（Publish/Subscribe），定义如下：</p>
<blockquote>
<p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>
</blockquote>
<p>下面是观察者模式的通用类图：</p>
<img src="/2016/12/04/设计模式：观察者模式/QQ20161204-0@2x.png" alt="QQ20161204-0@2x.png" title="">
<a id="more"></a>
<p>下面说明一下这几个角色的名称：</p>
<ul>
<li><p>Subject</p>
<p>被观察者：它必须能够动态地增加和取消观察者。一般是抽象类或者实现类，它的职责是管理观察者并通知观察者。</p>
</li>
<li><p>Observer</p>
<p>观察者：在接收到消息后，调用<code>update()</code>方法进行更新操作，对接收到的消息进行处理。</p>
</li>
<li><p>ConcreteSubject</p>
<p>具体的被观察者：定义了自己的业务逻辑，同时定义对哪些事件进行通知。</p>
</li>
<li><p>ConcreteObserver</p>
<p>具体的观察者：具有不同的处理逻辑，每个观察者在接收到消息后，可以通过自己的逻辑进行处理。</p>
</li>
</ul>
<h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><p>先看一下被观察者的通用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 观察者集合</span></div><div class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// 增加一个观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observers.add(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除一个观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer observer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observers.remove(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</div><div class="line">            o.update();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，被观察者的工作内容非常简单，主要就是增加、删除观察者以及通知观察者。</p>
<p>具体的被观察者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// do something ...</span></div><div class="line"></div><div class="line">        <span class="keyword">super</span>.notifyObservers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为是继承自<code>Subject</code>，所以只需要定义自己的业务逻辑，调用父类的<code>notifyObservers</code>方法即可。</p>
<p>观察者的通用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只需要一个<code>update</code>方法，下面是具体的观察者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// do something ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是使用场景代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	    Subject subject = <span class="keyword">new</span> ConcreteSubject();</div><div class="line">	    Observer observer = <span class="keyword">new</span> ConcreteObserver();</div><div class="line">	    subject.addObserver(observer);</div><div class="line">	    subject.work();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，都不用注释了。</p>
<h2 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a>观察者模式的优缺点</h2><p>根据上面介绍的观察者模式的定义，可以看下具体的优缺点</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>观察者和被观察值之间是抽象的耦合关系，如此设计很容易扩展观察者和被观察者</li>
<li>实现了一套触发机制，可以看到，在<code>ConcreteSubject</code>中的<code>work</code>方法中，可以通知观察者，并触发对应的<code>update</code>方法，这里并不关心每一个观察者具体是怎么处理的，它要做的只是通知观察者。</li>
<li>支持广播通信，因为被观察者中可以增加和删除观察者，这样在通知时会通知所有的观察者</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>如果一个被观察者对象有很多的观察者，那么通知观察者将会很耗时</li>
<li>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。这是很严重的问题，这一点特别要注意</li>
<li>虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的</li>
</ul>
<h2 id="Java中的观察者模式"><a href="#Java中的观察者模式" class="headerlink" title="Java中的观察者模式"></a>Java中的观察者模式</h2><p>在JDK中，已经提供了观察者模式，主要是<code>java.util.Observerbal</code>实现类和<code>java.util.Observer</code>接口，也就是说我们可以不用单独写一个观察者模式，直接使用JDK提供的即可。</p>
<p>下面写一个具体的例子来说明一下JDK中观察者模式的使用。</p>
<p>假设我要实现一个温度监控的功能，当温度超过26°C的时候，通知主人关窗，并且通知空调启动。</p>
<p>很简单，有一个温度计类，是被观察者，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thermometer</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 温度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> temperature;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> temperature;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemperature</span><span class="params">(<span class="keyword">int</span> temperature)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.temperature = temperature;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 监控温度</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (temperature &gt; <span class="number">25</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"温度高于25°C，通知观察者..."</span>);</div><div class="line">            <span class="comment">// 温度变化</span></div><div class="line">            <span class="keyword">super</span>.setChanged();</div><div class="line">            <span class="comment">// 通知观察者</span></div><div class="line">            <span class="keyword">super</span>.notifyObservers(temperature);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有家里的主人，是观察者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"主人收到消息，温度是"</span> + arg + <span class="string">"°C"</span>);</div><div class="line">        System.out.println(<span class="string">"关闭窗户..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一个观察者，是空调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirConditioner</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"空调收到消息，温度是"</span> + arg + <span class="string">"°C"</span>);</div><div class="line">        System.out.println(<span class="string">"启动空调..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看注释已经能够明白是怎么回事了，下面看下他们之间的类图：</p>
<img src="/2016/12/04/设计模式：观察者模式/QQ20161204-1.png" alt="QQ20161204-1.png" title="">
<p>可以看到，一个<code>Observer</code>包含了多个<code>Observable</code>，<code>Man</code>和<code>AirConditioner</code>作为观察者都实现了<code>Observer</code>接口，<code>Thermometer</code>作为被观察者，继承了<code>Observable</code>。</p>
<p>下面看一下场景类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thermometer thermometer = <span class="keyword">new</span> Thermometer();</div><div class="line">        Observer man = <span class="keyword">new</span> Man();</div><div class="line">        Observer airConditioner = <span class="keyword">new</span> AirConditioner();</div><div class="line">        <span class="comment">// 添加观察者</span></div><div class="line">        thermometer.addObserver(man);</div><div class="line">        thermometer.addObserver(airConditioner);</div><div class="line">        <span class="comment">// 设置温度为26°C</span></div><div class="line">        thermometer.setTemperature(<span class="number">26</span>);</div><div class="line">        <span class="comment">// 开始监控</span></div><div class="line">        thermometer.monitor();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">温度高于25°C，通知观察者...</div><div class="line">空调收到消息，温度是26°C</div><div class="line">启动空调...</div><div class="line">主人收到消息，温度是26°C</div><div class="line">关闭窗户...</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>观察者模式的实际应用有很多，比如Tomcat中的生命周期，就是典型的观察者模式，了解了观察者模式之后，再要了解Tomcat的生命周期就会非常容易了。</p>
<p>再比如现实生活中的例子，点一份外卖，点的商品相当于被观察者，商家和送餐员相当于观察者，点餐时，通知商家下订单，并且也会通知送餐员去商家取餐，而点餐的你也相当于观察者，可以查看送餐的进度。所以，观察者模式的用途也是比较广泛的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat源码：服务器组件]]></title>
      <url>http://www.ideabuffer.cn/2016/12/03/Tomcat%E6%BA%90%E7%A0%81%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="Server接口"><a href="#Server接口" class="headerlink" title="Server接口"></a>Server接口</h2><p><code>org.apache.catalina.Server</code>接口定义了Tomcat的服务器组件，该接口的实例代表了整个servlet引擎，包括了所有的组件。Tomcat的服务器组件非常重要，因为它可以很优雅的来启动或关闭整个系统，不需要对连接器和容器单独进行启动和关闭。</p>
<p>下面来介绍一下启动和关闭的工作原理。</p>
<p>从之前的文章<a href="/2016/11/26/Tomcat源码：Bootstrap启动流程/">Tomcat源码：Bootstrap启动流程</a>和<a href="/2016/11/27/Tomcat源码：Catalina启动流程/">Tomcat源码：Catalina启动流程</a>可以了解到，当Tomcat启动的时候，会调用<code>Catalina</code>的<code>setAwait(true)</code>方法，将<code>await</code>变量设置为<code>true</code>，然后调用<code>start</code>方法启动Tomcat，看下<code>Catalina</code>中的<code>start</code>方法的最后几行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (await) &#123;</div><div class="line">    await();</div><div class="line">    stop();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>回顾一下上篇<a href="/2016/11/27/Tomcat源码：Catalina启动流程/">Tomcat源码：Catalina启动流程</a>中提到的<code>await</code>方法的作用：</p>
<ul>
<li>判断当前启动的Server所要绑定的端口是否被占用</li>
<li>监听Server的端口，会一直等待接收关闭命令</li>
</ul>
<p>如果要关闭Tomcat，就可以向Server指定的端口发送一个关闭命令（默认是<em>SHUTDOWN</em>），接收到关闭命令后就会关闭所有的组件。</p>
<p>下面给出Server接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> NamingResourcesImpl <span class="title">getGlobalNamingResources</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGlobalNamingResources</span><span class="params">(NamingResourcesImpl globalNamingResources)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> javax.naming.<span class="function">Context <span class="title">getGlobalNamingContext</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShutdown</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShutdown</span><span class="params">(String shutdown)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getParentClassLoader</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Catalina <span class="title">getCatalina</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCatalina</span><span class="params">(Catalina catalina)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getCatalinaBase</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCatalinaBase</span><span class="params">(File catalinaBase)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getCatalinaHome</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCatalinaHome</span><span class="params">(File catalinaHome)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(Service service)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">findService</span><span class="params">(String name)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Service[] findServices();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeService</span><span class="params">(Service service)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNamingToken</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>setShutdown</code>方法用于设置Server的关闭命令，<code>setPort</code>方法用于设置Server的端口，用于接收关闭命令，<code>addService</code>方法用于添加服务组件，<code>removeService</code>方法用来删除服务组件，<code>findServices</code>方法用来添加到该服务器组件的所有服务组件，以及刚才提到的<code>await</code>方法。</p>
<h2 id="StandardServer类"><a href="#StandardServer类" class="headerlink" title="StandardServer类"></a>StandardServer类</h2><p><code>org.apache.catalina.core.StandardServer</code>类是<code>Server</code>接口的标准实现。从Server接口的定义可以看出，一个服务器组件可以有多个服务组件，当然，由于<code>StandardServer</code>继承了<code>LifecycleBase</code>，也就是实现了<code>LifeCycle</code>接口，所以StandardServer类中有4个与生命周期有关的方法，分别是<code>initInternal()</code>方法、<code>startInternal()</code>方法、<code>stopInternal()</code>和<code>destroyInternal()</code>方法。</p>
<p>说明一下，上面4个方法对应于<code>Lifecycle</code>接口中定义的<code>init()</code>方法、<code>start()</code>方法、<code>stop()</code>方法和<code>destroy()</code>方法，这4个方法已经被<code>LifecycleBase</code>实现，而<code>LifecycleBase</code>是一个抽象类，以<code>initInternal()</code>方法为例，该方法是一个抽象方法，StandardServer实现了该方法，相当于一个钩子方法，如果你了解了设计模式中的模板模式，这个应该就好理解了，看下<code>LifecycleBase</code>中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</div><div class="line">        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</div><div class="line">    &#125;</div><div class="line">    setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        initInternal();</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        ExceptionUtils.handleThrowable(t);</div><div class="line">        setStateInternal(LifecycleState.FAILED, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</div><div class="line">                sm.getString(<span class="string">"lifecycleBase.initFail"</span>,toString()), t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</div></pre></td></tr></table></figure>
<p>这下应该很明白了吧。类似的还有<code>start()</code>方法和<code>stop()</code>方法。</p>
<p>有关生命周期我以后会单独写一篇文章，这里就不过多介绍了。</p>
<p>看一下服务器组件的类图：</p>
<img src="/2016/12/03/Tomcat源码：服务器组件/屏幕快照%202016-12-04%20上午12.34.30.png" alt="屏幕快照 2016-12-04 上午12.34.30.png" title="">
<h3 id="initInternal方法"><a href="#initInternal方法" class="headerlink" title="initInternal方法"></a>initInternal方法</h3><p>该方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.initInternal();</div><div class="line"></div><div class="line">    <span class="comment">// Register global String cache</span></div><div class="line">    <span class="comment">// Note although the cache is global, if there are multiple Servers</span></div><div class="line">    <span class="comment">// present in the JVM (may happen when embedding) then the same cache</span></div><div class="line">    <span class="comment">// will be registered under multiple names</span></div><div class="line">    onameStringCache = register(<span class="keyword">new</span> StringCache(), <span class="string">"type=StringCache"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Register the MBeanFactory</span></div><div class="line">    MBeanFactory factory = <span class="keyword">new</span> MBeanFactory();</div><div class="line">    factory.setContainer(<span class="keyword">this</span>);</div><div class="line">    onameMBeanFactory = register(factory, <span class="string">"type=MBeanFactory"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Register the naming resources</span></div><div class="line">    globalNamingResources.init();</div><div class="line"></div><div class="line">    <span class="comment">// Populate the extension validator with JARs from common and shared</span></div><div class="line">    <span class="comment">// class loaders</span></div><div class="line">    <span class="keyword">if</span> (getCatalina() != <span class="keyword">null</span>) &#123;</div><div class="line">        ClassLoader cl = getCatalina().getParentClassLoader();</div><div class="line">        <span class="comment">// Walk the class loader hierarchy. Stop at the system class loader.</span></div><div class="line">        <span class="comment">// This will add the shared (if present) and common class loaders</span></div><div class="line">        <span class="keyword">while</span> (cl != <span class="keyword">null</span> &amp;&amp; cl != ClassLoader.getSystemClassLoader()) &#123;</div><div class="line">            <span class="keyword">if</span> (cl <span class="keyword">instanceof</span> URLClassLoader) &#123;</div><div class="line">                URL[] urls = ((URLClassLoader) cl).getURLs();</div><div class="line">                <span class="keyword">for</span> (URL url : urls) &#123;</div><div class="line">                    <span class="keyword">if</span> (url.getProtocol().equals(<span class="string">"file"</span>)) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            File f = <span class="keyword">new</span> File (url.toURI());</div><div class="line">                            <span class="keyword">if</span> (f.isFile() &amp;&amp;</div><div class="line">                                    f.getName().endsWith(<span class="string">".jar"</span>)) &#123;</div><div class="line">                                ExtensionValidator.addSystemResource(f);</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</div><div class="line">                            <span class="comment">// Ignore</span></div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                            <span class="comment">// Ignore</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            cl = cl.getParent();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Initialize our defined Services</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</div><div class="line">        services[i].init();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面是JNDI和一些MBean的操作以及对扩展依赖项的验证，最后是初始化服务组件。</p>
<p>服务组件<code>services</code>怎么来的？回顾一下<a href="/2016/11/27/Tomcat源码：Catalina启动流程/#createStartDigester方法">Tomcat源码：Catalina启动流程</a>中的<code>createStartDigester</code>方法，想想也就可以知道，肯定是通过解析<code>server.xml</code>文件得到的。</p>
<h3 id="startInternal方法"><a href="#startInternal方法" class="headerlink" title="startInternal方法"></a>startInternal方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line"></div><div class="line">    fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="keyword">null</span>);</div><div class="line">    setState(LifecycleState.STARTING);</div><div class="line"></div><div class="line">    globalNamingResources.start();</div><div class="line"></div><div class="line">    <span class="comment">// Start our defined Services</span></div><div class="line">    <span class="keyword">synchronized</span> (servicesLock) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</div><div class="line">            services[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简单，首先是对全局JNDI的资源的启动，然后是对服务组件的启动。</p>
<p>介绍到这里，其实<code>stopInternal()</code>方法和<code>destroyInternal()</code>方法与这两种方法类似，无非就是调用服务组件的<code>stop()</code>方法和<code>destroy()</code>方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的分析可以看出，StandardServer作为一个标准的服务器组件，它的主要工作是对服务组件的初始化、启动、关闭和销毁，功能比较简单，同时也可以看出，它使用一种优雅的方式来对服务组件进行启动和关闭的操作，没有对连接器和容器进行单独操作。</p>
<p>服务器组件实现了<code>Lifecycle</code>接口，生命周期在整个Tomcat中具有非常重要的作用，可以用它来管理不同层级的组件，Tomcat在设计上允许一个组件包含其他组件，例如本文中介绍的服务器组件，它包含了服务组件，再例如，服务组件包含了连接器和容器，容器中又可以包含类加载器和管理器等等。</p>
<p>父组件可以启动或关闭子组件，正式这种设计使得Tomcat在启动时只需要启动一个组件就可以将全部的组件都启动起来，这就是单一启动/关闭机制，而实现这一机制就是通过实现<code>Lifecycle</code>接口来完成的。</p>
<p>不多说了，好像有点跑题了。。。但要弄清楚服务器组件的工作流程必然要提及到<code>Lifecycle</code>，通过本篇文章的介绍，相信大家已经对服务器组件的工作有了一定了解，后续会继续分析服务组件以及详细介绍一下生命周期，先到这里吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java7 中的try-with-resources]]></title>
      <url>http://www.ideabuffer.cn/2016/12/02/Java7%E4%B8%AD%E7%9A%84try-with-resources/</url>
      <content type="html"><![CDATA[<p>今天调试了一下Tomcat关闭代码，在执行关闭时会调用<code>Catalina</code>对象的<code>stopServer</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopServer</span><span class="params">(String[] arguments)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (arguments != <span class="keyword">null</span>) &#123;</div><div class="line">        arguments(arguments);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Server s = getServer();</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Create and execute our Digester</span></div><div class="line">        Digester digester = createStopDigester();</div><div class="line">        File file = configFile();</div><div class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(file)) &#123;</div><div class="line">            InputSource is =</div><div class="line">                <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</div><div class="line">            is.setByteStream(fis);</div><div class="line">            digester.push(<span class="keyword">this</span>);</div><div class="line">            digester.parse(is);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            log.error(<span class="string">"Catalina.stop: "</span>, e);</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Server object already present. Must be running as a service</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            s.stop();</div><div class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</div><div class="line">            log.error(<span class="string">"Catalina.stop: "</span>, e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Stop the existing server</span></div><div class="line">    s = getServer();</div><div class="line">    <span class="keyword">if</span> (s.getPort()&gt;<span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 注意这段代码，并没有对资源进行close</div><div class="line">         */</div><div class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(s.getAddress(), s.getPort());</div><div class="line">                OutputStream stream = socket.getOutputStream()) &#123;</div><div class="line">            String shutdown = s.getShutdown();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shutdown.length(); i++) &#123;</div><div class="line">                stream.write(shutdown.charAt(i));</div><div class="line">            &#125;</div><div class="line">            stream.flush();</div><div class="line">        &#125; <span class="keyword">catch</span> (ConnectException ce) &#123;</div><div class="line">            log.error(sm.getString(<span class="string">"catalina.stopServer.connectException"</span>,</div><div class="line">                                   s.getAddress(),</div><div class="line">                                   String.valueOf(s.getPort())));</div><div class="line">            log.error(<span class="string">"Catalina.stop: "</span>, ce);</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            log.error(<span class="string">"Catalina.stop: "</span>, e);</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        log.error(sm.getString(<span class="string">"catalina.stopServer"</span>));</div><div class="line">        System.exit(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>啥意思呢，就是在执行<code>stopServer</code>方法时通过<code>Socket</code>来发送一个<code>SHUTDOWN</code>字符串到指定Tomcat的Server监听端口（默认为8005），来告诉Tomcat要执行关闭操作。</p>
<p>接收这个字符串的代码在<code>StandardServer</code>的<code>await</code>方法中，代码如下：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    InputStream stream;</div><div class="line">    <span class="keyword">long</span> acceptStartTime = System.currentTimeMillis();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 接收socket</span></div><div class="line">        socket = serverSocket.accept();</div><div class="line">        <span class="comment">// 设置超时时间为10妙</span></div><div class="line">        socket.setSoTimeout(<span class="number">10</span> * <span class="number">1000</span>);  <span class="comment">// Ten seconds</span></div><div class="line">        <span class="comment">// 获取输入流</span></div><div class="line">        stream = socket.getInputStream();</div><div class="line">    &#125; <span class="keyword">catch</span> (SocketTimeoutException ste) &#123;</div><div class="line">        <span class="comment">// This should never happen but bug 56684 suggests that</span></div><div class="line">        <span class="comment">// it does.</span></div><div class="line">        log.warn(sm.getString(<span class="string">"standardServer.accept.timeout"</span>,</div><div class="line">                Long.valueOf(System.currentTimeMillis() - acceptStartTime)), ste);</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (AccessControlException ace) &#123;</div><div class="line">        log.warn(<span class="string">"StandardServer.accept security exception: "</span></div><div class="line">                + ace.getMessage(), ace);</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="keyword">if</span> (stopAwait) &#123;</div><div class="line">            <span class="comment">// Wait was aborted with socket.close()</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        log.error(<span class="string">"StandardServer.await: accept: "</span>, e);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Read a set of characters from the socket</span></div><div class="line">    <span class="keyword">int</span> expected = <span class="number">1024</span>; <span class="comment">// Cut off to avoid DoS attack</span></div><div class="line">    <span class="keyword">while</span> (expected &lt; shutdown.length()) &#123;</div><div class="line">        <span class="keyword">if</span> (random == <span class="keyword">null</span>)</div><div class="line">            random = <span class="keyword">new</span> Random();</div><div class="line">        expected += (random.nextInt() % <span class="number">1024</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (expected &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> ch = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 接收字符</span></div><div class="line">            ch = stream.read();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            log.warn(<span class="string">"StandardServer.await: read: "</span>, e);</div><div class="line">            ch = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (ch &lt; <span class="number">32</span>)  <span class="comment">// Control character or EOF terminates loop</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        command.append((<span class="keyword">char</span>) ch);</div><div class="line">        expected--;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// Close the socket now that we are done with it</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</div><div class="line">            socket.close();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// Ignore</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意看下第41行的代码<code>ch = stream.read()</code>，这个用来接收一个字符。再看下第46行，说明已经接收完毕，通常应该<code>ch</code>应该是-1，然后break。</p>
<p>但在关闭时断点如果执行完<code>stream.flush()</code>后，<code>await</code>方法在接收最后一个字符的时候会一直等待，直到timeOut指定的时间，然后会报如下异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">警告: StandardServer.await: read: </div><div class="line">java.net.SocketTimeoutException: Read timed out</div><div class="line">	at java.net.SocketInputStream.socketRead0(Native Method)</div><div class="line">	at java.net.SocketInputStream.socketRead(SocketInputStream.java:<span class="number">116</span>)</div><div class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">170</span>)</div><div class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">141</span>)</div><div class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">223</span>)</div><div class="line">	at org.apache.catalina.core.StandardServer.await(StandardServer.java:<span class="number">498</span>)</div><div class="line">	at org.apache.catalina.startup.Catalina.await(Catalina.java:<span class="number">739</span>)</div><div class="line">	at org.apache.catalina.startup.Catalina.start(Catalina.java:<span class="number">685</span>)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</div><div class="line">	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:<span class="number">355</span>)</div><div class="line">	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:<span class="number">495</span>)</div></pre></td></tr></table></figure>
<p>这说明这个socket并未关闭，回过头来看<code>stopServer</code>中的代码，发现在<code>try-catch</code>中并未显式关闭<code>socket</code>和<code>stream</code>，如果断点再走一步的话，在<code>await</code>中的接收就变的正常了，说明在<code>try</code>语句块中执行完毕后自动关闭了<code>socket</code>和<code>stream</code>。</p>
<p>这种写法还真是第一次见，孤陋寡闻了。。。</p>
<p>其实，这是Java7中提供的一个新的异常处理机制，它能够很容易地关闭在try-catch语句块中使用的资源。</p>
<p>还有一个名字，叫做<em>try-with-resources</em></p>
<h2 id="旧的代码风格"><a href="#旧的代码风格" class="headerlink" title="旧的代码风格"></a>旧的代码风格</h2><p>在Java7以前，代码中使用的资源需要被明确地关闭，这个在写的时候就会有些繁琐，例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">    InputStream in = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        in = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">int</span> c = in.read();</div><div class="line">            <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println((<span class="keyword">char</span>) c);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>)</div><div class="line">            in.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，上面代码在执行<code>new FileInputStream(&quot;test.txt&quot;)</code>、<code>in.read()</code>和<code>in.close()</code>时都可能抛出异常。</p>
<p>那么到这里可以分析一下，如果在<code>try</code>语句块中抛出了异常，<code>finally</code>语句块仍然会执行，然而<code>finally</code>语句块在执行<code>in.close()</code>时也可能会抛出异常。</p>
<p>这时问题来了，如果<code>try</code>语句块中抛出了异常，<code>finally</code>语句块也抛出了异常，那么到底是哪个异常会在方法返回时向外传播？</p>
<p>其实在上面的代码中，如果都抛出异常，则在<code>finally</code>语句块中抛出的异常会向外传播，<code>try</code>语句块中的异常被抑制了。</p>
<h2 id="try-with-resources代码风格"><a href="#try-with-resources代码风格" class="headerlink" title="try-with-resources代码风格"></a>try-with-resources代码风格</h2><p>在Java7之后，上面的代码还可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">int</span> c = in.read();</div><div class="line">            <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println((<span class="keyword">char</span>) c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码只是把InputStream放到了<code>try</code>语句后面的小括号中来声明创建一个<code>FileInputStream</code>对象，在<code>try</code>语句块运行结束时会对<code>FileInputStream</code>对象自动进行关闭。</p>
<p>为什么会这样？</p>
<p>因为<code>FileInputStream</code>实现了<code>java.lang.AutoCloseable</code>接口，可以看下对应的类结构：</p>
<img src="/2016/12/02/Java7中的try-with-resources/屏幕快照%202016-12-01%20下午11.56.07.png" alt="屏幕快照 2016-12-01 下午11.56.07.png" title="">
<p>所有实现了<code>java.lang.AutoCloseable</code>接口的类都可以在<code>try-with-resources</code>结构中使用。</p>
<p>那么再考虑一下之前提到过的问题，如果这时对<code>FileInputStream</code>对象自动关闭（会调用close方法）时抛出了异常，并且<code>in.read()</code>也抛出了异常，那么在方法执行完毕时，<code>in.read()</code>抛出的异常会向外传播，<code>FileInputStream</code>对象关闭时抛出的异常将被抑制。这与之前旧的代码风格的异常抛出方式正好相反。</p>
<h2 id="try-with-resources使用多个资源"><a href="#try-with-resources使用多个资源" class="headerlink" title="try-with-resources使用多个资源"></a>try-with-resources使用多个资源</h2><p>在<code>try-with-resources</code>中可以使用多个资源，而且多个资源都能被自动关闭，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> (</div><div class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</div><div class="line">            BufferedInputStream bfIn = <span class="keyword">new</span> BufferedInputStream((in));</div><div class="line">    ) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">int</span> c = bfIn.read();</div><div class="line">            <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println((<span class="keyword">char</span>) c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里创建了两个资源：<code>FileInputStream</code>和<code>BufferedInputStream</code>。当<code>try</code>语句块运行结束时，这两个资源都会被自动关闭，而且关闭的顺序与创建的顺序相反（先关闭<code>BufferedInputStream</code>，后关闭<code>FileInputStream</code>），稍后会验证。</p>
<h2 id="AutoCloseable接口"><a href="#AutoCloseable接口" class="headerlink" title="AutoCloseable接口"></a>AutoCloseable接口</h2><p>先来查看一下<code>java.lang.AutoCloseable</code>接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，只有一个<code>close()</code>方法。</p>
<h2 id="AutoCloseable接口的实现"><a href="#AutoCloseable接口的实现" class="headerlink" title="AutoCloseable接口的实现"></a>AutoCloseable接口的实现</h2><p>下面自定义一个类，来实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoCloseableTest</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello World"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm closing..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该类实现了<code>AutoCloseable</code>接口，下面来使用这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">try</span> (</div><div class="line">            AutoCloseableTest test = <span class="keyword">new</span> AutoCloseableTest();</div><div class="line">    ) &#123;</div><div class="line">        test.say();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行查看结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello World</div><div class="line">I&apos;m closing...</div></pre></td></tr></table></figure>
<h2 id="验证多个资源的关闭"><a href="#验证多个资源的关闭" class="headerlink" title="验证多个资源的关闭"></a>验证多个资源的关闭</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> (</div><div class="line">                AutoCloseableTest test = <span class="keyword">new</span> AutoCloseableTest();</div><div class="line">                AutoCloseableTest2 test2 = <span class="keyword">new</span> AutoCloseableTest2();</div><div class="line">        ) &#123;</div><div class="line">            test.say();</div><div class="line">            test2.say();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoCloseableTest</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm in AutoCloseableTest"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"AutoCloseableTest is closing..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoCloseableTest2</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm in AutoCloseableTest2"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"AutoCloseableTest2 is closing..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">I&apos;m in AutoCloseableTest</div><div class="line">I&apos;m in AutoCloseableTest2</div><div class="line">AutoCloseableTest2 is closing...</div><div class="line">AutoCloseableTest is closing...</div></pre></td></tr></table></figure>
<p>可以看到，两个资源都被自动关闭了，而且顺序与创建的顺序相反。</p>
<h2 id="验证被抑制的异常"><a href="#验证被抑制的异常" class="headerlink" title="验证被抑制的异常"></a>验证被抑制的异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            call();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> (</div><div class="line">                AutoCloseableTest test = <span class="keyword">new</span> AutoCloseableTest();</div><div class="line">        ) &#123;</div><div class="line">            test.say();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            System.out.println(<span class="string">"I'm in finally"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoCloseableTest</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> <span class="keyword">throws</span> MyException1 </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException1(<span class="string">"I'm MyException1"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> MyException2 </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException2(<span class="string">"I'm MyException2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException1</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException1</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(message);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException2</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException2</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(message);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码定义了两个异常，在<code>main</code>方法中捕获并输出异常栈，结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">MyException1: I'm MyException1</div><div class="line">	at AutoCloseableTest.say(Test.java:31)</div><div class="line">	at Test.call(Test.java:21)</div><div class="line">	at Test.main(Test.java:9)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:497)</div><div class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</div><div class="line">	Suppressed: MyException2: I'm MyException2</div><div class="line">		at AutoCloseableTest.close(Test.java:36)</div><div class="line">		at Test.call(Test.java:22)</div><div class="line">		... 6 more</div><div class="line">I'm in finally</div></pre></td></tr></table></figure>
<p>可见，<code>try-with-resources</code>中自动关闭时调用<code>close()</code>方法抛出的异常被抑制了，捕获到的是<code>say()</code>方法抛出的异常<code>MyException1</code>。</p>
<h2 id="验证自动关闭和finally的执行顺序"><a href="#验证自动关闭和finally的执行顺序" class="headerlink" title="验证自动关闭和finally的执行顺序"></a>验证自动关闭和finally的执行顺序</h2><p>从上面代码可以看出，先输出了异常的信息，然后才输出<code>I&#39;m in finally</code>，可见，在<code>finally</code>语句块执行之前自动关闭就已经被执行了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从以上的分析可以看出，<code>try-with-resources</code>风格可以实现以下几种情况：</p>
<ul>
<li>任何实现了AutoCloseable接口的类，在<code>try()</code>里声明该类实例的时候，在<code>try</code>语句块结束时，都会调用该实例的<code>close()</code>方法</li>
<li>调用<code>close</code>方法时抛出的异常会被<code>try</code>语句块中抛出的异常抑制</li>
<li>在<code>finally</code>语句块执行前，<code>try()</code>中声明实例的<code>close()</code>方法总被调用</li>
<li><code>try()</code>中声明实例的<code>close()</code>方法总会被调用，即使<code>try</code>语句块中出现了异常</li>
<li><code>try()</code>中声明实例的关闭顺序与创建顺序相反</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat源码：Catalina启动流程]]></title>
      <url>http://www.ideabuffer.cn/2016/11/27/Tomcat%E6%BA%90%E7%A0%81%EF%BC%9ACatalina%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>上篇文章分析了<code>Bootstrap</code>类的启动流程，可以知道，<code>Bootstrap</code>实际上是调用了<code>Catalina</code>类的对象来实现Tomcat的启动的，这篇文章来介绍一下<code>Catalina</code>类的启动流程。</p>
<p>回顾一下<code>Bootstrap</code>中main方法执行启动时的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (command.equals(<span class="string">"start"</span>)) &#123;</div><div class="line">    daemon.setAwait(<span class="keyword">true</span>);</div><div class="line">    daemon.load(args);</div><div class="line">    daemon.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面介绍Catalina类中的方法。</p>
<a id="more"></a>
<h2 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h2><p><code>daemon.setAwait(true);</code>表示该Tomcat已经执行了启动，也是调用了<code>Catalina</code>中的<code>setAwait</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Await and shutdown.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    getServer().await();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里又调用的<code>Server</code>的<code>await</code>方法，<code>await</code>方法的作用就是判断当前启动的Server所要绑定的端口（默认是8005）是否被占用，如果被占用，则会抛出以下异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">严重: StandardServer.await: create[localhost:8005]: </div><div class="line">java.net.BindException: Address already in use</div><div class="line">	at java.net.PlainSocketImpl.socketBind(Native Method)</div><div class="line">	at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:387)</div><div class="line">	at java.net.ServerSocket.bind(ServerSocket.java:375)</div><div class="line">	at java.net.ServerSocket.&lt;init&gt;(ServerSocket.java:237)</div><div class="line">	at org.apache.catalina.core.StandardServer.await(StandardServer.java:441)</div><div class="line">	at org.apache.catalina.startup.Catalina.await(Catalina.java:743)</div><div class="line">	at org.apache.catalina.startup.Catalina.start(Catalina.java:689)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:497)</div><div class="line">	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:355)</div><div class="line">	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:495)</div></pre></td></tr></table></figure>
<p>还有一个作用就是监听Server的端口（默认是8005），会一直等待接收关闭命令，这个以后的文章会说到，这里就先不做介绍了。</p>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><p><code>Bootstrap</code>类中的<code>load</code>方法会调用<code>Catalina</code>中的<code>load</code>方法，<code>Catalina</code>中的<code>load</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Start a new server instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line">    initDirs();</div><div class="line"></div><div class="line">    <span class="comment">// Before digester - it may be needed</span></div><div class="line">    initNaming();</div><div class="line"></div><div class="line">    <span class="comment">//使用Digester创建server.xml文件的对象，生成相应的处理规则</span></div><div class="line">    <span class="comment">// Create and execute our Digester</span></div><div class="line">    Digester digester = createStartDigester();</div><div class="line"></div><div class="line">    InputSource inputSource = <span class="keyword">null</span>;</div><div class="line">    InputStream inputStream = <span class="keyword">null</span>;</div><div class="line">    File file = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 获取配置文件，server.xml</span></div><div class="line">            file = configFile();</div><div class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">            inputSource = <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">                log.debug(sm.getString(<span class="string">"catalina.configFail"</span>, file), e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                inputStream = getClass().getClassLoader()</div><div class="line">                    .getResourceAsStream(getConfigFile());</div><div class="line">                inputSource = <span class="keyword">new</span> InputSource</div><div class="line">                    (getClass().getClassLoader()</div><div class="line">                     .getResource(getConfigFile()).toString());</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">                    log.debug(sm.getString(<span class="string">"catalina.configFail"</span>,</div><div class="line">                            getConfigFile()), e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// This should be included in catalina.jar</span></div><div class="line">        <span class="comment">// Alternative: don't bother with xml, just create it manually.</span></div><div class="line">        <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                inputStream = getClass().getClassLoader()</div><div class="line">                        .getResourceAsStream(<span class="string">"server-embed.xml"</span>);</div><div class="line">                inputSource = <span class="keyword">new</span> InputSource</div><div class="line">                (getClass().getClassLoader()</div><div class="line">                        .getResource(<span class="string">"server-embed.xml"</span>).toString());</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">                    log.debug(sm.getString(<span class="string">"catalina.configFail"</span>,</div><div class="line">                            <span class="string">"server-embed.xml"</span>), e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (inputStream == <span class="keyword">null</span> || inputSource == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span>  (file == <span class="keyword">null</span>) &#123;</div><div class="line">                log.warn(sm.getString(<span class="string">"catalina.configFail"</span>,</div><div class="line">                        getConfigFile() + <span class="string">"] or [server-embed.xml]"</span>));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                log.warn(sm.getString(<span class="string">"catalina.configFail"</span>,</div><div class="line">                        file.getAbsolutePath()));</div><div class="line">                <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</div><div class="line">                    log.warn(<span class="string">"Permissions incorrect, read permission is not allowed on the file."</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inputSource.setByteStream(inputStream);</div><div class="line">            </div><div class="line">            <span class="comment">//将Catalina对象压入栈底，server对象生成之后会调用当前对象的setServer方法来设置server对象</span></div><div class="line">            digester.push(<span class="keyword">this</span>);</div><div class="line">            digester.parse(inputSource);</div><div class="line">        &#125; <span class="keyword">catch</span> (SAXParseException spe) &#123;</div><div class="line">            log.warn(<span class="string">"Catalina.start using "</span> + getConfigFile() + <span class="string">": "</span> +</div><div class="line">                    spe.getMessage());</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            log.warn(<span class="string">"Catalina.start using "</span> + getConfigFile() + <span class="string">": "</span> , e);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                inputStream.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="comment">// Ignore</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getServer().setCatalina(<span class="keyword">this</span>);</div><div class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</div><div class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</div><div class="line"></div><div class="line">    <span class="comment">// Stream redirection</span></div><div class="line">    initStreams();</div><div class="line"></div><div class="line">    <span class="comment">// Start the new server</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 初始化server</span></div><div class="line">        getServer().init();</div><div class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</div><div class="line">        <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            log.error(<span class="string">"Catalina.start"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</div><div class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</div><div class="line">        log.info(<span class="string">"Initialization processed in "</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">" ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法主要的工作是：</p>
<ol>
<li>解析server.xml配置文件</li>
<li>根据server.xml文件创建对象，包括server，listener，service，connector，container等等</li>
<li>初始化上面创建的对象</li>
</ol>
<h2 id="server-xml文件结构"><a href="#server-xml文件结构" class="headerlink" title="server.xml文件结构"></a>server.xml文件结构</h2><p>在往下看之前，还是说一下<code>server.xml</code>的文件结构吧，也好参考的代码做对比，结构如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></div><div class="line">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></div><div class="line">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></div><div class="line">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></div><div class="line">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</div><div class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></div><div class="line"></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></div><div class="line">        <span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">minSpareThreads</span>=<span class="string">"4"</span>/&gt;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></div><div class="line">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></div><div class="line">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</div><div class="line">   ...</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></div><div class="line"></div><div class="line">     </div><div class="line"></div><div class="line">      <span class="comment">&lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords</span></div><div class="line">           via a brute-force attack --&gt;</div><div class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></div><div class="line">               <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</div><div class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></div><div class="line"></div><div class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></div><div class="line">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</div><div class="line"></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.authenticator.SingleSignOn"</span> /&gt;</span></div><div class="line">        ...</div><div class="line">        <span class="tag">&lt;<span class="name">Context</span>&gt;</span>...<span class="tag">&lt;/<span class="name">Context</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里列出了大概的结构，接下来说明是解析<code>server.xml</code>的流程。</p>
<h2 id="createStartDigester方法"><a href="#createStartDigester方法" class="headerlink" title="createStartDigester方法"></a>createStartDigester方法</h2><p>该方法负责创建一个<code>Digester</code>对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Create and configure the Digester we will be using for startup.</div><div class="line"> * <span class="doctag">@return</span> the main digester to parse server.xml</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> Digester <span class="title">createStartDigester</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> t1=System.currentTimeMillis();</div><div class="line">    <span class="comment">// Initialize the digester</span></div><div class="line">    Digester digester = <span class="keyword">new</span> Digester();</div><div class="line">    digester.setValidating(<span class="keyword">false</span>);</div><div class="line">    digester.setRulesValidation(<span class="keyword">true</span>);</div><div class="line">    HashMap&lt;Class&lt;?&gt;, List&lt;String&gt;&gt; fakeAttributes = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    ArrayList&lt;String&gt; attrs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    attrs.add(<span class="string">"className"</span>);</div><div class="line">    fakeAttributes.put(Object.class, attrs);</div><div class="line">    digester.setFakeAttributes(fakeAttributes);</div><div class="line">    digester.setUseContextClassLoader(<span class="keyword">true</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 增加创建server对象的规则</span></div><div class="line">    <span class="comment">// Configure the actions we will be using</span></div><div class="line">    digester.addObjectCreate(<span class="string">"Server"</span>,</div><div class="line">                             <span class="string">"org.apache.catalina.core.StandardServer"</span>,</div><div class="line">                             <span class="string">"className"</span>);</div><div class="line">    <span class="comment">// 增加设置Server属性的规则，用户在Server对象创建完之后设置Server对象的属性值</span></div><div class="line">    digester.addSetProperties(<span class="string">"Server"</span>);</div><div class="line">    <span class="comment">// Server对象创建完成后，会调用它前一个对象的setServer方法，并把自己作为参数</span></div><div class="line">    digester.addSetNext(<span class="string">"Server"</span>,</div><div class="line">                        <span class="string">"setServer"</span>,</div><div class="line">                        <span class="string">"org.apache.catalina.Server"</span>);</div><div class="line"></div><div class="line">    digester.addObjectCreate(<span class="string">"Server/GlobalNamingResources"</span>,</div><div class="line">                             <span class="string">"org.apache.catalina.deploy.NamingResourcesImpl"</span>);</div><div class="line">    digester.addSetProperties(<span class="string">"Server/GlobalNamingResources"</span>);</div><div class="line">    digester.addSetNext(<span class="string">"Server/GlobalNamingResources"</span>,</div><div class="line">                        <span class="string">"setGlobalNamingResources"</span>,</div><div class="line">                        <span class="string">"org.apache.catalina.deploy.NamingResourcesImpl"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//创建listener，其中第二个参数为空，表示必须在配置文件中指定className</span></div><div class="line">    digester.addObjectCreate(<span class="string">"Server/Listener"</span>,</div><div class="line">                             <span class="keyword">null</span>, <span class="comment">// MUST be specified in the element</span></div><div class="line">                             <span class="string">"className"</span>);</div><div class="line">    digester.addSetProperties(<span class="string">"Server/Listener"</span>);</div><div class="line">    digester.addSetNext(<span class="string">"Server/Listener"</span>,</div><div class="line">                        <span class="string">"addLifecycleListener"</span>,</div><div class="line">                        <span class="string">"org.apache.catalina.LifecycleListener"</span>);</div><div class="line"></div><div class="line">    digester.addObjectCreate(<span class="string">"Server/Service"</span>,</div><div class="line">                             <span class="string">"org.apache.catalina.core.StandardService"</span>,</div><div class="line">                             <span class="string">"className"</span>);</div><div class="line">    digester.addSetProperties(<span class="string">"Server/Service"</span>);</div><div class="line">    digester.addSetNext(<span class="string">"Server/Service"</span>,</div><div class="line">                        <span class="string">"addService"</span>,</div><div class="line">                        <span class="string">"org.apache.catalina.Service"</span>);</div><div class="line"></div><div class="line">    digester.addObjectCreate(<span class="string">"Server/Service/Listener"</span>,</div><div class="line">                             <span class="keyword">null</span>, <span class="comment">// MUST be specified in the element</span></div><div class="line">                             <span class="string">"className"</span>);</div><div class="line">    digester.addSetProperties(<span class="string">"Server/Service/Listener"</span>);</div><div class="line">    digester.addSetNext(<span class="string">"Server/Service/Listener"</span>,</div><div class="line">                        <span class="string">"addLifecycleListener"</span>,</div><div class="line">                        <span class="string">"org.apache.catalina.LifecycleListener"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//Executor</span></div><div class="line">    digester.addObjectCreate(<span class="string">"Server/Service/Executor"</span>,</div><div class="line">                     <span class="string">"org.apache.catalina.core.StandardThreadExecutor"</span>,</div><div class="line">                     <span class="string">"className"</span>);</div><div class="line">    digester.addSetProperties(<span class="string">"Server/Service/Executor"</span>);</div><div class="line"></div><div class="line">    digester.addSetNext(<span class="string">"Server/Service/Executor"</span>,</div><div class="line">                        <span class="string">"addExecutor"</span>,</div><div class="line">                        <span class="string">"org.apache.catalina.Executor"</span>);</div><div class="line"></div><div class="line"></div><div class="line">    digester.addRule(<span class="string">"Server/Service/Connector"</span>,</div><div class="line">                     <span class="keyword">new</span> ConnectorCreateRule());</div><div class="line">    digester.addRule(<span class="string">"Server/Service/Connector"</span>,</div><div class="line">                     <span class="keyword">new</span> SetAllPropertiesRule(<span class="keyword">new</span> String[]&#123;<span class="string">"executor"</span>, <span class="string">"sslImplementationName"</span>&#125;));</div><div class="line">    digester.addSetNext(<span class="string">"Server/Service/Connector"</span>,</div><div class="line">                        <span class="string">"addConnector"</span>,</div><div class="line">                        <span class="string">"org.apache.catalina.connector.Connector"</span>);</div><div class="line"></div><div class="line">    digester.addObjectCreate(<span class="string">"Server/Service/Connector/SSLHostConfig"</span>,</div><div class="line">                             <span class="string">"org.apache.tomcat.util.net.SSLHostConfig"</span>);</div><div class="line">    digester.addSetProperties(<span class="string">"Server/Service/Connector/SSLHostConfig"</span>);</div><div class="line">    digester.addSetNext(<span class="string">"Server/Service/Connector/SSLHostConfig"</span>,</div><div class="line">            <span class="string">"addSslHostConfig"</span>,</div><div class="line">            <span class="string">"org.apache.tomcat.util.net.SSLHostConfig"</span>);</div><div class="line"></div><div class="line">    digester.addRule(<span class="string">"Server/Service/Connector/SSLHostConfig/Certificate"</span>,</div><div class="line">                     <span class="keyword">new</span> CertificateCreateRule());</div><div class="line">    digester.addRule(<span class="string">"Server/Service/Connector/SSLHostConfig/Certificate"</span>,</div><div class="line">                     <span class="keyword">new</span> SetAllPropertiesRule(<span class="keyword">new</span> String[]&#123;<span class="string">"type"</span>&#125;));</div><div class="line">    digester.addSetNext(<span class="string">"Server/Service/Connector/SSLHostConfig/Certificate"</span>,</div><div class="line">                        <span class="string">"addCertificate"</span>,</div><div class="line">                        <span class="string">"org.apache.tomcat.util.net.SSLHostConfigCertificate"</span>);</div><div class="line"></div><div class="line">    digester.addObjectCreate(<span class="string">"Server/Service/Connector/Listener"</span>,</div><div class="line">                             <span class="keyword">null</span>, <span class="comment">// MUST be specified in the element</span></div><div class="line">                             <span class="string">"className"</span>);</div><div class="line">    digester.addSetProperties(<span class="string">"Server/Service/Connector/Listener"</span>);</div><div class="line">    digester.addSetNext(<span class="string">"Server/Service/Connector/Listener"</span>,</div><div class="line">                        <span class="string">"addLifecycleListener"</span>,</div><div class="line">                        <span class="string">"org.apache.catalina.LifecycleListener"</span>);</div><div class="line"></div><div class="line">    digester.addObjectCreate(<span class="string">"Server/Service/Connector/UpgradeProtocol"</span>,</div><div class="line">                              <span class="keyword">null</span>, <span class="comment">// MUST be specified in the element</span></div><div class="line">                              <span class="string">"className"</span>);</div><div class="line">    digester.addSetProperties(<span class="string">"Server/Service/Connector/UpgradeProtocol"</span>);</div><div class="line">    digester.addSetNext(<span class="string">"Server/Service/Connector/UpgradeProtocol"</span>,</div><div class="line">                        <span class="string">"addUpgradeProtocol"</span>,</div><div class="line">                        <span class="string">"org.apache.coyote.UpgradeProtocol"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Add RuleSets for nested elements</span></div><div class="line">    digester.addRuleSet(<span class="keyword">new</span> NamingRuleSet(<span class="string">"Server/GlobalNamingResources/"</span>));</div><div class="line">    digester.addRuleSet(<span class="keyword">new</span> EngineRuleSet(<span class="string">"Server/Service/"</span>));</div><div class="line">    digester.addRuleSet(<span class="keyword">new</span> HostRuleSet(<span class="string">"Server/Service/Engine/"</span>));</div><div class="line">    digester.addRuleSet(<span class="keyword">new</span> ContextRuleSet(<span class="string">"Server/Service/Engine/Host/"</span>));</div><div class="line">    addClusterRuleSet(digester, <span class="string">"Server/Service/Engine/Host/Cluster/"</span>);</div><div class="line">    digester.addRuleSet(<span class="keyword">new</span> NamingRuleSet(<span class="string">"Server/Service/Engine/Host/Context/"</span>));</div><div class="line"></div><div class="line">    <span class="comment">// When the 'engine' is found, set the parentClassLoader.</span></div><div class="line">    digester.addRule(<span class="string">"Server/Service/Engine"</span>,</div><div class="line">                     <span class="keyword">new</span> SetParentClassLoaderRule(parentClassLoader));</div><div class="line">    addClusterRuleSet(digester, <span class="string">"Server/Service/Engine/Cluster/"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t2=System.currentTimeMillis();</div><div class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">        log.debug(<span class="string">"Digester for server.xml created "</span> + ( t2-t1 ));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (digester);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面我只注释了创建Server对象的部分，其他的原理都类似，就不多说了，这里要注意一个地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Server对象创建完成后，会调用它前一个对象的setServer方法，并把自己作为参数</span></div><div class="line">digester.addSetNext(<span class="string">"Server"</span>, <span class="string">"setServer"</span>, <span class="string">"org.apache.catalina.Server"</span>);</div></pre></td></tr></table></figure>
<p>回顾一下<code>load</code>方法中的这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将Catalina对象压入栈底，server对象生成之后会调用当前对象的setServer方法来设置server对象</span></div><div class="line">digester.push(<span class="keyword">this</span>);</div><div class="line">digester.parse(inputSource);</div></pre></td></tr></table></figure>
<p>意思就是把当前的<code>Catalina</code>对象压入栈底，然后解析配置文件。所以在Server对象创建完成后，会调用<code>Catalina</code>对象的setServer方法。</p>
<p>这里简单介绍一下<code>Digester</code>解析的原理：</p>
<ul>
<li>Digester实例有一个内部栈用来临时存储对象。当addObjectCreate方法实例化一个类时，就将结果放到栈中。</li>
<li>当调用两个addObjectCreate方法时，第一个对象首先放入栈中，接着是第二个对象。</li>
<li>addSetNext方法用于创建两个对象之间的关系，其通过调用第一个对象指定的方法并以第二个对象作为参数传递给这个方法。</li>
</ul>
<p>有关<code>Digester</code>库的更详细的用法，请自行查找相关资料。</p>
<h2 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h2><p>这里才是真正启动tomcat的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Start a new server instance.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</div><div class="line">        load();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</div><div class="line">        log.fatal(<span class="string">"Cannot start server. Server instance is not configured."</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line">    <span class="comment">// Start the new server</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 启动server</span></div><div class="line">        getServer().start();</div><div class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</div><div class="line">        log.fatal(sm.getString(<span class="string">"catalina.serverStartFail"</span>), e);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            getServer().destroy();</div><div class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e1) &#123;</div><div class="line">            log.debug(<span class="string">"destroy() failed for failed Server "</span>, e1);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</div><div class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</div><div class="line">        log.info(<span class="string">"Server startup in "</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">" ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Register shutdown hook</span></div><div class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</div><div class="line">        <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</div><div class="line">            shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</div><div class="line">        &#125;</div><div class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</div><div class="line"></div><div class="line">        <span class="comment">// If JULI is being used, disable JULI's shutdown hook since</span></div><div class="line">        <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></div><div class="line">        <span class="comment">// if JULI's hook completes before the CatalinaShutdownHook()</span></div><div class="line">        LogManager logManager = LogManager.getLogManager();</div><div class="line">        <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</div><div class="line">            ((ClassLoaderLogManager) logManager).setUseShutdownHook(</div><div class="line">                    <span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (await) &#123;</div><div class="line">        await();</div><div class="line">        stop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>await</code>在开头已经讨论过，就不说了。这里的<code>getServer().start()</code>是负责启动server对象的，其实server对象需要做的只是启动<code>globalNamingResources</code>和<code>service</code>，进而会启动整个tomcat，通过上面给出的<code>server.xml</code>文件的结构也可以知道，因为<code>GlobalNamingResources</code>和<code>Service</code>是<code>Server</code>的子元素。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，<code>Catalina</code>的初始化和启动工作流程算是完成了。</p>
<p>由<a href="/2016/11/26/Tomcat源码：Bootstrap启动流程/">上一篇：Tomcat源码：Bootstrap启动流程</a>和这篇文章来看，我们已经大概了解了tomcat的启动过程，所以可以总结出来tomcat的各个组件的层次关系大概如下图所示：</p>
<img src="/2016/11/27/Tomcat源码：Catalina启动流程/tomcat-components.png" alt="tomcat-components.png" title="">
<p>层次结构还算比较清晰的，接下来就是各个组件的初始化和启动的工作流程，这些流程后续有时间也会详细讨论。</p>
<p>睡觉。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat源码：Bootstrap启动流程]]></title>
      <url>http://www.ideabuffer.cn/2016/11/26/Tomcat%E6%BA%90%E7%A0%81%EF%BC%9ABootstrap%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Tomcat的启动流程从整体上来说并不算复杂，启动的入口就是从Bootstrap类的main方法开始的，这篇文章就让我们来看一下Bootstrap这个类都干了些什么。</p>
<h2 id="Bootstrap类中的变量"><a href="#Bootstrap类中的变量" class="headerlink" title="Bootstrap类中的变量"></a>Bootstrap类中的变量</h2><p>首先看下Bootstrap都定义了哪些变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Bootstrap类的引用</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap daemon = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="comment">// 这两个路径一般都是tomcat的根目录，即webapp的父目录</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaBaseFile;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaHomeFile;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATH_PATTERN = Pattern.compile(<span class="string">"(\".*?\")|(([^,])*)"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 这个其实就是`org.apache.catalina.startup.Catalina`对象，它是真正负责启动server的对象</span></div><div class="line"><span class="keyword">private</span> Object catalinaDaemon = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="comment">// tomcat涉及到的类加载器</span></div><div class="line">ClassLoader commonLoader = <span class="keyword">null</span>;</div><div class="line">ClassLoader catalinaLoader = <span class="keyword">null</span>;</div><div class="line">ClassLoader sharedLoader = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Tomcat的类加载器"><a href="#Tomcat的类加载器" class="headerlink" title="Tomcat的类加载器"></a>Tomcat的类加载器</h2><p>首先看下JVM的类加载器的结构：</p>
<img src="/2016/11/26/Tomcat源码：Bootstrap启动流程/jvm-class-loader.png" alt="jvm-class-loader.png" title="">
<ul>
<li>Bootstrap：引导类加载器，负责加载<code>rt.jar</code></li>
<li>Extension：扩展类加载器，负责加载<code>jre/lib/ext</code>中的jar</li>
<li>System：系统类加载器，负责加载指定classpath中的jar</li>
</ul>
<p>下面来看一下tomcat的类加载器的结构：</p>
<img src="/2016/11/26/Tomcat源码：Bootstrap启动流程/tomcat-class-loader.png" alt="tomcat-class-loader.png" title="">
<ul>
<li>Bootstrap：负责加载JVM启动时所需要的类以及<code>$JAVA_HOME/jre/lib/ext</code>目录中的类。相当于Java类加载器的Bootstrap和Extension。</li>
<li>System：负责加载<code>$CATALINA_HOME/bin</code>目录下的类，比如<code>bootstrap.jar</code></li>
<li>Common：负责加载tomcat使用以及应用通用的一些类，位于<code>$CATALINA_HOME/lib</code>或<code>$CATALINA_BASE/lib</code>下的jar，比如<code>servlet-api.jar</code></li>
<li>WebappX：每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于该应用下的<code>WEB-INF/lib</code>中的jar文件和<code>WEB-INF/classes</code>中的class文件</li>
</ul>
<p>在tomcat中，如果要加载一个类，那么他的加载顺序为：</p>
<ol>
<li><p>使用bootstrap引导类加载器加载</p>
</li>
<li><p>使用system系统类加载器加载</p>
</li>
<li><p>使用应用类加载器在<code>WEB-INF/classes</code>中加载</p>
</li>
<li><p>使用应用类加载器在<code>WEB-INF/lib</code>中加载</p>
</li>
<li><p>使用common类加载器在<code>$CATALINA_HOME/lib</code>或<code>$CATALINA_BASE/lib</code>中加载</p>
</li>
</ol>
<p>参考：<a href="http://tomcat.apache.org/tomcat-8.5-doc/class-loader-howto.html" target="_blank" rel="external">tomcat-8.5-doc</a></p>
<h2 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h2><p>在static代码块中，主要是对一些路径进行初始化。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    <span class="comment">//当前tomcat的路径，其实就是tomcat所在的目录的路径</span></div><div class="line">    <span class="comment">// Will always be non-null</span></div><div class="line">    String userDir = System.getProperty(<span class="string">"user.dir"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 该路径是设置的catalina.home指定的路径</span></div><div class="line">    <span class="comment">// Home first</span></div><div class="line">    String home = System.getProperty(Globals.CATALINA_HOME_PROP);</div><div class="line">    File homeFile = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (home != <span class="keyword">null</span>) &#123;</div><div class="line">        File f = <span class="keyword">new</span> File(home);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            homeFile = f.getCanonicalFile();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">            homeFile = f.getAbsoluteFile();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// First fall-back. See if current directory is a bin directory</span></div><div class="line">        <span class="comment">// in a normal Tomcat install</span></div><div class="line">        File bootstrapJar = <span class="keyword">new</span> File(userDir, <span class="string">"bootstrap.jar"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (bootstrapJar.exists()) &#123;</div><div class="line">            File f = <span class="keyword">new</span> File(userDir, <span class="string">".."</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                homeFile = f.getCanonicalFile();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">                homeFile = f.getAbsoluteFile();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Second fall-back. Use current directory</span></div><div class="line">        File f = <span class="keyword">new</span> File(userDir);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            homeFile = f.getCanonicalFile();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">            homeFile = f.getAbsoluteFile();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    catalinaHomeFile = homeFile;</div><div class="line">    System.setProperty(</div><div class="line">            Globals.CATALINA_HOME_PROP, catalinaHomeFile.getPath());</div><div class="line"></div><div class="line">    <span class="comment">// Then base</span></div><div class="line">    String base = System.getProperty(Globals.CATALINA_BASE_PROP);</div><div class="line">    </div><div class="line">    <span class="comment">// 可见，如果没有设置base路径，默认就是catalina.home指定的路径</span></div><div class="line">    <span class="keyword">if</span> (base == <span class="keyword">null</span>) &#123;</div><div class="line">        catalinaBaseFile = catalinaHomeFile;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        File baseFile = <span class="keyword">new</span> File(base);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            baseFile = baseFile.getCanonicalFile();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">            baseFile = baseFile.getAbsoluteFile();</div><div class="line">        &#125;</div><div class="line">        catalinaBaseFile = baseFile;</div><div class="line">    &#125;</div><div class="line">    System.setProperty(</div><div class="line">            Globals.CATALINA_BASE_PROP, catalinaBaseFile.getPath());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上可见，主要是设置了一些运行时所需要的路径，例如要设置catalina.home，如果你要运行tomcat源码的话，可以在启动选项的VM options中设置<code>-Dcatalina.home=&quot;/Users/sangjian/dev/source-files/apache-tomcat-8.5.4-src/output/build&quot;</code>来指定。例如：</p>
<img src="/2016/11/26/Tomcat源码：Bootstrap启动流程/B2439EFA-6276-425A-A807-C66B975E59F6.png" alt="B2439EFA-6276-425A-A807-C66B975E59F6.png" title="">
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Main method and entry point when starting Tomcat via the provided</div><div class="line"> * scripts.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> args Command line arguments to be processed</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//创建Bootstarp类型的对象  </span></div><div class="line">        <span class="comment">// Don't set daemon until init() has completed</span></div><div class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            bootstrap.init();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            handleThrowable(t);</div><div class="line">            t.printStackTrace();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        daemon = bootstrap;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// When running as a service the call to stop will be on a new</span></div><div class="line">        <span class="comment">// thread so make sure the correct class loader is used to prevent</span></div><div class="line">        <span class="comment">// a range of class not found exceptions.</span></div><div class="line">        Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        String command = <span class="string">"start"</span>;</div><div class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            command = args[args.length - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (command.equals(<span class="string">"startd"</span>)) &#123;</div><div class="line">            args[args.length - <span class="number">1</span>] = <span class="string">"start"</span>;</div><div class="line">            daemon.load(args);</div><div class="line">            daemon.start();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"stopd"</span>)) &#123;</div><div class="line">            args[args.length - <span class="number">1</span>] = <span class="string">"stop"</span>;</div><div class="line">            daemon.stop();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"start"</span>)) &#123;</div><div class="line">            daemon.setAwait(<span class="keyword">true</span>);</div><div class="line">            daemon.load(args);</div><div class="line">            daemon.start();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"stop"</span>)) &#123;</div><div class="line">            daemon.stopServer(args);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"configtest"</span>)) &#123;</div><div class="line">            daemon.load(args);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span>==daemon.getServer()) &#123;</div><div class="line">                System.exit(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            System.exit(<span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            log.warn(<span class="string">"Bootstrap: command \""</span> + command + <span class="string">"\" does not exist."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="comment">// Unwrap the Exception for clearer error reporting</span></div><div class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</div><div class="line">                t.getCause() != <span class="keyword">null</span>) &#123;</div><div class="line">            t = t.getCause();</div><div class="line">        &#125;</div><div class="line">        handleThrowable(t);</div><div class="line">        t.printStackTrace();</div><div class="line">        System.exit(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实整个流程很简单，总结如下：</p>
<ol>
<li>创建一个自身对象并调用<code>init</code>方法初始化，赋值给daemon</li>
<li>判断参数，默认是start</li>
<li>执行<code>daemon.load</code>方法，判断参数类型，反射调用<code>org.apache.catalina.startup.Catalina</code>对象的<code>load</code>方法</li>
<li>执行<code>daemon.start</code>方法，反射调用<code>org.apache.catalina.startup.Catalina</code>对象的<code>start</code>方法</li>
</ol>
<h2 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Initialize daemon.</div><div class="line"> * <span class="doctag">@throws</span> Exception Fatal initialization error</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化类加载器</span></div><div class="line">    initClassLoaders();</div><div class="line"></div><div class="line">    <span class="comment">// 设置当前线程的类加载器</span></div><div class="line">    Thread.currentThread().setContextClassLoader(catalinaLoader);</div><div class="line"></div><div class="line">    SecurityClassLoad.securityClassLoad(catalinaLoader);</div><div class="line"></div><div class="line">    <span class="comment">// Load our startup class and call its process() method</span></div><div class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</div><div class="line">        log.debug(<span class="string">"Loading startup class"</span>);</div><div class="line">    Class&lt;?&gt; startupClass =</div><div class="line">        catalinaLoader.loadClass</div><div class="line">        (<span class="string">"org.apache.catalina.startup.Catalina"</span>);</div><div class="line">    Object startupInstance = startupClass.newInstance();</div><div class="line"></div><div class="line">    <span class="comment">// Set the shared extensions class loader</span></div><div class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</div><div class="line">        log.debug(<span class="string">"Setting startup class properties"</span>);</div><div class="line">    String methodName = <span class="string">"setParentClassLoader"</span>;</div><div class="line">    Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</div><div class="line">    paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">"java.lang.ClassLoader"</span>);</div><div class="line">    Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * sharedLoader为加载$CATALINA_HOME/lib目录的类加载器</div><div class="line">     * 其实在Tomcat5之后，并取消了catalinaLoader和sharedLoader，而默认只设置了commonLoader</div><div class="line">     * 在默认配置的情况下，这里使用sharedLoader的来加载class时，还是会通过commonLoader来加载</div><div class="line">     * 因为sharedLoader的parentClassLoader是catalinaLoader，catalinaLoder的parentClassLoader是commonLoader</div><div class="line">     * 但在这里，这3个加载器都是commonLoader这个对象，这个稍后会说到</div><div class="line">     */</div><div class="line">    paramValues[<span class="number">0</span>] = sharedLoader;</div><div class="line">    Method method =</div><div class="line">        startupInstance.getClass().getMethod(methodName, paramTypes);</div><div class="line">    </div><div class="line">    <span class="comment">// 设置org.apache.catalina.startup.Catalina对象的parentClassloader</span></div><div class="line">    method.invoke(startupInstance, paramValues);</div><div class="line"></div><div class="line">    catalinaDaemon = startupInstance;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>init方法主要做了以下几件事：</p>
<ol>
<li>初始化类加载器</li>
<li>设置当前线程的类加载器</li>
<li>创建<code>org.apache.catalina.startup.Catalina</code>对象<code>startupInstance</code></li>
<li>反射调用<code>org.apache.catalina.startup.Catalina</code>对象的<code>setParentClassLoader</code>方法，设置父加载器为<code>sharedLoader</code></li>
<li>将<code>startupInstance</code>赋值给<code>catalinaDaemon</code></li>
</ol>
<h2 id="initClassLoaders和createClassLoader方法"><a href="#initClassLoaders和createClassLoader方法" class="headerlink" title="initClassLoaders和createClassLoader方法"></a>initClassLoaders和createClassLoader方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClassLoaders</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        commonLoader = createClassLoader(<span class="string">"common"</span>, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span>( commonLoader == <span class="keyword">null</span> ) &#123;</div><div class="line">            <span class="comment">// no config file, default to this loader - we might be in a 'single' env.</span></div><div class="line">            commonLoader=<span class="keyword">this</span>.getClass().getClassLoader();</div><div class="line">        &#125;</div><div class="line">        catalinaLoader = createClassLoader(<span class="string">"server"</span>, commonLoader);</div><div class="line">        sharedLoader = createClassLoader(<span class="string">"shared"</span>, commonLoader);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        handleThrowable(t);</div><div class="line">        log.error(<span class="string">"Class loader creation threw exception"</span>, t);</div><div class="line">        System.exit(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(String name, ClassLoader parent)</span></span></div><div class="line">    <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">    String value = CatalinaProperties.getProperty(name + <span class="string">".loader"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 如果catalina.properties文件中没有值，则返回parent</span></div><div class="line">    <span class="keyword">if</span> ((value == <span class="keyword">null</span>) || (value.equals(<span class="string">""</span>)))</div><div class="line">        <span class="keyword">return</span> parent;</div><div class="line"></div><div class="line">    value = replace(value);</div><div class="line"></div><div class="line">    List&lt;Repository&gt; repositories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    String[] repositoryPaths = getPaths(value);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (String repository : repositoryPaths) &#123;</div><div class="line">        <span class="comment">// Check for a JAR URL repository</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line">            URL url = <span class="keyword">new</span> URL(repository);</div><div class="line">            repositories.add(</div><div class="line">                    <span class="keyword">new</span> Repository(repository, RepositoryType.URL));</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</div><div class="line">            <span class="comment">// Ignore</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Local repository</span></div><div class="line">        <span class="keyword">if</span> (repository.endsWith(<span class="string">"*.jar"</span>)) &#123;</div><div class="line">            repository = repository.substring</div><div class="line">                (<span class="number">0</span>, repository.length() - <span class="string">"*.jar"</span>.length());</div><div class="line">            repositories.add(</div><div class="line">                    <span class="keyword">new</span> Repository(repository, RepositoryType.GLOB));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (repository.endsWith(<span class="string">".jar"</span>)) &#123;</div><div class="line">            repositories.add(</div><div class="line">                    <span class="keyword">new</span> Repository(repository, RepositoryType.JAR));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            repositories.add(</div><div class="line">                    <span class="keyword">new</span> Repository(repository, RepositoryType.DIR));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ClassLoaderFactory.createClassLoader(repositories, parent);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基于之前介绍的tomcat的类加载器，这两个方法应该比较好理解了，这里需要注意的是，在Tomcat5之后，Tomcat的类加载器发生了变化，默认是没有catalinaLoader和sharedLoader的路径了，这个可以通过查看<code>catalina.properties</code>文件来说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">common.loader=&quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</div><div class="line"></div><div class="line">server.loader=</div><div class="line"></div><div class="line">shared.loader=</div></pre></td></tr></table></figure>
<p>可见，默认只设置了commonLoader。从<code>createClassLoader</code>方法可以看出，后两个loader的值是空的，所以commonLoader,catalinaLoader和sharedLoader都是同一个对象。</p>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Load daemon.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String[] arguments)</span></span></div><div class="line">    <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Call the load() method</span></div><div class="line">    String methodName = <span class="string">"load"</span>;</div><div class="line">    Object param[];</div><div class="line">    Class&lt;?&gt; paramTypes[];</div><div class="line">    <span class="keyword">if</span> (arguments==<span class="keyword">null</span> || arguments.length==<span class="number">0</span>) &#123;</div><div class="line">        paramTypes = <span class="keyword">null</span>;</div><div class="line">        param = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        paramTypes = <span class="keyword">new</span> Class[<span class="number">1</span>];</div><div class="line">        paramTypes[<span class="number">0</span>] = arguments.getClass();</div><div class="line">        param = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">        param[<span class="number">0</span>] = arguments;</div><div class="line">    &#125;</div><div class="line">    Method method =</div><div class="line">        catalinaDaemon.getClass().getMethod(methodName, paramTypes);</div><div class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</div><div class="line">        log.debug(<span class="string">"Calling startup class "</span> + method);</div><div class="line">    method.invoke(catalinaDaemon, param);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这不用多说了吧，还是调用<code>org.apache.catalina.startup.Catalina</code>对象的<code>load</code>方法。</p>
<h2 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Start the Catalina daemon.</div><div class="line"> * <span class="doctag">@throws</span> Exception Fatal start error</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">throws</span> Exception &#123;</div><div class="line">    <span class="keyword">if</span>( catalinaDaemon==<span class="keyword">null</span> ) init();</div><div class="line"></div><div class="line">    Method method = catalinaDaemon.getClass().getMethod(<span class="string">"start"</span>, (Class [] )<span class="keyword">null</span>);</div><div class="line">    method.invoke(catalinaDaemon, (Object [])<span class="keyword">null</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更简单是不是？</p>
<p>以上就是Bootstrap类的工作，接下来就是Catalina需要做的事了，所以从这个流程来看，Bootstrap所做的工作还是很简单的。关于Catalina的分析下一篇文章继续吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>http://www.ideabuffer.cn/2016/11/25/test/</url>
      <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><span id="encrypt-message">Welcome to my blog, enter password to read.</span><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1/KZik1a7qPQXxJz0ssuOS2GFOh87F9N1oKkCqx7vprymJGlsMKRCLgE5Jfr6Y0Ui/k45qcYPQuINSYHHZ9HLrChQIP+Vir7GozzbImDDGAkdIvWFi7cPW2 </div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux配置调优：最大打开文件描述符个数]]></title>
      <url>http://www.ideabuffer.cn/2016/11/20/Linux%E9%85%8D%E7%BD%AE%E8%B0%83%E4%BC%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AA%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>一般情况下，Linux默认的最大文件描述符数量是1024，对于一般的程序来说1024应该是足够使用的（Nginx、系统进程等）。但是像mysql、java等单进程处理大量请求的应用来说就未必了。如果单个进程打开的文件描述符数量超过了系统定义的值，就会提到“too many files open”的错误提示。</p>
<p>如果想查看当前进程打开了多少个文件，可以执行如下命令查看：</p>
<p><code>lsof -n | awk &#39;{print $2}&#39; | sort | uniq -c | sort -nr | more</code></p>
<p>执行后可以看到，第一列是打开的文件描述符数量，第二列是进程id。</p>
<h2 id="限制级别"><a href="#限制级别" class="headerlink" title="限制级别"></a>限制级别</h2><p>最大文件描述符数的限制可以分为3种：</p>
<ul>
<li>shell级别的限制</li>
<li>用户级别的限制</li>
<li>系统级别的限制</li>
</ul>
<a id="more"></a>
<h3 id="shell级别的限制"><a href="#shell级别的限制" class="headerlink" title="shell级别的限制"></a>shell级别的限制</h3><p>如果在shell中执行<code>ulimit -n 4096</code>后，表示将当前用户所有进程能打开的最大文件数量设置为4096.但只是在当前shell中有效，退出后再登录则又恢复成之前的限制。</p>
<h3 id="用户级别的限制"><a href="#用户级别的限制" class="headerlink" title="用户级别的限制"></a>用户级别的限制</h3><p>用户级别的限制是针对具体的用户，一个用户可以通过多个shell打开，这里不针对每一个shell限制。</p>
<h3 id="系统级别的限制"><a href="#系统级别的限制" class="headerlink" title="系统级别的限制"></a>系统级别的限制</h3><p>这一级别的限制是对整个系统的所有用户的限制，可以执行<code>cat /proc/sys/fs/file-max</code>来查看。</p>
<h2 id="ulimit命令"><a href="#ulimit命令" class="headerlink" title="ulimit命令"></a>ulimit命令</h2><h3 id="ulimit功能介绍"><a href="#ulimit功能介绍" class="headerlink" title="ulimit功能介绍"></a>ulimit功能介绍</h3><p>考虑一下如下情况：</p>
<p>一台Linux主机上同时通过ssh登录了20个人，如果在系统资源无限制的情况下，这20个人同时打开了100个文档，并且每个文档的大小大概有20M，这时系统的内存资源就会力不从心了。</p>
<p>ulimit用于限制shell启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、shell进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU时间、单个用户的最大线程数、shell进程所能使用的最大虚拟内存。同时，它支持对资源的硬限制和软限制。</p>
<p>ulimit可以作用于用户登录的当前shell会话，是一种临时限制。在会话终止时便结束限制，在shell中执行该命令不会影响其他shell会话。</p>
<p>如果想要使限制永久生效，则需要设置<code>/etc/security/limits.conf</code>文件，这个文件稍后会讲到。</p>
<h3 id="ulimit的使用说明"><a href="#ulimit的使用说明" class="headerlink" title="ulimit的使用说明"></a>ulimit的使用说明</h3><p>执行<code>help ulimit</code>命令可以查看一下该命令的使用说明：</p>
<img src="/2016/11/20/Linux配置调优：最大打开文件描述符个数/2016-11-20%201.18.23.png" alt="2016-11-20 1.18.23.png" title="">
<h3 id="ulimit限制最大打开文件描述符个数"><a href="#ulimit限制最大打开文件描述符个数" class="headerlink" title="ulimit限制最大打开文件描述符个数"></a>ulimit限制最大打开文件描述符个数</h3><p>由上可知，如果要限制最大打开文件描述符的个数可以执行以下命令：</p>
<p><code>ulimit -n 1000</code></p>
<p>该命令表示将最大打开文件描述符的个数限制为1000（只在当前shell中有效）。</p>
<p>这里需要注意的地方是，linux资源限制的方式可分为<em>软限制</em>和<em>硬限制</em>。</p>
<p>从<code>ulimit</code>的使用说明来看，<code>ulimit</code>的参数已经包含了软限制和硬限制，<code>-H</code>代表硬限制，<code>-S</code>代表软限制。</p>
<p>例如，执行<code>ulimit -Hn 1000</code>表示将硬限制设置为1000，同样<code>ulimit -Sn 1000</code>表示将软限制设置为1000，如果不指定<code>-H</code>或是<code>-S</code>，则相当于把软限制和硬限制都设置为1000。</p>
<p>它们之间的关系是：</p>
<ul>
<li>软限制起实际限制作用，但不能超过硬限制（除非有root权限）。</li>
<li>普通用户可以在硬限制范围内，更改自己的软限制</li>
<li>普通用户都可以缩小硬限制,但不能扩大硬限制，而root缩小扩大都可以。</li>
</ul>
<p>下面通过几个例子来说明<code>ulimit</code>命令的使用。</p>
<h3 id="ulimit-n的使用"><a href="#ulimit-n的使用" class="headerlink" title="ulimit -n的使用"></a><code>ulimit -n</code>的使用</h3><p>如果你没有配置过，则默认的限制为1024</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ulimit -n</div><div class="line">1024</div></pre></td></tr></table></figure>
<p>将限制设置为2048</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ulimit -n 2048</div></pre></td></tr></table></figure>
<p>查看软限制和硬限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ulimit -Sn</div><div class="line">2048</div><div class="line">[root@localhost ~]# ulimit -Hn</div><div class="line">2048</div></pre></td></tr></table></figure>
<p>对于root用户，可以将增加硬限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ulimit -n 2049</div><div class="line">[root@localhost ~]#</div></pre></td></tr></table></figure>
<p>对于普通用户，通过<code>ulimit -n</code>来查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[sangjian@localhost ~]$ ulimit -n</div><div class="line">1024</div></pre></td></tr></table></figure>
<p>将限制改为1023，执行成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[sangjian@localhost ~]$ ulimit -n 1023</div><div class="line">[sangjian@localhost ~]$</div></pre></td></tr></table></figure>
<p>将限制改为1025，执行失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[sangjian@localhost ~]$ ulimit -n 1025</div><div class="line">-bash: ulimit: open files: 无法修改 limit 值: 不允许的操作</div></pre></td></tr></table></figure>
<p>可见，普通用户只能缩小限制，而不能扩大限制。</p>
<p>刚才说到执行<code>ulimit -n</code>是同时对软限制和硬限制都生效的，现在将软限制改为1000，执行成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[sangjian@localhost ~]$ ulimit -Sn 1000</div><div class="line">[sangjian@localhost ~]$</div></pre></td></tr></table></figure>
<p>将软限制改为1024，执行失败，因为硬限制的值为1023</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[sangjian@localhost ~]$ ulimit -Sn 1024</div><div class="line">-bash: ulimit: open files: 无法修改 limit 值: 无效的参数</div></pre></td></tr></table></figure>
<h2 id="修改最大文件限制数量的方式"><a href="#修改最大文件限制数量的方式" class="headerlink" title="修改最大文件限制数量的方式"></a>修改最大文件限制数量的方式</h2><ul>
<li>通过<code>ulimit -n</code>修改</li>
<li>通过<code>/etc/security/limits.conf</code>文件来修改</li>
<li>通过<code>/proc/sys/fs/file-max</code>文件来修改</li>
</ul>
<h2 id="etc-security-limits-conf"><a href="#etc-security-limits-conf" class="headerlink" title="/etc/security/limits.conf"></a>/etc/security/limits.conf</h2><p>limits.conf文件实际是Linux PAM（插入式认证模块，Pluggable Authentication Modules）中 pam_limits.so 的配置文件，突破系统的默认限制，对系统访问资源有一定保护作用。 limits.conf 和sysctl.conf区别在于limits.conf是针对用户，而sysctl.conf是针对整个系统参数配置。</p>
<p>limits.conf的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">username|@groupname type resource limit</div></pre></td></tr></table></figure>
<p><em>username|@groupname</em>：设置需要被限制的用户名，组名前面加@和用户名区别。也可以用通配符*来做所有用户的限制。</p>
<p><em>type</em>：有 soft，hard 和 -，soft 指的是当前系统生效的设置值。hard 表明系统中所能设定的最大值。soft 的限制不能比har 限制高。用 - 就表明同时设置了 soft 和 hard 的值。</p>
<p><em>resource</em>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　　core			- 限制内核文件的大小</div><div class="line">　　date 			- 最大数据大小</div><div class="line">　　fsize 		- 最大文件大小</div><div class="line">　　memlock 		- 最大锁定内存地址空间</div><div class="line">　　nofile 		- 打开文件的最大数目</div><div class="line">　　rss 			- 最大持久设置大小</div><div class="line">　　stack 		- 最大栈大小</div><div class="line">　　cpu 			- 以分钟为单位的最多 CPU 时间</div><div class="line">　　noproc 		- 进程的最大数目</div><div class="line">　　as 			- 地址空间限制</div><div class="line">　　maxlogins 	- 此用户允许登录的最大数目</div><div class="line">　　maxsyslogins	- 系统所有登录的最大数量</div></pre></td></tr></table></figure>
<p>例如，如果想把最大文件描述符数设置为4096，且对所有用户生效，则在该文件中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">* soft nofile 4096</div><div class="line">* hard nofile 4096</div></pre></td></tr></table></figure>
<h2 id="proc-sys-fs-file-max"><a href="#proc-sys-fs-file-max" class="headerlink" title="/proc/sys/fs/file-max"></a>/proc/sys/fs/file-max</h2><p>该文件是系统级别的限制，可以查看该文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /proc/sys/fs/file-max</div><div class="line">185983</div></pre></td></tr></table></figure>
<p>可以看到，系统级别的最大文件描述符数是185983，该限制是对整个系统的所有用户生效。但是不是就不可以设置更大的限制数量呢？答案是否定的。对于root来说，可以设置大于这个数量的限制，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ulimit -n 185984</div><div class="line">[root@localhost ~]#</div></pre></td></tr></table></figure>
<p>发现执行成功了，说明root是可以修改为更大的限制数量的。</p>
<p>其实，/proc/sys/fs/file-max是系统给出的建议值，系统会计算资源给出一个和合理值，一般跟内存有关系，内存越大，改值越大，但是仅仅是一个建议值，limits.conf的设定完全可以超过/proc/sys/fs/file-max。通过limits.conf文件来配置也是可以的。</p>
<h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><h3 id="ulimit-n设置的是当前用户单个进程能够打开的文件描述符个数还是所有进程的文件描述符个数？"><a href="#ulimit-n设置的是当前用户单个进程能够打开的文件描述符个数还是所有进程的文件描述符个数？" class="headerlink" title="ulimit -n设置的是当前用户单个进程能够打开的文件描述符个数还是所有进程的文件描述符个数？"></a><code>ulimit -n</code>设置的是当前用户单个进程能够打开的文件描述符个数还是所有进程的文件描述符个数？</h3><p>对于第一点，网上这两种说法都有，具体我也做了一些试验，例如，当用<code>vim</code>查看一个文件时，通过另一个shell登录后，查看vim进程的pid：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[sangjian@localhost ~]$ ps -ef | grep vim</div><div class="line">sangjian  6099  6036  0 23:39 pts/0    00:00:00 vim test.sh</div><div class="line">sangjian  6101  5986  0 23:39 pts/3    00:00:00 grep --color=auto vim</div></pre></td></tr></table></figure>
<p>可知，pid是6099，查看<code>/proc/6099/fd</code>中的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[sangjian@localhost ~]$ ll /proc/6099/fd</div><div class="line">总用量 0</div><div class="line">lrwx------. 1 sangjian sangjian 64 11月 19 23:41 0 -&gt; /dev/pts/0</div><div class="line">lrwx------. 1 sangjian sangjian 64 11月 19 23:41 1 -&gt; /dev/pts/0</div><div class="line">lrwx------. 1 sangjian sangjian 64 11月 19 23:39 2 -&gt; /dev/pts/0</div><div class="line">lrwx------. 1 sangjian sangjian 64 11月 19 23:41 4 -&gt; /home/sangjian/.test.sh.swp</div></pre></td></tr></table></figure>
<p>每个进程的信息都会在/proc目录中保存，fd目录为打开的文件描述符，可以看到当前打开了4个文件描述符。</p>
<p>修改<code>/etc/security/limits.conf</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sangjian soft nofile 20</div><div class="line">sangjian hard nofile 20</div></pre></td></tr></table></figure>
<p>将<code>sangjian</code>这个用户的最大打开文件描述符个数设置为20，因为设置太小的话shell登录都不成功。然后新开了6个shell以<code>sangjian</code>这个用户来登录，并且每个都用<code>vim</code>打开一个文件，结果是都可以打开，这也就是说使用<code>ulimit -n</code>限制的是每个进程最大打开文件描述符的数量。</p>
<h3 id="lsof-p-pid查看的结果是否都是该进程打开的文件描述符？"><a href="#lsof-p-pid查看的结果是否都是该进程打开的文件描述符？" class="headerlink" title="lsof -p pid查看的结果是否都是该进程打开的文件描述符？"></a><code>lsof -p pid</code>查看的结果是否都是该进程打开的文件描述符？</h3><p>不都是。</p>
<p><code>lsof</code>命令列出的是一个进程及其子进程与哪些文件有关联。</p>
<p><em>请注意</em>：关联文件和打开文件描述符是不同的，关联文件的数量可能远远大于打开的文件描述符的数量。</p>
<p>比如刚刚查看的vim命令执行后，在<code>/proc</code>目录下查看了打开的文件描述符是4个，那么我们再通过<code>lsof</code>来看一下：</p>
<img src="/2016/11/20/Linux配置调优：最大打开文件描述符个数/2016-11-20%2012.50.44.png" alt="2016-11-20 12.50.44.png" title="">
<p>可以看到，这个数量已经远远大于4了，这是为什么呢？</p>
<p>google找了一些资料，大概原因是<code>lsof</code>会列出系统中所占用的资源,但是这些资源不一定会占用打开的文件描述符(比如共享内存,信号量,消息队列,内存映射等，虽然占用了这些资源但不占用打开文件号)，因此有可能出现<code>cat /proc/sys/fs/file-max</code>的值小于<code>lsof | wc -l</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Nginx配置：虚拟主机（1）]]></title>
      <url>http://www.ideabuffer.cn/2016/11/12/Nginx%E9%85%8D%E7%BD%AE%EF%BC%9A%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="什么是虚拟主机"><a href="#什么是虚拟主机" class="headerlink" title="什么是虚拟主机"></a>什么是虚拟主机</h2><p>虚拟主机使用的是特殊的软硬件技术，它把一台运行在因特网上的服务器主机分成一台台“虚拟”的主机，每<br>台虚拟主机都可以是一个独立的网站，可以具有独立的域名，具有完整的Intemet服务器功能（WWW、FTP、Email等），同一台主机上的虚拟主机之间是完全独立的。从网站访问者来看，每一台虚拟主机和一台独立的主机完全一样。</p>
<p>利用虚拟主机，不用为每个要运行的网站提供一台单独的Nginx服务器或单独运行一组Nginx进程。虚拟主机提供了在同一台服务器、同一组Nginx进程上运行多个网站的功能。</p>
<p>在Nginx下，一个server标签就是一个虚拟主机，有一下3种：</p>
<ul>
<li>基于域名的虚拟主机，通过域名来区分虚拟主机</li>
<li>基于端口的虚拟主机，通过端口来区分虚拟主机</li>
<li>基于IP的虚拟主机，通过IP地址来区分虚拟主机</li>
</ul>
<a id="more"></a>
<h2 id="基于域名的虚拟主机"><a href="#基于域名的虚拟主机" class="headerlink" title="基于域名的虚拟主机"></a>基于域名的虚拟主机</h2><p>该虚拟主机主要应用在外部网站，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">   listen 80;</div><div class="line">   server_name www.abc.com;</div><div class="line">   index index.html;</div><div class="line">   ...</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">   listen 80;</div><div class="line">   server_name blog.abc.com;</div><div class="line">   index index.html;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基于端口的虚拟主机"><a href="#基于端口的虚拟主机" class="headerlink" title="基于端口的虚拟主机"></a>基于端口的虚拟主机</h2><p>该虚拟主机主要应用在公司的内部网站或者网站的后台，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 8080;</div><div class="line">    server_name www.abc.com;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">    listen 8011;</div><div class="line">    server_name blog.abc.com;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基于IP的虚拟主机"><a href="#基于IP的虚拟主机" class="headerlink" title="基于IP的虚拟主机"></a>基于IP的虚拟主机</h2><p>配置该虚拟主机主要是用来通过IP进行访问，一般配置多个IP。配置基于IP的虚拟主机，就是为Nginx服务器提供的每台虚拟主机配置一个不同的IP，所以需要将网卡设置为同时能够监听多个IP地址。</p>
<p>Linux支持IP别名的添加，可以使用<code>ifconfig</code>命令来为同一块网卡添加多个IP别名。</p>
<p>例如，我当前的网络配置如下：</p>
<img src="/2016/11/12/Nginx配置：虚拟主机（1）/2016-11-12%204.14.33.png" alt="2016-11-12 4.14.33.png" title="">
<p>可见，我当前的网卡为enp0s3，ip为192.168.1.125.</p>
<p>接下来需要为enp0s3添加两个IP别名：192.168.1.30和192.168.1.31，作为Nginx基于IP的虚拟主机的IP地址，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo ifconfig enp0s3:0 192.168.1.30 netmask 255.255.255.0 up</div><div class="line">sudo ifconfig enp0s3:1 192.168.1.31 netmask 255.255.255.0 up</div></pre></td></tr></table></figure>
<p>命令中up表示立即启用该别名。</p>
<p>这时再次查看一下网络配置：</p>
<img src="/2016/11/12/Nginx配置：虚拟主机（1）/2016-11-12%204.22.15.png" alt="2016-11-12 4.22.15.png" title="">
<p>可以看到，enp0s3增加了两个别名，enp0s3:0和enp0s3:1，IP分别为192.168.1.30,192.168.1.31。</p>
<p><em>注意：</em></p>
<ul>
<li><p>如果你使用Centos7最小化安装会提示找不到<code>ifconfig</code>命令，这是需要安装net-tools:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum -y install net-tools</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>按照如上方法为enp0s3设置的别名在重启后将会失效，需要重新设置。如果需要永久生效的话可以执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo <span class="built_in">echo</span> <span class="string">"ifconfig enp0s3:0 192.168.1.30 netmask 255.255.255.0 up"</span> &gt;&gt; /etc/rc.local</div><div class="line">sudo <span class="built_in">echo</span> <span class="string">"ifconfig enp0s3:1 192.168.1.31 netmask 255.255.255.0 up"</span> &gt;&gt; /etc/rc.local</div></pre></td></tr></table></figure>
</li>
</ul>
<p>设置好别名之后就可以使用IP地址来配置Nginx的虚拟主机了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line">    server_name 192.168.1.30;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line">    server_name 192.168.1.31;</div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过以上配置后，来自192.168.1.30的请求将由第一个虚拟主机接收和处理，来自192.168.1.31的请求将由第二个虚拟主机接收和处理。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决mysql5.6占用内存过大]]></title>
      <url>http://www.ideabuffer.cn/2016/10/27/%E8%A7%A3%E5%86%B3mysql5-6%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E8%BF%87%E5%A4%A7/</url>
      <content type="html"><![CDATA[<p>虚拟机的内存设置成了1G，跑了两个tomcat和rabbitmq以及redis,mysql启动失败。再次启动有时会成功，但过一会看进程又没有了。</p>
<p>使用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysqld restart</div></pre></td></tr></table></figure></p>
<p>后提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ERROR! MySQL server PID file could not be found!</div><div class="line">Starting MySQL..................................... ERROR! The server quit without updating PID file (/opt/mysql/data/localhost.localdomain.pid).</div></pre></td></tr></table></figure></p>
<p>查看mysql配置文件<code>/etc/my.cnf</code>，查看错误日志文件，是内存太小了的原因。</p>
<a id="more"></a>
<p>调整my.cnf 参数,重新配置即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">performance_schema_max_table_instances=200</div><div class="line">table_definition_cache=200</div><div class="line">table_open_cache=128</div></pre></td></tr></table></figure>
<p>下面附一个相关的my.cnf配置文件的说明<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div></pre></td><td class="code"><pre><div class="line">[client]</div><div class="line">port = 3306</div><div class="line">socket = /tmp/mysql.sock</div><div class="line"> </div><div class="line">[mysqld]</div><div class="line">port = 3306</div><div class="line">socket = /tmp/mysql.sock</div><div class="line"> </div><div class="line">basedir = /usr/local/mysql</div><div class="line">datadir = /data/mysql</div><div class="line">pid-file = /data/mysql/mysql.pid</div><div class="line">user = mysql</div><div class="line">bind-address = 0.0.0.0</div><div class="line">server-id = 1 #表示是本机的序号为1,一般来讲就是master的意思</div><div class="line"> </div><div class="line">skip-name-resolve</div><div class="line"># 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，</div><div class="line"># 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求</div><div class="line"> </div><div class="line">#skip-networking</div><div class="line"> </div><div class="line">back_log = 600</div><div class="line"># MySQL能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用，</div><div class="line"># 然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。</div><div class="line"># 如果期望在一个短时间内有很多连接，你需要增加它。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，</div><div class="line"># 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。</div><div class="line"># 另外，这值（back_log）限于您的操作系统对到来的TCP/IP连接的侦听队列的大小。</div><div class="line"># 你的操作系统在这个队列大小上有它自己的限制（可以检查你的OS文档找出这个变量的最大值），试图设定back_log高于你的操作系统的限制将是无效的。</div><div class="line"> </div><div class="line">max_connections = 1000</div><div class="line"># MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过'conn%'通配符查看当前状态的连接数量，以定夺该值的大小。</div><div class="line"> </div><div class="line">max_connect_errors = 6000</div><div class="line"># 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。</div><div class="line"> </div><div class="line">open_files_limit = 65535</div><div class="line"># MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个，</div><div class="line"># 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。</div><div class="line"> </div><div class="line">table_open_cache = 128</div><div class="line"># MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64</div><div class="line"># 假定系统有200个并发连接，则需将此参数设置为200*N(N为每个连接所需的文件描述符数目)；</div><div class="line"># 当把table_open_cache设置为很大时，如果系统处理不了那么多文件描述符，那么就会出现客户端失效，连接不上</div><div class="line"> </div><div class="line">max_allowed_packet = 4M</div><div class="line"># 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。</div><div class="line"># 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。</div><div class="line"> </div><div class="line">binlog_cache_size = 1M</div><div class="line"># 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K</div><div class="line"> </div><div class="line">max_heap_table_size = 8M</div><div class="line"># 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变</div><div class="line"> </div><div class="line">tmp_table_size = 16M</div><div class="line"># MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。</div><div class="line"># 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。</div><div class="line"># 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果</div><div class="line"> </div><div class="line">read_buffer_size = 2M</div><div class="line"># MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。</div><div class="line"># 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能</div><div class="line"> </div><div class="line">read_rnd_buffer_size = 8M</div><div class="line"># MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，</div><div class="line"># MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大</div><div class="line"> </div><div class="line">sort_buffer_size = 8M</div><div class="line"># MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。</div><div class="line"># 如果不能，可以尝试增加sort_buffer_size变量的大小</div><div class="line"> </div><div class="line">join_buffer_size = 8M</div><div class="line"># 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享</div><div class="line"> </div><div class="line">thread_cache_size = 8</div><div class="line"># 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，</div><div class="line"># 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，</div><div class="line"># 增加这个值可以改善系统性能.通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。(–&gt;表示要调整的值)</div><div class="line"># 根据物理内存设置规则如下：</div><div class="line"># 1G  —&gt; 8</div><div class="line"># 2G  —&gt; 16</div><div class="line"># 3G  —&gt; 32</div><div class="line"># 大于3G  —&gt; 64</div><div class="line"> </div><div class="line">query_cache_size = 8M</div><div class="line">#MySQL的查询缓冲大小（从4.0.1开始，MySQL提供了查询缓冲机制）使用查询缓冲，MySQL将SELECT语句和查询结果存放在缓冲区中，</div><div class="line"># 今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。根据MySQL用户手册，使用查询缓冲最多可以达到238%的效率。</div><div class="line"># 通过检查状态值'Qcache_%'，可以知道query_cache_size设置是否合理：如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，</div><div class="line"># 如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，</div><div class="line"># 这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲</div><div class="line"> </div><div class="line">query_cache_limit = 2M</div><div class="line">#指定单个查询能够使用的缓冲区大小，默认1M</div><div class="line"> </div><div class="line">key_buffer_size = 4M</div><div class="line">#指定用于索引的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，</div><div class="line"># 系统将开始换页并且真的变慢了。对于内存在4GB左右的服务器该参数可设置为384M或512M。通过检查状态值Key_read_requests和Key_reads，</div><div class="line"># 可以知道key_buffer_size设置是否合理。比例key_reads/key_read_requests应该尽可能的低，</div><div class="line"># 至少是1:100，1:1000更好(上述状态值可以使用SHOW STATUS LIKE 'key_read%'获得)。注意：该参数值设置的过大反而会是服务器整体效率降低</div><div class="line"> </div><div class="line">ft_min_word_len = 4</div><div class="line"># 分词词汇最小长度，默认4</div><div class="line"> </div><div class="line">transaction_isolation = REPEATABLE-READ</div><div class="line"># MySQL支持4种事务隔离级别，他们分别是：</div><div class="line"># READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.</div><div class="line"># 如没有指定，MySQL默认采用的是REPEATABLE-READ，ORACLE默认的是READ-COMMITTED</div><div class="line"> </div><div class="line">log_bin = mysql-bin</div><div class="line">binlog_format = mixed</div><div class="line">expire_logs_days = 30 #超过30天的binlog删除</div><div class="line"> </div><div class="line">log_error = /data/mysql/mysql-error.log #错误日志路径</div><div class="line">slow_query_log = 1</div><div class="line">long_query_time = 1 #慢查询时间 超过1秒则为慢查询</div><div class="line">slow_query_log_file = /data/mysql/mysql-slow.log</div><div class="line"> </div><div class="line">performance_schema = 0</div><div class="line">explicit_defaults_for_timestamp</div><div class="line"> </div><div class="line">#lower_case_table_names = 1 #不区分大小写</div><div class="line"> </div><div class="line">skip-external-locking #MySQL选项以避免外部锁定。该选项默认开启</div><div class="line"> </div><div class="line">default-storage-engine = InnoDB #默认存储引擎</div><div class="line"> </div><div class="line">innodb_file_per_table = 1</div><div class="line"># InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间</div><div class="line"># 独立表空间优点：</div><div class="line"># 1．每个表都有自已独立的表空间。</div><div class="line"># 2．每个表的数据和索引都会存在自已的表空间中。</div><div class="line"># 3．可以实现单表在不同的数据库中移动。</div><div class="line"># 4．空间可以回收（除drop table操作处，表空不能自已回收）</div><div class="line"># 缺点：</div><div class="line"># 单表增加过大，如超过100G</div><div class="line"># 结论：</div><div class="line"># 共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files</div><div class="line"> </div><div class="line">innodb_open_files = 500</div><div class="line"># 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300</div><div class="line"> </div><div class="line">innodb_buffer_pool_size = 64M</div><div class="line"># InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.</div><div class="line"># 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少.</div><div class="line"># 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%</div><div class="line"># 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.</div><div class="line"># 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,</div><div class="line"># 所以不要设置的太高.</div><div class="line"> </div><div class="line">innodb_write_io_threads = 4</div><div class="line">innodb_read_io_threads = 4</div><div class="line"># innodb使用后台线程处理数据页上的读写 I/O(输入输出)请求,根据你的 CPU 核数来更改,默认是4</div><div class="line"># 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64</div><div class="line"> </div><div class="line">innodb_thread_concurrency = 0</div><div class="line"># 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量</div><div class="line"> </div><div class="line">innodb_purge_threads = 1</div><div class="line"># InnoDB中的清除操作是一类定期回收无用数据的操作。在之前的几个版本中，清除操作是主线程的一部分，这意味着运行时它可能会堵塞其它的数据库操作。</div><div class="line"># 从MySQL5.5.X版本开始，该操作运行于独立的线程中,并支持更多的并发数。用户可通过设置innodb_purge_threads配置参数来选择清除操作是否使用单</div><div class="line"># 独线程,默认情况下参数设置为0(不使用单独线程),设置为 1 时表示使用单独的清除线程。建议为1</div><div class="line"> </div><div class="line">innodb_flush_log_at_trx_commit = 2</div><div class="line"># 0：如果innodb_flush_log_at_trx_commit的值为0,log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作（执行是由mysql的master thread线程来执行的。</div><div class="line"># 主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件(REDO LOG)中。不论事务是否已经提交）默认的日志文件是ib_logfile0,ib_logfile1</div><div class="line"># 1：当设为默认值1的时候，每次提交事务的时候，都会将log buffer刷写到日志。</div><div class="line"># 2：如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。</div><div class="line"># 每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘</div><div class="line"># 默认值1是为了保证完整的ACID。当然，你可以将这个配置项设为1以外的值来换取更高的性能，但是在系统崩溃的时候，你将会丢失1秒的数据。</div><div class="line"># 设为0的话，mysqld进程崩溃的时候，就会丢失最后1秒的事务。设为2,只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。</div><div class="line"># 总结</div><div class="line"># 设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能</div><div class="line"> </div><div class="line">innodb_log_buffer_size = 2M</div><div class="line"># 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间</div><div class="line"> </div><div class="line">innodb_log_file_size = 32M</div><div class="line"># 此参数确定数据日志文件的大小，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间</div><div class="line"> </div><div class="line">innodb_log_files_in_group = 3</div><div class="line"># 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3</div><div class="line"> </div><div class="line">innodb_max_dirty_pages_pct = 90</div><div class="line"># innodb主线程刷新缓存池中的数据，使脏数据比例小于90%</div><div class="line"> </div><div class="line">innodb_lock_wait_timeout = 120 </div><div class="line"># InnoDB事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用LOCK TABLES语句注意到锁定设置。默认值是50秒</div><div class="line"> </div><div class="line">bulk_insert_buffer_size = 8M</div><div class="line"># 批量插入缓存大小， 这个参数是针对MyISAM存储引擎来说的。适用于在一次性插入100-1000+条记录时， 提高效率。默认值是8M。可以针对数据量的大小，翻倍增加。</div><div class="line"> </div><div class="line">myisam_sort_buffer_size = 8M</div><div class="line"># MyISAM设置恢复表之时使用的缓冲区的尺寸，当在REPAIR TABLE或用CREATE INDEX创建索引或ALTER TABLE过程中排序 MyISAM索引分配的缓冲区</div><div class="line"> </div><div class="line">myisam_max_sort_file_size = 10G</div><div class="line"># 如果临时文件会变得超过索引，不要使用快速排序索引方法来创建一个索引。注释：这个参数以字节的形式给出</div><div class="line"> </div><div class="line">myisam_repair_threads = 1</div><div class="line"># 如果该值大于1，在Repair by sorting过程中并行创建MyISAM表索引(每个索引在自己的线程内)  </div><div class="line"> </div><div class="line">interactive_timeout = 28800</div><div class="line"># 服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。默认值：28800秒（8小时）</div><div class="line"> </div><div class="line">wait_timeout = 28800</div><div class="line"># 服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，</div><div class="line"># 取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时）</div><div class="line"># MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此我们希望客户端在连接到MySQL Server处理完相应的操作后，</div><div class="line"># 应该断开连接并释放占用的内存。如果你的MySQL Server有大量的闲置连接，他们不仅会白白消耗内存，而且如果连接一直在累加而不断开，</div><div class="line"># 最终肯定会达到MySQL Server的连接上限数，这会报'too many connections'的错误。对于wait_timeout的值设定，应该根据系统的运行情况来判断。</div><div class="line"># 在系统运行一段时间后，可以通过show processlist命令查看当前系统的连接状态，如果发现有大量的sleep状态的连接进程，则说明该参数设置的过大，</div><div class="line"># 可以进行适当的调整小些。要同时设置interactive_timeout和wait_timeout才会生效。</div><div class="line"> </div><div class="line">[mysqldump]</div><div class="line">quick</div><div class="line">max_allowed_packet = 16M #服务器发送和接受的最大包长度</div><div class="line"> </div><div class="line">[myisamchk]</div><div class="line">key_buffer_size = 8M</div><div class="line">sort_buffer_size = 8M</div><div class="line">read_buffer = 4M</div><div class="line">write_buffer = 4M</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat 8 介绍]]></title>
      <url>http://www.ideabuffer.cn/2016/09/01/Tomcat-8-%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="Apache-Tomcat-版本介绍"><a href="#Apache-Tomcat-版本介绍" class="headerlink" title="Apache Tomcat 版本介绍"></a>Apache Tomcat 版本介绍</h2><p>Tomcat是一个开源的软件，其实现了Java Servlet, JavaServer Pages, Java Expression Language 以及 Java WebSocket 技术。Java Servlet, JavaServer Pages, Java Expression Language 以及 Java WebSocket 规范是在 <a href="http://www.jcp.org" target="_blank" rel="external">Java Community Process</a> 下开发出来的。</p>
<p>不同版本的Apache Tomcat实现了不同版本的Servlet和JSP规范。它们之间的对应关系如下：</p>
<img src="/2016/09/01/Tomcat-8-介绍/QQ20160901-0-2x.png" alt="QQ20160901-0-2x.png" title="">
<p>当选举一个发布版本时，如果审阅者认为次发布版本已经达到稳定水平，则会选取此版本为稳定版。新的主要版本最初的发布通常从Alpha版本开始,然后经历beta版，最后到稳定版，这通常要经历几个月的时间。不过，稳定版的条件是Java规范的实现都已经完成。也就是说，在所有其他方面被认为是稳定的，但如果规范的实现不是最终的，可能仍然被标记为Beta版。</p>
<p><strong>Alpha</strong>  由于规范的要求和/或一些显著的bug的原因，可能含有大量的未经测试或者缺少的功能，并且预计不会在任何时间内稳定地运行。</p>
<p><strong>Beta</strong> 可能含有一些未经测试的功能和/或一些相对较小的错误。Beta版预计不会稳定地运行。</p>
<p><strong>Stable</strong> 可能包含少量相对较小的错误。稳定版本可以用于进行生产环境使用，预计可以长时间稳定地运行。</p>
<a id="more"></a>
<p>参考：<a href="http://tomcat.apache.org/whichversion.html" target="_blank" rel="external">Apache Tomcat Versions</a></p>
<h2 id="Tomcat-8-0-x-版本"><a href="#Tomcat-8-0-x-版本" class="headerlink" title="Tomcat 8.0.x 版本"></a>Tomcat 8.0.x 版本</h2><p>Tomcat 8.0.x最新的版本是Tomcat 8.0.36。该系列同样实现了 Servlet 3.1, JSP 2.3, EL 3.0 and Web Socket 1.0 规范。该系列版本的新特性有：</p>
<ul>
<li><p>对资源进行了重构，合并了Aliases，VirtualLoader，VirtualDirContext，JAR资源和外部仓库，现在都以单个的、一致的方法进行配置。</p>
</li>
<li><p>新增了当Tomcat未运行时对war包修改的检测。Tomcat会在解压后的目录中创建一个META-INF/war-tracker文件，设置该文件的最后修改时间为war包的最后修改时间。如果Tomcat通过这种机制检测到修改过的war包则会重新部署该web应用（也就是说之前的解压目录会被删除，修改过的war包会重新解压到当前目录）。</p>
</li>
<li><p>新增了支持并行加载的web应用程序的类加载器<code>ParallelWebappClassLoader</code>的实现。</p>
</li>
<li><p><del>实验支持[SPDY] [1]</del>。</p>
</li>
<li><p>连接器默认使用无阻塞I/O。现在HTTP和AJP的连接器默认的都是无阻塞的I/O。</p>
</li>
<li><p>修改了连接器的默认URIEncoding，将之前的ISO-8859-1修改为UTF-8。</p>
</li>
</ul>
<blockquote>
<p><em>SPDY协议是Google提出的基于传输控制协议(TCP)的应用层协议，通过压缩、多路复用和优先级来缩短加载时间。该协议是一种更加快速的内容传输协议。该功能在 Tomcat 8.0.22 版本被删除</em></p>
</blockquote>
<p>参考：<a href="http://tomcat.apache.org/tomcat-8.0-doc/changelog.html" target="_blank" rel="external">Tomcat 8.0.x Changelog</a></p>
<h2 id="Tomcat-8-5-x-版本"><a href="#Tomcat-8-5-x-版本" class="headerlink" title="Tomcat 8.5.x 版本"></a>Tomcat 8.5.x 版本</h2><p>Tomcat 8.5.4于2016年7月12日发布，这个版本的分支来自Tomcat9.0.0.M4。主要的目的是恢复Java 7的兼容性，并支持Servlet3.1，JSP2.3，EL3.0，WebSocket1.1以及1.1 JASPIC规范。</p>
<blockquote>
<p><em>The Tomcat 8.5.x branch was created from the Tomcat 9.0.0.M4 tag. Changes were applied to restore Java 7 compatibility and to align the specification APIs with Servlet 3.1, JSP 2.3, EL 3.0, WebSocket 1.1 and JASPIC 1.1.</em></p>
</blockquote>
<p>该系列版本的主要新特性有：</p>
<ul>
<li><p>新增了 <code>org.apache.catalina.servlet4preview</code> 包，作用是可以尽早地获取Servlet 4.0 的新特性（需要注意的是，这个包Tomcat 9.x将不会出现）。</p>
</li>
<li><p>新增了对 JASPIC (JSR-196) 的支持。</p>
</li>
<li><p>新增了对 HTTP/2 支持。</p>
</li>
<li><p>新增了动态添加 TLS 虚拟主机的功能。</p>
</li>
</ul>
<p>参考：<a href="http://tomcat.apache.org/tomcat-8.5-doc/changelog.html" target="_blank" rel="external">Tomcat 8.5.x Changelog</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux/Centos7设置nginx开机自启动]]></title>
      <url>http://www.ideabuffer.cn/2016/08/26/Linux-Centos7%E8%AE%BE%E7%BD%AEnginx%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
      <content type="html"><![CDATA[<h2 id="新增shell脚本-vi-etc-rc-d-init-d-nginx"><a href="#新增shell脚本-vi-etc-rc-d-init-d-nginx" class="headerlink" title="新增shell脚本 vi /etc/rc.d/init.d/nginx"></a>新增shell脚本 vi /etc/rc.d/init.d/nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"><span class="comment"># chkconfig: 35 85 15  </span></div><div class="line"><span class="comment"># description: Nginx is an HTTP(S) server, HTTP(S) reverse</span></div><div class="line"><span class="built_in">set</span> <span class="_">-e</span></div><div class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin</div><div class="line">DESC=<span class="string">"nginx daemon"</span>  </div><div class="line">NAME=nginx  </div><div class="line">DAEMON=/usr/<span class="built_in">local</span>/nginx/sbin/<span class="variable">$NAME</span>  </div><div class="line">SCRIPTNAME=/etc/init.d/<span class="variable">$NAME</span>  </div><div class="line"><span class="built_in">test</span> -x <span class="variable">$DAEMON</span> || <span class="built_in">exit</span> 0  </div><div class="line"><span class="function"><span class="title">d_start</span></span>()&#123;  </div><div class="line">   <span class="variable">$DAEMON</span> || <span class="built_in">echo</span> -n <span class="string">" already running"</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">d_stop</span></span>() &#123;  </div><div class="line">   <span class="variable">$DAEMON</span> <span class="_">-s</span> quit || <span class="built_in">echo</span> -n <span class="string">" not running"</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">d_reload</span></span>() &#123;  </div><div class="line">   <span class="variable">$DAEMON</span> <span class="_">-s</span> reload || <span class="built_in">echo</span> -n <span class="string">" counld not reload"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span>  </div><div class="line">  start)  </div><div class="line">     <span class="built_in">echo</span> -n <span class="string">"Starting <span class="variable">$DESC</span>:<span class="variable">$NAME</span>"</span></div><div class="line">     d_start</div><div class="line">     <span class="built_in">echo</span> <span class="string">"."</span></div><div class="line">  ;;</div><div class="line">  stop)  </div><div class="line">     <span class="built_in">echo</span> -n <span class="string">"Stopping <span class="variable">$DESC</span>:<span class="variable">$NAME</span>"</span></div><div class="line">     d_stop</div><div class="line">     <span class="built_in">echo</span> <span class="string">"."</span></div><div class="line">  ;;</div><div class="line">  reload)  </div><div class="line">     <span class="built_in">echo</span> -n <span class="string">"Reloading <span class="variable">$DESC</span> configuration..."</span></div><div class="line">     d_reload</div><div class="line">     <span class="built_in">echo</span> <span class="string">"reloaded."</span></div><div class="line">  ;;</div><div class="line">  restart)  </div><div class="line">     <span class="built_in">echo</span> -n <span class="string">"Restarting <span class="variable">$DESC</span>: <span class="variable">$NAME</span>"</span></div><div class="line">     d_stop</div><div class="line">     sleep 2</div><div class="line">     d_start</div><div class="line">     <span class="built_in">echo</span> <span class="string">"."</span></div><div class="line">  ;;</div><div class="line">  *)</div><div class="line">     <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$SCRIPTNAME</span> &#123;start|stop|restart|reload&#125;"</span> &gt;&amp;2</div><div class="line">     <span class="built_in">exit</span> 3</div><div class="line">  ;;</div><div class="line"><span class="keyword">esac</span>  </div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="设置可执行权限"><a href="#设置可执行权限" class="headerlink" title="设置可执行权限"></a>设置可执行权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x /etc/rc.d/init.d/nginx</div></pre></td></tr></table></figure>
<h2 id="添加系统服务"><a href="#添加系统服务" class="headerlink" title="添加系统服务"></a>添加系统服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig --add nginx</div></pre></td></tr></table></figure>
<h2 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig --level 35 nginx on</div></pre></td></tr></table></figure>
<hr>
<p>原文链接: <a href="http://my.oschina.net/tomener/blog/664469" target="_blank" rel="external">http://my.oschina.net/tomener/blog/664469</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS7服务器初步配置]]></title>
      <url>http://www.ideabuffer.cn/2016/08/01/CentOS7%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E6%AD%A5%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>在开发或者部署网站的时候，需要自己配置Linux服务器，本文以Centos7为例，记录了配置Linux服务器的初步流程</p>
<h2 id="第一步：root用户登录"><a href="#第一步：root用户登录" class="headerlink" title="第一步：root用户登录"></a>第一步：root用户登录</h2><p>使用root用户登录远程主机（假定IP地址为192.168.1.125）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh root@192.168.1.125</div></pre></td></tr></table></figure>
<p>这时，会出现警告，提示这是一个新的地址，存在安全风险。接收则输入yes</p>
<img src="/2016/08/01/CentOS7服务器初步配置/-----2016-08-22---10-30-13.png" alt="-----2016-08-22---10-30-13.png" title="">
<a id="more"></a>
<p>登录远程主机之后修改root密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">passwd</div></pre></td></tr></table></figure>
<h2 id="第二步：新建用户"><a href="#第二步：新建用户" class="headerlink" title="第二步：新建用户"></a>第二步：新建用户</h2><p>添加一个用户组admin</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groupadd admin</div></pre></td></tr></table></figure>
<p>然后，添加一个新的用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd <span class="_">-d</span> /home/sangjian <span class="_">-s</span> /bin/bash -m sangjian</div></pre></td></tr></table></figure>
<p>上面命令中，参数d表示指定用户的主目录，参数s指定用户的shell，参数m表示如果该目录不存在，则创建该目录。</p>
<p>设置新用户的密码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">passwd sangjian</div></pre></td></tr></table></figure>
<p>将sangjian添加到用户组admin中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod <span class="_">-a</span> -G admin sangjian</div></pre></td></tr></table></figure>
<p>为sangjian用户设定sudo权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">visudo</div></pre></td></tr></table></figure>
<p>visudo命令会打开文件/etc/sudoers，找到如下一行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root    ALL=(ALL) ALL</div></pre></td></tr></table></figure>
<p>添加一行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sangjian    ALL=(ALL) NOPASSWD: ALL</div></pre></td></tr></table></figure>
<p>上面的NOPASSWD表示，切换sudo的时候，不需要输入密码，我喜欢这样比较省事。如果出于安全考虑，也可以强制要求输入密码。<br>另开一个终端，以sangjian用户登录，检查是否设置成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh sangjian@192.168.1.125</div></pre></td></tr></table></figure>
<h2 id="第三步：SSH设置"><a href="#第三步：SSH设置" class="headerlink" title="第三步：SSH设置"></a>第三步：SSH设置</h2><p>查看本机是否有SSH公钥（一般是~/.ssh/id_rsa.pub），如果没有则可以使用ssh-keygen命令生成<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen</div></pre></td></tr></table></figure></p>
<p>想省事的话可以一直按回车即可</p>
<p>将刚生成的id_rsa.pub文件的内容追加到服务器的authorized_keys文件中<br>可以使用scp命令将生成的id_rsa.pub文件上传到服务器中，再将文件的内容追加到authorized_keys文件中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp ~/.ssh/id_rsa.pub sangjian@192.168.1.125:/home/sangjian/mac_id_rsa.pub</div></pre></td></tr></table></figure></p>
<p>上面的命令是将本地的公钥上传到服务器中的/home/sangjian目录下的mac_id_rsa.pub文件中</p>
<p>再执行追加命令（如果~/.ssh目录不存在，则新建）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat mac_id_rsa.pub &gt; ~/.ssh/authorized_keys</div></pre></td></tr></table></figure></p>
<p>修改SSH配置文件/etc/ssh/sshd_config<br>在配置文件中找到 <code>#Port 22</code>，修改默认的端口，范围可以从1025到65536<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Port 6983</div></pre></td></tr></table></figure></p>
<p>修改如下设置并确保去除了#号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Protocol 2</div><div class="line"><span class="comment">#禁止root用户登录</span></div><div class="line">PermitRootLogin no</div><div class="line"></div><div class="line"><span class="comment">#禁止使用密码登录</span></div><div class="line">PasswordAuthentication no</div><div class="line">PermitEmptyPasswords no</div><div class="line">PasswordAuthentication yes</div></pre></td></tr></table></figure></p>
<p>最后，在配置文件的末尾添加一行用来指定可以登录的用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AllowUsers sangjian</div></pre></td></tr></table></figure></p>
<p>保存退出后，修改authorized_keys和.ssh的文件权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo chmod 700 ~/.ssh/</div><div class="line">sudo chmod 600 ~/.ssh/authorized_keys</div></pre></td></tr></table></figure></p>
<p>确保.ssh的权限为700，authorized_keys的权限为600，否则登录的时候会出现如下错误</p>
<img src="/2016/08/01/CentOS7服务器初步配置/-----2016-08-22---10-54-52.png" alt="-----2016-08-22---10-54-52.png" title="">
<p>查看日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tail -n 20 /var/<span class="built_in">log</span>/secure</div></pre></td></tr></table></figure></p>
<p>可以看到登录时的日志有如下一句</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">localhost sshd[2359]: Authentication refused: bad ownership or modes <span class="keyword">for</span> file /home/sangjian/.ssh/authorized_keys</div></pre></td></tr></table></figure>
<img src="/2016/08/01/CentOS7服务器初步配置/-----2016-08-22---10-58-33.png" alt="-----2016-08-22---10-58-33.png" title="">
<p>重启SSHD<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service sshd restart</div></pre></td></tr></table></figure></p>
<p>检查是否可以免密码登录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh sangjian@192.168.1.125 -p 6983</div></pre></td></tr></table></figure></p>
<p>发现不可以，提示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh: connect to host 192.168.1.125 port 6983: Connection refused</div></pre></td></tr></table></figure></p>
<h2 id="第四步：登录失败问题解决"><a href="#第四步：登录失败问题解决" class="headerlink" title="第四步：登录失败问题解决"></a>第四步：登录失败问题解决</h2><p>出现这一情况主要是防火墙端口开放的问题<br>查看日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo tail -n 20 /var/<span class="built_in">log</span>/secure</div></pre></td></tr></table></figure></p>
<p>发现没有失败的日志输出<br>查看防火墙是否开启<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl status firewalld</div></pre></td></tr></table></figure></p>
<p>如果开启了，则原因就是刚刚设置的ssh端口6983并没有添加到防火墙中<br>添加端口到防火墙<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo firewall-cmd --zone=public --permanent --add-port=6983/tcp</div></pre></td></tr></table></figure></p>
<p>重启防火墙<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl restart firewalld</div></pre></td></tr></table></figure></p>
<p>查看端口是否添加成功</p>
<p>执行<code>sudo firewall-cmd --list-all</code>，如果出现以下输出，则证明添加成功</p>
<img src="/2016/08/01/CentOS7服务器初步配置/-----2016-08-22---11-18-34.png" alt="-----2016-08-22---11-18-34.png" title="">
<h2 id="第五步-登录服务器"><a href="#第五步-登录服务器" class="headerlink" title="第五步 登录服务器"></a>第五步 登录服务器</h2><p>SSH的配置已经完成了，下面测试以下是否可以登录</p>
<p>输入<code>ssh sangjian@192.168.1.125 -p 6983</code>，提示</p>
<img src="/2016/08/01/CentOS7服务器初步配置/-----2016-08-22---11-20-02.png" alt="-----2016-08-22---11-20-02.png" title="">
<p>表示已经登录成功了，至此基于Centos7的服务器初步配置已经完成了。</p>
<p>本文主要介绍了SSH配置，剩下的可以根据需要配置一些安全相关的设置，比如防火墙的设置，端口的限制等等。</p>
]]></content>
    </entry>
    
  
  
</search>
